{
  "version": 3,
  "sources": ["../src/index.ts", "../src/io/index.ts", "../src/io/fileProvider.ts", "../src/models/hook.ts", "../src/models/httpFileHooks.ts", "../src/models/httpRegionAction.ts", "../src/models/httpSymbolKind.ts", "../src/models/logHandler.ts", "../src/models/processorContext.ts", "../src/models/protoDefinition.ts", "../src/models/repeatOptions.ts", "../src/models/testFunction.ts", "../src/models/variableType.ts", "../src/utils/index.ts", "../src/utils/assertUtils.ts", "../src/utils/stringUtils.ts", "../src/utils/mimeTypeUtils.ts", "../src/utils/requestUtils.ts", "../src/utils/fsUtils.ts", "../src/utils/moduleUtils.ts", "../src/utils/promiseUtils.ts", "../src/utils/configUtils.ts", "../src/utils/environmentUtils.ts", "../src/utils/errorUtils.ts", "../src/utils/httpRegionUtils.ts", "../src/utils/httpStringUtils.ts", "../src/utils/logUtils.ts", "../src/utils/markdownUtils.ts", "../src/utils/variableUtils.ts", "../src/io/gotHttpClientFactory.ts", "../src/io/logger.ts", "../src/io/userInteractionProvider.ts", "../src/store/index.ts", "../src/store/cookieStore.ts", "../src/parser/index.ts", "../src/parser/parserRegex.ts", "../src/parser/commentHttpRegionParser.ts", "../src/actions/index.ts", "../src/actions/cookieJarAction.ts", "../src/actions/createRequestAction.ts", "../src/actions/defaultHeadersAction.ts", "../src/actions/envDefaultsHeaderAction.ts", "../src/actions/eventSourceClientAction.ts", "../src/actions/gqlAction.ts", "../src/actions/grpcClientAction.ts", "../src/actions/httpClientAction.ts", "../src/actions/loopMetaAction.ts", "../src/actions/intellij/intellijHttpClient.ts", "../src/actions/testMethod.ts", "../src/variables/provider/index.ts", "../src/variables/provider/dotenvVariableProvider.ts", "../src/variables/provider/configVariableProvider.ts", "../src/variables/provider/intellijVariableProvider.ts", "../src/variables/provider/intellijGlobalVariableProvider.ts", "../src/variables/provider/initHooks.ts", "../src/actions/intellij/intellijVariables.ts", "../src/actions/intellij/intellijHttpResponse.ts", "../src/actions/intellijAction.ts", "../src/actions/importMetaAction.ts", "../src/actions/requestVariableReplacer.ts", "../src/actions/transformRequestBodyAction.ts", "../src/actions/responseAsVariableAction.ts", "../src/actions/initHooks.ts", "../src/actions/mqttClientAction.ts", "../src/actions/createReqeustBodyInterceptor.ts", "../src/actions/refMetaAction.ts", "../src/actions/webSocketClientAction.ts", "../src/parser/metaData/defaultMetaDataHandler.ts", "../src/parser/metaData/importMetaDataHandler.ts", "../src/parser/metaData/refMetaDataHandler.ts", "../src/parser/metaData/loopMetaDataHandler.ts", "../src/parser/metaData/keepStreamingMetaDataHandler.ts", "../src/parser/metaData/rateLimitMetaDataHandler.ts", "../src/parser/metaData/responseRefMetaDataHandler.ts", "../src/parser/metaData/sleepMetaDataHandler.ts", "../src/parser/metaData/verboseMetaDataHandler.ts", "../src/parser/metaHttpRegionParser.ts", "../src/parser/parserUtils.ts", "../src/parser/eventSourceHttpRegionParser.ts", "../src/parser/gqlHttpRegionParser.ts", "../src/parser/httpFileParser.ts", "../src/parser/intellijHttpRegionParser.ts", "../src/parser/javascriptHttpRegionParser.ts", "../src/parser/requestBodyHttpRegionParser.ts", "../src/parser/requestHttpRegionParser.ts", "../src/parser/responseHttpRegionParser.ts", "../src/parser/responseRefHttpRegionParser.ts", "../src/parser/outputRedirectionHttpRegionParser.ts", "../src/parser/variableHttpRegionParser.ts", "../src/parser/protoHttpRegionParser.ts", "../src/parser/grpcHttpRegionParser.ts", "../src/parser/websocketHttpRegionParser.ts", "../src/parser/mqtttHttpRegionParser.ts", "../src/parser/noteMetaHttpRegionParser.ts", "../src/parser/cancelExecutionInterceptor.ts", "../src/parser/initHooks.ts", "../src/variables/index.ts", "../src/variables/replacer/index.ts", "../src/variables/replacer/awsAuthVariableReplacer.ts", "../src/variables/replacer/basicAuthVariableReplacer.ts", "../src/variables/replacer/clientCertVariableReplacer.ts", "../src/variables/replacer/digestAuthVariableReplacer.ts", "../src/variables/replacer/escapeVariableReplacer.ts", "../src/variables/replacer/hostVariableReplacer.ts", "../src/variables/replacer/intellijVariableReplacer.ts", "../src/variables/replacer/javascriptVariableReplacer.ts", "../src/variables/replacer/oauth/openIdConfiguration.ts", "../src/variables/replacer/oauth/openIdInformation.ts", "../src/variables/replacer/oauth/authorizationCodeFlow.ts", "../src/variables/replacer/oauth/openIdHttpserver.ts", "../src/variables/replacer/oauth/clientCredentialsFlow.ts", "../src/variables/replacer/oauth/deviceCodeFlow.ts", "../src/variables/replacer/oauth/implicitFlow.ts", "../src/variables/replacer/oauth/refreshTokenFlow.ts", "../src/variables/replacer/oauth/passwordFlow.ts", "../src/variables/replacer/oauth/tokenExchangeFlow.ts", "../src/variables/replacer/oauth2VariableReplacer.ts", "../src/variables/replacer/restClientVariableReplacer.ts", "../src/variables/replacer/showInputBoxVariableReplacer.ts", "../src/variables/replacer/showQuickpickVariableReplacer.ts", "../src/variables/replacer/initHooks.ts", "../src/store/httpFileStore.ts", "../src/store/userSessionStore.ts", "../src/httpYacApi.ts", "../src/cli/index.ts", "../src/cli/cli.ts", "../src/cli/cliOptions.ts", "../src/cli/cliJsonOutput.ts", "../src/cli/initCliProvider.ts"],
  "sourcesContent": ["export * from './httpYacApi';\r\nexport * from './models';\r\n\r\nexport * as actions from './actions';\r\nexport * as cli from './cli';\r\nexport * as io from './io';\r\nexport * as parser from './parser';\r\nexport * as store from './store';\r\nexport * as utils from './utils';\r\nexport * as variables from './variables';\r\n", "export * from './fileProvider';\r\nexport * from './gotHttpClientFactory';\r\nexport * from './logger';\r\nexport * from './userInteractionProvider';\r\n", "import { FileProvider, PathLike } from '../models';\r\n\r\nexport const fileProvider: FileProvider = {\r\n  exists: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  dirname: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  isAbsolute: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  joinPath: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  readFile: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  readBuffer: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  writeBuffer: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  readdir: () => {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  fsPath: toString,\r\n  toString\r\n};\r\n\r\nfunction toString(fileName: PathLike): string {\r\n  if (typeof fileName === 'string') {\r\n    return fileName;\r\n  }\r\n  return fileName.toString();\r\n}\r\n", "import { log } from '../io';\r\n\r\ninterface BaseHookItem {\r\n  id: string;\r\n  before?: Array<string>;\r\n  after?: Array<string>;\r\n}\r\n\r\nexport const HookCancel = Symbol('cancel hook run');\r\n\r\n\r\nexport interface HookItem<T, TReturn> extends BaseHookItem {\r\n  action(arg: T, arg1?: unknown, arg2?: unknown): TReturn | typeof HookCancel | Promise<TReturn | typeof HookCancel>;\r\n}\r\n\r\nexport interface HookInterceptor<T, TReturn> {\r\n  register?(item: HookItem<T, TReturn>): boolean;\r\n  beforeLoop?(context: HookTriggerContext<T, TReturn>): Promise<boolean | undefined>;\r\n  beforeTrigger?(context: HookTriggerContext<T, TReturn>): Promise<boolean | undefined>;\r\n  afterTrigger?(context: HookTriggerContext<T, TReturn>): Promise<boolean | undefined>;\r\n  afterLoop?(context: HookTriggerContext<T, TReturn>): Promise<boolean | undefined>;\r\n}\r\n\r\n\r\nexport interface HookTriggerContext<T, TReturn> {\r\n  index: number;\r\n  length: number;\r\n  arg: T\r\n  hookItem?: HookItem<T, TReturn>\r\n}\r\n\r\n\r\nexport abstract class Hook<T, TReturn, TTriggerResult, TArg = undefined, TArg2 = undefined> {\r\n  protected items: Array<HookItem<T, TReturn>>;\r\n  protected interceptors: Array<HookInterceptor<T, TReturn>>;\r\n\r\n  id: string;\r\n\r\n  constructor(private readonly bailOut?: ((arg: TReturn) => boolean) | undefined) {\r\n    this.id = this.constructor.name;\r\n    this.items = [];\r\n    this.interceptors = [];\r\n  }\r\n\r\n  hasHook(id: string) {\r\n    return this.items.some(obj => obj.id === id);\r\n  }\r\n\r\n  addHook(id: string, action: (arg: T, arg1: TArg, arg2: TArg2) => TReturn | typeof HookCancel | Promise<TReturn | typeof HookCancel>, options?: {\r\n    before?: Array<string>;\r\n    after?: Array<string>;\r\n  }): void {\r\n    const item = {\r\n      id,\r\n      action,\r\n      ...options\r\n    };\r\n    if (item.before) {\r\n      const index = Math.min(...this.getIndeces(item.before));\r\n      if (index >= 0) {\r\n        this.items.splice(index, 0, item);\r\n        return;\r\n      }\r\n    }\r\n    if (item.after) {\r\n      const index = Math.max(...this.getIndeces(item.after));\r\n      if (index >= 0) {\r\n        this.items.splice(index + 1, 0, item);\r\n        return;\r\n      }\r\n    }\r\n    this.items.push(item);\r\n  }\r\n\r\n  private getIndeces(ids: Array<string>) {\r\n    return ids\r\n      .map(before => this.items.findIndex(obj => obj.id === before))\r\n      .filter(obj => obj >= 0);\r\n  }\r\n\r\n  addObjHook<TObj extends BaseHookItem>(\r\n    getAction: (obj: TObj) => ((arg: T, arg1?: TArg, arg2?: TArg2) => Promise<TReturn | typeof HookCancel>),\r\n    ...objs: TObj[]\r\n  ): void {\r\n    for (const obj of objs) {\r\n      this.addHook(obj.id, getAction(obj).bind(obj), obj);\r\n    }\r\n  }\r\n\r\n  removeHook(id: string): boolean {\r\n    const index = this.items.findIndex(obj => obj.id === id);\r\n    if (index >= 0) {\r\n      this.items.splice(index, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  addInterceptor(interceptor: HookInterceptor<T, TReturn>): void {\r\n    this.interceptors.push(interceptor);\r\n  }\r\n  removeInterceptor(interceptor: HookInterceptor<T, TReturn>): boolean {\r\n    const index = this.interceptors.indexOf(interceptor);\r\n    if (index >= 0) {\r\n      this.interceptors.splice(index, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async trigger(arg: T, arg1?: TArg, arg2?: TArg2): Promise<TTriggerResult | typeof HookCancel> {\r\n    const results: TReturn[] = [];\r\n    const context: HookTriggerContext<T, TReturn> = {\r\n      index: 0,\r\n      length: this.items.length,\r\n      arg\r\n    };\r\n\r\n    if ((await this.intercept(obj => obj.beforeLoop, context)) === false) {\r\n      return HookCancel;\r\n    }\r\n\r\n    while (context.index < context.length) {\r\n      context.hookItem = this.items[context.index];\r\n      log.trace(`${this.id}: ${context.hookItem.id} started`);\r\n      try {\r\n\r\n        if ((await this.intercept(obj => obj.beforeTrigger, context)) === false) {\r\n          return HookCancel;\r\n        }\r\n\r\n        const result = await context.hookItem.action(context.arg, arg1, arg2);\r\n        if (result === HookCancel) {\r\n          return HookCancel;\r\n        }\r\n        if (this.bailOut && this.bailOut(result)) {\r\n          results.push(result);\r\n          return this.getMergedResults(results, arg);\r\n        }\r\n        results.push(result);\r\n        context.arg = this.getNextArg(result, arg);\r\n\r\n        if ((await this.intercept(obj => obj.afterTrigger, context)) === false) {\r\n          return HookCancel;\r\n        }\r\n        context.index++;\r\n      } catch (err) {\r\n        log.error(`${this.id}: ${context.hookItem.id} failed`);\r\n        throw err;\r\n      }\r\n    }\r\n    if ((await this.intercept(obj => obj.afterLoop, context)) === false) {\r\n      return HookCancel;\r\n    }\r\n    return this.getMergedResults(results, arg);\r\n  }\r\n\r\n\r\n  private async intercept(\r\n    method: (interceptor: HookInterceptor<T, TReturn>) => ((context: HookTriggerContext<T, TReturn>) => Promise<boolean | void>) | undefined,\r\n    context: HookTriggerContext<T, TReturn>\r\n  ) {\r\n    for (const interceptor of this.interceptors) {\r\n      const event = method(interceptor);\r\n      if (event) {\r\n        const result = await event.apply(interceptor, [context]);\r\n        if (!result) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  protected abstract getNextArg(_next: TReturn, current: T): T;\r\n\r\n\r\n  protected abstract getMergedResults(results: TReturn[], arg: T): TTriggerResult;\r\n}\r\n\r\nexport class SeriesHook<T, TReturn, TBail = void, TArg = undefined, TArg2 = undefined> extends Hook<T, TReturn | TBail, Array<TReturn>, TArg, TArg2> {\r\n  constructor(bailOut?: ((arg: TReturn | TBail) => boolean) | undefined) {\r\n    super(bailOut);\r\n  }\r\n  protected getNextArg(_next: TReturn, current: T): T {\r\n    return current;\r\n  }\r\n\r\n  protected getMergedResults(results: TReturn[]): TReturn[] {\r\n    return results;\r\n  }\r\n}\r\n\r\nexport class BailSeriesHook<T, TReturn, TBail = void, TArg = undefined, TArg2 = undefined>\r\n  extends Hook<T, TReturn | TBail, TReturn | undefined, TArg, TArg2> {\r\n  constructor(bailOut?: ((arg: TReturn | TBail | undefined) => boolean) | undefined) {\r\n    super(bailOut);\r\n  }\r\n  protected getNextArg(_next: TReturn, current: T): T {\r\n    return current;\r\n  }\r\n\r\n  protected getMergedResults(results: TReturn[]): TReturn | undefined {\r\n    return results.pop();\r\n  }\r\n}\r\n\r\n\r\nexport class WaterfallHook<T, TBail = T, TArg = undefined, TArg2 = undefined> extends Hook<T, T | TBail, T | TBail, TArg, TArg2> {\r\n  constructor(bailOut?: ((arg: T | TBail) => boolean) | undefined) {\r\n    super(bailOut);\r\n  }\r\n  protected getNextArg(next: T): T {\r\n    return next;\r\n  }\r\n\r\n  protected getMergedResults(results: T[], arg: T): T {\r\n    return results.pop() || arg;\r\n  }\r\n}\r\n", "import { BailSeriesHook, WaterfallHook, SeriesHook } from './hook';\r\nimport { HttpRegionParserResult } from './httpRegionParserResult';\r\nimport { Request } from './httpRequest';\r\nimport { HttpResponse } from './httpResponse';\r\nimport { getHttpLineGenerator, ParserContext } from './parserContext';\r\nimport { ProcessorContext } from './processorContext';\r\nimport { VariableProviderContext } from './variableProviderContext';\r\nimport { Variables } from './variables';\r\n\r\nexport interface HttpFileHooks{\r\n  readonly parse: ParseHook,\r\n  readonly parseEndRegion: ParseEndRegionHook,\r\n  readonly replaceVariable: ReplaceVariableHook;\r\n  readonly provideEnvironments: ProvideEnvironmentsHook;\r\n  readonly provideVariables: ProvideVariablesHook;\r\n\r\n\r\n  readonly onRequest: OnRequestHook;\r\n  readonly onResponse: OnResponseHook,\r\n  readonly responseLogging: ResponseLoggingHook,\r\n}\r\n\r\nexport class ParseHook extends BailSeriesHook<getHttpLineGenerator,\r\n  HttpRegionParserResult,\r\n  false,\r\n  ParserContext\r\n> {\r\n  constructor() {\r\n    super(obj => !!obj);\r\n    this.id = 'ParseHook';\r\n  }\r\n}\r\n\r\nexport class ParseEndRegionHook extends SeriesHook<ParserContext, void> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'ParseEndRegionHook';\r\n  }\r\n}\r\nexport class ProvideVariablesHook extends SeriesHook<string[] | undefined, Variables, string, VariableProviderContext> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'ProvideVariablesHook';\r\n  }\r\n}\r\nexport class ProvideEnvironmentsHook extends SeriesHook<VariableProviderContext, string[], string> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'ProvideEnvironmentsHook';\r\n  }\r\n}\r\nexport class ReplaceVariableHook extends WaterfallHook<unknown, undefined, string, ProcessorContext> {\r\n  constructor() {\r\n    super(obj => obj === undefined);\r\n    this.id = 'ReplaceVariableHook';\r\n  }\r\n}\r\nexport class OnRequestHook extends SeriesHook<Request, void, Request, ProcessorContext> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'BeforeRequestHook';\r\n  }\r\n}\r\nexport class OnResponseHook extends SeriesHook<HttpResponse, void, HttpResponse, ProcessorContext> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'AfterRequestHook';\r\n  }\r\n}\r\n\r\nexport class OnStreaming extends SeriesHook<ProcessorContext, void> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'OnStreaming';\r\n  }\r\n}\r\nexport class ResponseLoggingHook extends BailSeriesHook<HttpResponse, void, HttpResponse, ProcessorContext> {\r\n  constructor() {\r\n    super();\r\n    this.id = 'ResponseLoggingHook';\r\n  }\r\n}\r\nexport class ExecuteHook extends SeriesHook<ProcessorContext, boolean> {\r\n  constructor() {\r\n    super(obj => !obj);\r\n    this.id = 'ExecuteHook';\r\n  }\r\n}\r\n", "import { ProcessorContext } from './processorContext';\r\n\r\n\r\n/**\r\n * @returns false if processing cancelled\r\n */\r\nexport interface HttpRegionAction {\r\n  id: ActionType | string;\r\n  process(context: ProcessorContext): Promise<boolean>;\r\n}\r\n\r\nexport enum ActionType{\r\n  cookieJar = 'cookieJar',\r\n  defaultHeaders = 'defaultHeaders',\r\n  eventSourceClient = 'eventSourceClient',\r\n  intellij = 'intellij',\r\n  gql = 'gql',\r\n  loop = 'loop',\r\n  js = 'js',\r\n  protoImport = 'protoImport',\r\n  protoCreate = 'protoCreate',\r\n  grpcClient = 'grpcClient',\r\n  httpClient = 'httpClient',\r\n  import = 'import',\r\n  ref = 'ref',\r\n  variable = 'variable',\r\n  websocketClient = 'websocketClient',\r\n}\r\n", "export enum HttpSymbolKind {\r\n  request = 'request',\r\n  requestLine = 'requestLine',\r\n  requestHeader = 'requestHeader',\r\n  requestBody = 'requestBody',\r\n  response = 'response',\r\n  gql = 'gql',\r\n  proto = 'proto',\r\n  script = 'script',\r\n  metaData = 'metaData',\r\n  comment = 'comment',\r\n\r\n  url = 'url',\r\n  operator = 'operator',\r\n  key = 'key',\r\n  value = 'value',\r\n  variable = 'variable',\r\n  text = 'text',\r\n}\r\n", "import { HttpRegion } from './httpRegion';\r\nimport { HttpResponse } from './httpResponse';\r\n\r\nexport enum LogLevel{\r\n  trace = 1,\r\n  debug = 2,\r\n  warn = 5,\r\n  info = 10,\r\n  error = 100,\r\n  none = 1000,\r\n}\r\n\r\nexport interface LogHandler {\r\n  readonly options: {\r\n    level?: LogLevel,\r\n    logMethod?: (level: LogLevel, ...params: unknown[]) => void,\r\n  }\r\n  info(...params: unknown[]): void;\r\n  log(...params: unknown[]): void;\r\n  trace(...params: unknown[]): void;\r\n  debug(...params: unknown[]): void;\r\n  error(...params: unknown[]): void;\r\n  warn(...params: unknown[]): void;\r\n}\r\n\r\nexport interface ConsoleLogHandler extends LogHandler{\r\n  logTest(result: boolean, message: string): void;\r\n  collectMessages(): void;\r\n  flush() : void;\r\n}\r\n\r\n\r\nexport type RequestLogger = (response: HttpResponse, httpRegion?: HttpRegion) => Promise<void>;\r\n\r\nexport type StreamLogger = (channel: string, type: string, message: unknown) => Promise<void>;\r\n", "import { ConsoleLogHandler, RequestLogger, StreamLogger } from './logHandler';\r\nimport { HttpClient } from './httpClient';\r\nimport { HttpFile } from './httpFile';\r\nimport { HttpRegion, ProcessedHttpRegion } from './httpRegion';\r\nimport { Request } from './httpRequest';\r\nimport { RepeatOptions } from './repeatOptions';\r\nimport { Variables } from './variables';\r\nimport { EnvironmentConfig } from './environmentConfig';\r\n\r\n\r\nexport type Dispose = () => void;\r\n\r\nexport interface Progress{\r\n  isCanceled: () => boolean;\r\n  register: (event: (() => void)) => Dispose;\r\n  report?: (value: { message?: string, increment?: number }) => void;\r\n}\r\n\r\nexport interface HttpFileSendContext{\r\n  httpFile: HttpFile;\r\n  config?: EnvironmentConfig,\r\n  progress?: Progress;\r\n  httpClient?: HttpClient;\r\n  httpRegionPredicate?: (obj: HttpRegion) => boolean;\r\n  processedHttpRegions?: Array<ProcessedHttpRegion>;\r\n  scriptConsole?: ConsoleLogHandler;\r\n  logStream?: StreamLogger;\r\n  logResponse?: RequestLogger;\r\n  repeat?: RepeatOptions;\r\n  require?: Record<string, unknown>,\r\n}\r\n\r\nexport interface HttpRegionsSendContext extends HttpFileSendContext{\r\n  httpRegions: HttpRegion[];\r\n}\r\n\r\nexport interface HttpRegionSendContext extends HttpFileSendContext{\r\n  httpRegion: HttpRegion;\r\n}\r\nexport interface ProcessorContext extends HttpRegionSendContext{\r\n  httpClient: HttpClient;\r\n  variables: Variables;\r\n  request?: Request;\r\n  showProgressBar?: boolean;\r\n  options: Record<string, unknown>\r\n}\r\n\r\nexport function isProcessorContext(context: unknown): context is ProcessorContext {\r\n  const test = context as ProcessorContext;\r\n  return !!test?.httpClient && !!test?.httpFile && !!test?.variables && !!test?.config;\r\n}\r\n\r\n\r\nexport type SendContext = HttpRegionSendContext | HttpFileSendContext | HttpRegionsSendContext;\r\n", "import { GrpcObject } from '@grpc/grpc-js';\r\nimport { PackageDefinition } from '@grpc/proto-loader';\r\n\r\nexport class ProtoDefinition {\r\n  loaderOptions: Record<string, string>;\r\n\r\n  constructor(readonly fileName: string) {\r\n    this.loaderOptions = {};\r\n  }\r\n  packageDefinition?: PackageDefinition;\r\n  grpcObject?: GrpcObject;\r\n}\r\n", "export enum RepeatOrder{\r\n  sequential,\r\n  parallel,\r\n}\r\n\r\nexport interface RepeatOptions{\r\n  type: RepeatOrder;\r\n  count: number;\r\n}\r\n", "export const testSymbols = {\r\n  ok: '\u2713',\r\n  error: '\u2716',\r\n};\r\n\r\nexport interface TestFunction{\r\n  (message: string, testMethod: () => void): void;\r\n  status(status: number): void;\r\n  header(headerKey: string, val: string | string[] | undefined): void;\r\n  headerContains(headerKey: string, val: string): void;\r\n  responseBody(val: unknown): void;\r\n  hasResponseBody(): void;\r\n  hasNoResponseBody(): void;\r\n}\r\n", "export enum VariableType{\r\n  variable ='Variable',\r\n  url = 'Url',\r\n  body = 'Body',\r\n  filePath = 'FilePath'\r\n}\r\n", "export * from './assertUtils';\r\nexport * from './configUtils';\r\nexport * from './environmentUtils';\r\nexport * from './errorUtils';\r\nexport * from './fsUtils';\r\nexport * from './httpRegionUtils';\r\nexport * from './httpStringUtils';\r\nexport * from './logUtils';\r\nexport * from './markdownUtils';\r\nexport * from './mimeTypeUtils';\r\nexport * from './moduleUtils';\r\nexport * from './stringUtils';\r\nexport * from './requestUtils';\r\nexport * from './promiseUtils';\r\nexport * from './variableUtils';\r\n", "import { HttpResponse } from '../models';\r\nimport { strictEqual, ok } from 'assert';\r\nimport { getHeader } from './requestUtils';\r\nimport { isString } from './stringUtils';\r\n\r\n\r\nexport function assertStatusEquals(response: HttpResponse, status: number): void {\r\n  strictEqual(response.statusCode, status, `response status equals to ${status}`);\r\n}\r\n\r\nexport function assertMaxTotalTime(response: HttpResponse, maxTotalTime: number): void {\r\n  ok(response.timings?.total ? response.timings.total < maxTotalTime : true, `total time exceeded ${maxTotalTime}`);\r\n}\r\n\r\nexport function assertHeaderEquals(response: HttpResponse, headerKey: string, val: string | string[] | undefined): void {\r\n  const headerValue = getHeader(response.headers, headerKey);\r\n  strictEqual(headerValue, val, `response header equals ${val}`);\r\n}\r\n\r\nexport function assertHeaderContains(response: HttpResponse, headerKey: string, val: string): void {\r\n  const headerValue = getHeader(response.headers, headerKey);\r\n  if (isString(headerValue) || Array.isArray(headerValue)) {\r\n    ok(headerValue.indexOf(val), `response header contains ${val}`);\r\n  }\r\n}\r\n\r\nexport function assertResponsetimeLower(response: HttpResponse, maxTotal: number): void {\r\n  if (response.timings?.total) {\r\n    ok(response.timings.total <= maxTotal, `response time lower ${maxTotal}`);\r\n  }\r\n}\r\n\r\nexport function assertHasResponseBody(response: HttpResponse): void {\r\n  ok(!!response.body, 'response body exists');\r\n}\r\nexport function assertHasNoResponseBody(response: HttpResponse): void {\r\n  ok(!response.body, 'response body does not exists');\r\n}\r\n\r\nexport function assertResponseBodyEquals(response: HttpResponse, val: unknown): void {\r\n  strictEqual(response.body, val, `response body equals ${val}`);\r\n}\r\n", "import { EOL } from 'os';\r\n\r\nexport function toMultiLineString(lines: Array<string>) : string {\r\n  return lines.join(EOL);\r\n}\r\n\r\nexport function toMultiLineArray(text: string) : Array<string> {\r\n  return text.split(/\\r?\\n/gu);\r\n}\r\n\r\nexport function isString(text: unknown): text is string {\r\n  return typeof text === 'string';\r\n}\r\n\r\nexport function toNumber<T>(text: string | undefined, defaultVal?: T|undefined): number | T | undefined {\r\n  if (text) {\r\n    const number = Number.parseInt(text, 10);\r\n    if (!Number.isNaN(number)) {\r\n      return number;\r\n    }\r\n  }\r\n  return defaultVal;\r\n}\r\n\r\n\r\nexport function isStringEmpty(text: unknown) : boolean {\r\n  return typeof text === 'string' && /^(\\s*)?$/u.test(text);\r\n}\r\n\r\nexport function stateGenerator(length = 30) : string {\r\n  const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n  const result = [];\r\n  for (let i = length; i > 0; --i) {\r\n    result.push(chars[Math.floor(Math.random() * chars.length)]);\r\n  }\r\n  return result.join('');\r\n}\r\n", "import { ContentType } from '../models';\r\n\r\nexport function parseMimeType(contentType: string): ContentType {\r\n  const [mimeType, ...parameters] = contentType.split(';').map(v => v.trim());\r\n  const charset = parameters.find(p => p.startsWith('charset='))?.split('=')[1];\r\n  return { mimeType, contentType, charset };\r\n}\r\n\r\nexport function isMimeTypeJSON(contentType: ContentType | undefined) : boolean {\r\n  return !!contentType && (\r\n    contentType.mimeType === 'application/json'\r\n    || contentType.mimeType.indexOf('+json') >= 0\r\n    || contentType.mimeType.indexOf('x-amz-json') >= 0\r\n  );\r\n}\r\nexport function isMimeTypeJavascript(contentType: ContentType | undefined) : boolean {\r\n  return contentType?.mimeType === 'application/javascript'\r\n    || contentType?.mimeType === 'text/x-javascript';\r\n}\r\nexport function isMimeTypeXml(contentType: ContentType | undefined) : boolean {\r\n  return !!contentType && (\r\n    contentType.mimeType === 'application/xml'\r\n    || contentType.mimeType === 'text/xml'\r\n    || contentType.mimeType.indexOf('+xml') >= 0\r\n  );\r\n}\r\nexport function isMimeTypeHtml(contentType: ContentType | undefined) : boolean {\r\n  return contentType?.mimeType === 'text/html';\r\n\r\n}\r\nexport function isMimeTypeCSS(contentType: ContentType | undefined) : boolean {\r\n  return contentType?.mimeType === 'text/css';\r\n}\r\n\r\nexport function isMimeTypeMarkdown(contentType: ContentType | undefined) : boolean {\r\n  return contentType?.mimeType === 'text/markdown';\r\n}\r\n\r\nexport function isMimeTypeMultiPartFormData(contentType: ContentType | undefined): boolean {\r\n  return contentType?.mimeType === 'multipart/form-data';\r\n}\r\n\r\nexport function isMimeTypeNewlineDelimitedJSON(contentType: ContentType | undefined): boolean {\r\n  return contentType?.mimeType === 'application/x-ndjson';\r\n}\r\n\r\nexport function isMimeTypeFormUrlEncoded(contentType: ContentType | undefined): boolean {\r\n  return contentType?.mimeType === 'application/x-www-form-urlencoded';\r\n}\r\n\r\nexport function isMimeTypePdf(contentType: ContentType | undefined): boolean {\r\n  return contentType?.mimeType === 'application/pdf';\r\n}\r\n\r\nexport function isMimeTypeImage(contentType: ContentType | undefined): boolean {\r\n  if (contentType) {\r\n    return ['image/jpeg',\r\n      'image/gif',\r\n      'image/webp',\r\n      'image/png',\r\n      'image/bmp'].indexOf(contentType.mimeType) >= 0;\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../models';\r\nimport { isString, toMultiLineString } from './stringUtils';\r\nimport { isMimeTypeJSON, isMimeTypeXml, parseMimeType } from './mimeTypeUtils';\r\nimport { default as chalk } from 'chalk';\r\nimport { log } from '../io';\r\nimport xmlFormat from 'xml-formatter';\r\nimport { TextDecoder } from 'util';\r\n\r\n\r\nexport function isHttpRequestMethod(method: string | undefined): method is models.HttpMethod {\r\n  if (method) {\r\n    return ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'CONNECT', 'TRACE',\r\n      'PROPFIND', 'PROPPATCH', 'MKCOL', 'COPY', 'MOVE', 'LOCK', 'UNLOCK', 'CHECKOUT', 'CHECKIN', 'REPORT', 'MERGE', 'MKACTIVITY', 'MKWORKSPACE', 'VERSION-CONTROL', 'BASELINE-CONTROL' // cal-dav\r\n    ]\r\n      .includes(method.toUpperCase());\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function isHttpRequest(request: models.Request | undefined): request is models.HttpRequest {\r\n  return isHttpRequestMethod(request?.method);\r\n}\r\n\r\nexport function isWebsocketRequest(request: models.Request | undefined): request is models.WebsocketRequest {\r\n  return request?.method === 'WS';\r\n}\r\n\r\nexport function isEventSourceRequest(request: models.Request | undefined): request is models.EventSourceRequest {\r\n  return request?.method === 'SSE';\r\n}\r\n\r\nexport function isMQTTRequest(request: models.Request | undefined): request is models.MQTTRequest {\r\n  return request?.method === 'MQTT';\r\n}\r\n\r\nexport function isGrpcRequest(request: models.Request | undefined): request is models.GrpcRequest {\r\n  return request?.method === 'GRPC';\r\n}\r\n\r\nexport function deleteHeader(headers: Record<string, unknown> | undefined, ...headerNames: string[]): void {\r\n  if (headers) {\r\n    for (const headerName of headerNames) {\r\n      const entry = Object.entries(headers)\r\n        .find(([key]) => key.toLowerCase() === headerName.toLowerCase());\r\n      if (entry && entry.length > 1) {\r\n        delete headers[entry[0]];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getHeader<T>(headers: Record<string, T> | undefined, headerName: string): T | undefined {\r\n  if (headers) {\r\n    const entry = Object.entries(headers)\r\n      .find(([key]) => key.toLowerCase() === headerName.toLowerCase());\r\n    if (entry && entry.length > 1) {\r\n      return entry[1];\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\nexport function getHeaderArray(headers: Record<string, string | string[] | undefined> | undefined, headerName: string): string[] | undefined {\r\n  const value = getHeader(headers, headerName);\r\n  if (value) {\r\n    return isString(value) ? [value] : value;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport function parseContentType(headers: Record<string, unknown>): models.ContentType | undefined {\r\n  const contentType = getHeader(headers, 'content-type');\r\n  if (isString(contentType)) {\r\n    return parseMimeType(contentType);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport interface JWTToken {\r\n  iss?: string;\r\n  sub?: string;\r\n  aud?: string[];\r\n  exp?: number;\r\n  iat?: number;\r\n  jti?: string;\r\n  scope?: string;\r\n  name?: string;\r\n}\r\n\r\n\r\nexport function decodeJWT(str: string): JWTToken | null {\r\n  try {\r\n    const jwtComponents = str.split('.');\r\n    if (jwtComponents.length !== 3) {\r\n      return null;\r\n    }\r\n    let payload = jwtComponents[1];\r\n    payload = payload.replace(/-/gu, '+');\r\n    payload = payload.replace(/_/gu, '/');\r\n    switch (payload.length % 4) {\r\n      case 0:\r\n        break;\r\n      case 2:\r\n        payload += '==';\r\n        break;\r\n      case 3:\r\n        payload += '=';\r\n        break;\r\n      default:\r\n        return null;\r\n    }\r\n\r\n    const result = (new TextDecoder()).decode(Buffer.from(payload, 'base64'));\r\n    return JSON.parse(result);\r\n  } catch (err) {\r\n    log.warn(err);\r\n    return null;\r\n  }\r\n}\r\n\r\n\r\nexport function toQueryParams(params: Record<string, undefined | string | number | boolean>): string {\r\n  return Object.entries(params)\r\n    .filter(([, value]) => !!value)\r\n    .map(([key, value]) => `${key}=${encodeURIComponent(value || '')}`)\r\n    .join('&');\r\n}\r\n\r\nexport interface RequestLoggerFactoryOptions {\r\n  useShort?: boolean;\r\n  requestOutput?: boolean;\r\n  requestHeaders?: boolean;\r\n  requestBodyLength?: number;\r\n  responseHeaders?: boolean;\r\n  responseBodyPrettyPrint?: boolean,\r\n  responseBodyLength?: number;\r\n  onlyFailed?: boolean;\r\n}\r\n\r\nexport function requestLoggerFactory(\r\n  log: (args: string) => void,\r\n  options: RequestLoggerFactoryOptions,\r\n  optionsFailed?: RequestLoggerFactoryOptions\r\n): models.RequestLogger {\r\n\r\n  return async function logResponse(response: models.HttpResponse, httpRegion?: models.HttpRegion): Promise<void> {\r\n\r\n    let opt = options;\r\n    if (optionsFailed && httpRegion?.testResults && httpRegion.testResults.some(obj => !obj.result)) {\r\n      opt = optionsFailed;\r\n    }\r\n\r\n    if (opt.onlyFailed\r\n      && (!httpRegion?.testResults || httpRegion.testResults.every(obj => obj.result))) {\r\n      return;\r\n    }\r\n\r\n    log('');\r\n    log('---------------------');\r\n    log('');\r\n    if (httpRegion?.metaData?.title || httpRegion?.metaData?.description) {\r\n      if (httpRegion?.metaData?.title) {\r\n        log(chalk`{gray === ${httpRegion.metaData.title} ===}`);\r\n      }\r\n      if (httpRegion?.metaData?.description) {\r\n        log(chalk`{gray ${httpRegion.metaData.description}}`);\r\n      }\r\n      log('');\r\n    }\r\n    if (opt.useShort) {\r\n      log(chalk`{yellow ${response.request?.method || 'GET'}} {gray ${response.request?.url || '?'}}`);\r\n      log(chalk`{gray =>} {cyan.bold ${response.statusCode}} ({yellow ${response.timings?.total || '?'} ms}, {yellow ${response.meta?.size || '?'}})`);\r\n    } else {\r\n\r\n      const result: Array<string> = [];\r\n      if (response.request && opt.requestOutput) {\r\n        result.push(...logRequest(response.request, {\r\n          headers: opt.requestHeaders,\r\n          bodyLength: opt.requestBodyLength,\r\n        }));\r\n      }\r\n\r\n      if (opt.responseHeaders) {\r\n        if (result.length > 0) {\r\n          result.push('');\r\n        }\r\n        result.push(...logResponseHeader(response));\r\n      }\r\n\r\n      if (isString(response.body) && opt.responseBodyLength !== undefined) {\r\n        if (result.length > 0) {\r\n          result.push('');\r\n        }\r\n        let body = response.body;\r\n        if (options.responseBodyPrettyPrint && response.prettyPrintBody) {\r\n          body = response.prettyPrintBody;\r\n        }\r\n        body = getPartOfBody(body, opt.responseBodyLength);\r\n        result.push(body);\r\n      }\r\n      log(toMultiLineString(result));\r\n    }\r\n  };\r\n}\r\n\r\nfunction getPartOfBody(body: string, length: number) {\r\n  let result = body;\r\n  if (length > 0) {\r\n    result = body.slice(0, Math.min(body.length, length));\r\n    if (body.length >= length) {\r\n      result += `... (${body.length - length} characters  more)`;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction logRequest(request: models.Request, options: {\r\n  headers?: boolean,\r\n  bodyLength?: number,\r\n}) {\r\n  const result: Array<string> = [];\r\n  result.push(chalk`{cyan.bold ${request.method} ${request.url}}`);\r\n  if (request.headers && options.headers) {\r\n    result.push(...Object.entries(request.headers)\r\n      .map(([key, value]) => chalk`{yellow ${key}}: ${value}`)\r\n      .sort());\r\n  }\r\n  if (isHttpRequest(request) && (request.https?.certificate || request.https?.pfx)) {\r\n    result.push(chalk`{yellow client-cert}: true`);\r\n  }\r\n  if (isString(request.body) && options.bodyLength !== undefined) {\r\n    result.push('');\r\n    result.push(chalk`{gray ${getPartOfBody(request.body, options.bodyLength)}}`);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction logResponseHeader(response: models.HttpResponse) {\r\n  const result: Array<string> = [];\r\n  result.push(chalk`{cyan.bold ${response.protocol}} {cyan.bold ${response.statusCode}} {bold ${response.statusMessage ? ` - ${response.statusMessage}` : ''}}`);\r\n  if (response.headers) {\r\n    result.push(...Object.entries(response.headers)\r\n      .filter(([key]) => !key.startsWith(':'))\r\n      .map(([key, value]) => chalk`{yellow ${key}}: ${value}`)\r\n      .sort());\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\nexport function cloneResponse(response: models.HttpResponse): models.HttpResponse {\r\n  const clone: models.HttpResponse = {\r\n    protocol: response.protocol,\r\n    statusCode: response.statusCode,\r\n    statusMessage: response.statusMessage,\r\n    httpVersion: response.httpVersion,\r\n    headers: response.headers,\r\n    body: response.body,\r\n    rawBody: response.rawBody,\r\n    parsedBody: response.parsedBody,\r\n    prettyPrintBody: response.prettyPrintBody,\r\n    contentType: response.contentType,\r\n    timings: response.timings,\r\n    meta: response.meta,\r\n  };\r\n  if (response.request) {\r\n    clone.request = {\r\n      ...response.request,\r\n    };\r\n  }\r\n  return clone;\r\n}\r\n\r\n\r\nexport function setAdditionalResponseBody(httpResponse: models.HttpResponse, context?: models.ProcessorContext): void {\r\n  if (isString(httpResponse.body)\r\n    && httpResponse.body.length > 0) {\r\n    const requestPrettyPrintBodyMaxSize = context?.config?.requestPrettyPrintBodyMaxSize || 1000000;\r\n    if (isMimeTypeJSON(httpResponse.contentType)) {\r\n      try {\r\n        if (!httpResponse.parsedBody) {\r\n          httpResponse.parsedBody = JSON.parse(httpResponse.body);\r\n        }\r\n        if (!httpResponse.prettyPrintBody && httpResponse.body.length < requestPrettyPrintBodyMaxSize) {\r\n          httpResponse.prettyPrintBody = JSON.stringify(httpResponse.parsedBody, null, 2);\r\n        }\r\n      } catch (err) {\r\n        log.warn('json parse error', httpResponse.body, err);\r\n      }\r\n    } else if (isMimeTypeXml(httpResponse.contentType)\r\n      && !httpResponse.prettyPrintBody\r\n      && httpResponse.body.length < requestPrettyPrintBodyMaxSize) {\r\n      try {\r\n        httpResponse.prettyPrintBody = xmlFormat(httpResponse.body, {\r\n          collapseContent: true,\r\n          indentation: '  ',\r\n        });\r\n      } catch (err) {\r\n        log.warn('xml format error', httpResponse.body, err);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport async function triggerRequestResponseHooks(\r\n  method: () => Promise<models.HttpResponse | false>,\r\n  context: models.ProcessorContext\r\n): Promise<boolean> {\r\n  try {\r\n    if (context.request && await context.httpFile.hooks.onRequest.trigger(context.request, context) === models.HookCancel) {\r\n      return false;\r\n    }\r\n    if (context.request && await context.httpRegion.hooks.onRequest.trigger(context.request, context) === models.HookCancel) {\r\n      return false;\r\n    }\r\n\r\n    const response = await method();\r\n    if (response) {\r\n\r\n      if (await context.httpRegion.hooks.onResponse.trigger(response, context) === models.HookCancel) {\r\n        return false;\r\n      }\r\n      if (await context.httpFile.hooks.onResponse.trigger(response, context) === models.HookCancel) {\r\n        return false;\r\n      }\r\n\r\n      context.httpRegion.response = response;\r\n    }\r\n    return true;\r\n  } catch (err) {\r\n    log.error(context.request?.url, context.request, err);\r\n    throw err;\r\n  }\r\n\r\n}\r\n", "import { fileProvider } from '../io';\r\nimport { PathLike } from '../models';\r\nimport { isString } from './stringUtils';\r\n\r\n\r\nexport async function toAbsoluteFilename(fileName: PathLike | undefined, baseName: PathLike | undefined, isFolder = false): Promise<PathLike | undefined> {\r\n  if (fileName) {\r\n    if (await fileProvider.isAbsolute(fileName) && await fileProvider.exists(fileName)) {\r\n      return fileName;\r\n    }\r\n    if (baseName) {\r\n      let dirName: PathLike = baseName;\r\n      if (!isFolder) {\r\n        dirName = fileProvider.dirname(baseName) || baseName;\r\n      }\r\n      if (isString(fileName)) {\r\n        const absolute = fileProvider.joinPath(dirName, fileName);\r\n        if (await fileProvider.exists(absolute)) {\r\n          return absolute;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function extensionName(fileName: PathLike) {\r\n  const file = fileProvider.toString(fileName);\r\n  const dotIndex = file.lastIndexOf('.');\r\n  if (dotIndex > 0 && dotIndex < file.length - 2) {\r\n    return file.slice(dotIndex + 1);\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function replaceInvalidChars(fileName: string): string {\r\n  const result = fileName.replace(/[/\\\\?%*:|\"<>]/gu, '_');\r\n  return result.split('_').filter(obj => obj.length > 0).join('_');\r\n}\r\n\r\n\r\nexport function shortenFileName(fileName: string, maxChars = 50): string {\r\n  const result: Array<string> = [];\r\n\r\n  let charLength = 0;\r\n  for (const item of fileName.split('_').reverse()) {\r\n    if (item.length + charLength < maxChars) {\r\n      result.push(item);\r\n      charLength += (item.length + 1);\r\n    } else if (result.length === 0) {\r\n      result.push(item);\r\n    }\r\n  }\r\n  const joinedString = result.reverse().join('_');\r\n  return joinedString.slice(Math.max(joinedString.length - maxChars, 0));\r\n}\r\n\r\n\r\nexport async function findRootDirOfFile(filename: PathLike, workingDir?: PathLike, ...files: Array<string>): Promise<PathLike | undefined> {\r\n  let file = filename;\r\n  if (!(await fileProvider.isAbsolute(filename)) && workingDir) {\r\n    file = fileProvider.joinPath(workingDir, fileProvider.fsPath(filename));\r\n  }\r\n  return await findRootDir(fileProvider.dirname(file), ...files);\r\n}\r\n\r\nexport async function findRootDir(currentDir: PathLike | undefined, ...files: Array<string>): Promise<PathLike | undefined> {\r\n  if (currentDir) {\r\n    const dirFiles = await fileProvider.readdir(currentDir);\r\n\r\n    if (dirFiles.some(file => files.indexOf(file) >= 0)) {\r\n      return currentDir;\r\n    }\r\n    for (const file of files) {\r\n      if (dirFiles.some(obj => file.startsWith(obj))) {\r\n        const dir = fileProvider.joinPath(currentDir, file);\r\n        if (await fileProvider.exists(dir)) {\r\n          return fileProvider.dirname(dir);\r\n        }\r\n      }\r\n    }\r\n    if (fileProvider.dirname(currentDir) !== currentDir) {\r\n      return findRootDir(fileProvider.dirname(currentDir), ...files);\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n", "import path from 'path';\r\nimport Module from 'module';\r\nimport vm from 'vm';\r\nimport { log, fileProvider } from '../io';\r\nimport { isPromise } from './promiseUtils';\r\nimport { EOL } from 'os';\r\nimport { PathLike, ProcessorContext } from '../models';\r\nimport { toMultiLineArray } from './stringUtils';\r\n\r\n\r\nexport function resolveModule(request: string, context: string): string | undefined {\r\n  let resolvedPath: string | undefined;\r\n  try {\r\n    try {\r\n      resolvedPath = Module.createRequire(path.resolve(context, 'package.json')).resolve(request);\r\n    } catch (e) {\r\n      resolvedPath = require.resolve(request, { paths: [context] });\r\n    }\r\n  } catch (e) {\r\n    log.debug(e);\r\n  }\r\n  return resolvedPath;\r\n}\r\n\r\nexport function loadModule<T>(request: string, context: string, force = false): T | undefined {\r\n  try {\r\n    if (force) {\r\n      clearModule(request, context);\r\n    }\r\n    return Module.createRequire(path.resolve(context, 'package.json'))(request);\r\n  } catch (e) {\r\n    const resolvedPath = resolveModule(request, context);\r\n    if (resolvedPath) {\r\n      if (force) {\r\n        clearRequireCache(resolvedPath);\r\n      }\r\n      return require(resolvedPath);\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction createModule(filename: string, source?: string | undefined): Module {\r\n  const mod = new Module(filename, require.main);\r\n  mod.filename = filename;\r\n  // see https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L565-L640\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-underscore-dangle\r\n  mod.paths = (Module as any)._nodeModulePaths(path.dirname(filename));\r\n  if (source) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-underscore-dangle\r\n    (mod as any)._compile(source, filename);\r\n  }\r\n  return mod;\r\n}\r\n\r\n\r\nexport function clearModule(request: string, context: string): void {\r\n  const resolvedPath = resolveModule(request, context);\r\n  if (resolvedPath) {\r\n    clearRequireCache(resolvedPath);\r\n  }\r\n}\r\n\r\nfunction clearRequireCache(id: string, map = new Map()) {\r\n  const module = require.cache[id];\r\n  if (module) {\r\n    map.set(id, true);\r\n    // Clear children modules\r\n    module.children.forEach(child => {\r\n      if (!map.get(child.id)) {\r\n        clearRequireCache(child.id, map);\r\n      }\r\n    });\r\n    delete require.cache[id];\r\n  }\r\n}\r\n\r\n\r\nexport async function runScript(source: string, options: {\r\n  fileName: PathLike,\r\n  lineOffset: number,\r\n  context: Record<string, unknown>,\r\n  require?: Record<string, unknown>,\r\n}): Promise<Record<string, unknown>> {\r\n\r\n  const filename = fileProvider.fsPath(options.fileName);\r\n\r\n  const mod = createModule(filename);\r\n\r\n  function extendedRequire(id: string) {\r\n    if (options.require && options.require[id]) {\r\n      return options.require[id];\r\n    }\r\n    return mod.require(id);\r\n  }\r\n\r\n  const context = vm.createContext({\r\n    ...global,\r\n    Buffer,\r\n    process,\r\n    requireUncached: (id: string) => {\r\n      const dirName = fileProvider.dirname(filename);\r\n      if (dirName) {\r\n        clearModule(id, fileProvider.fsPath(dirName));\r\n      }\r\n      return mod.require(id);\r\n    },\r\n    ...options.context,\r\n  });\r\n\r\n  const compiledWrapper = vm.runInContext(Module.wrap(`${EOL}${source}`), context, {\r\n    filename,\r\n    lineOffset: options.lineOffset,\r\n    displayErrors: true,\r\n  });\r\n  compiledWrapper.apply(context, [\r\n    mod.exports,\r\n    extendedRequire,\r\n    mod,\r\n    filename,\r\n    path.dirname(filename),\r\n  ]);\r\n\r\n  let result = mod.exports;\r\n  if (isPromise(result)) {\r\n    result = await result;\r\n  } else {\r\n    for (const [key, value] of Object.entries(result)) {\r\n      if (isPromise(value)) {\r\n        result[key] = await value;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport async function evalExpression(expression: string, context: ProcessorContext) : Promise<unknown> {\r\n  const script = `exports.$result = (${expression});`;\r\n  let lineOffset = context.httpRegion.symbol.startLine;\r\n  if (context.httpRegion.symbol.source) {\r\n    const index = toMultiLineArray(context.httpRegion.symbol.source).findIndex(line => line.indexOf(expression) >= 0);\r\n    if (index >= 0) {\r\n      lineOffset += index;\r\n    }\r\n  }\r\n  const value = await runScript(script, {\r\n    fileName: context.httpFile.fileName,\r\n    context: {\r\n      httpFile: context.httpFile,\r\n      httpRegion: context.httpRegion,\r\n      console: context.scriptConsole,\r\n      ...context.variables,\r\n    },\r\n    lineOffset,\r\n  });\r\n  return value.$result;\r\n}\r\n\r\n\r\nexport const JAVASCRIPT_KEYWORDS = ['await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'super', 'switch', 'static', 'this', 'throw', 'try', 'true', 'typeof', 'var', 'void', 'while', 'with', 'yield'];\r\n\r\n\r\nexport function isValidVariableName(name: string): boolean {\r\n  if (JAVASCRIPT_KEYWORDS.indexOf(name) <= 0) {\r\n    try {\r\n      // eslint-disable-next-line no-new-func\r\n      Function(`var ${name}`);\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n", "export function isPromise(obj: unknown): obj is Promise<unknown> {\r\n  const guard = obj as Promise<unknown>;\r\n  return guard && !!guard.then;\r\n}\r\n\r\n\r\nexport function sleep(timeout: number) : Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, timeout));\r\n}\r\n", "import { fileProvider, log } from '../io';\r\nimport { ConfigureHooks, EnvironmentConfig, PathLike } from '../models';\r\nimport { toAbsoluteFilename, findRootDir } from './fsUtils';\r\nimport { loadModule } from './moduleUtils';\r\n\r\nexport async function getHttpacConfig(rootDir: PathLike) : Promise<EnvironmentConfig | undefined> {\r\n  let result = await loadFileConfig(rootDir);\r\n  if (!result) {\r\n    result = (await parseJson<Record<string, EnvironmentConfig>>(fileProvider.joinPath(rootDir, 'package.json')))?.httpyac;\r\n  }\r\n  if (result) {\r\n    await resolveClientCertficates(result, rootDir);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport const defaultConfigFiles = [\r\n  '.httpyac.js',\r\n  '.httpyac.config.js',\r\n  '.httpyac.json',\r\n  'httpyac.config.json'\r\n];\r\n\r\nasync function loadFileConfig(rootDir: PathLike): Promise<EnvironmentConfig | undefined> {\r\n  let fileConfigPath: PathLike | undefined;\r\n  for (const fileName of defaultConfigFiles) {\r\n    const resolvedPath = fileName && fileProvider.joinPath(rootDir, fileName);\r\n    if (resolvedPath && await fileProvider.exists(resolvedPath)) {\r\n      fileConfigPath = resolvedPath;\r\n      break;\r\n    }\r\n  }\r\n  if (fileConfigPath) {\r\n    const fileConfig = loadModule<EnvironmentConfig |(() => EnvironmentConfig)>(fileProvider.fsPath(fileConfigPath), fileProvider.fsPath(rootDir), true);\r\n    if (typeof fileConfig === 'function') {\r\n      return fileConfig();\r\n    }\r\n    return fileConfig;\r\n\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport async function parseJson<T>(fileName: PathLike) : Promise<T | undefined> {\r\n  try {\r\n    const text = await fileProvider.readFile(fileName, 'utf-8');\r\n    return JSON.parse(text);\r\n  } catch (err) {\r\n    log.debug(`json parse of ${fileName} failed`);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport async function resolveClientCertficates(config: EnvironmentConfig, rootDir: PathLike) : Promise<void> {\r\n  if (config.clientCertificates) {\r\n    for (const [, value] of Object.entries(config.clientCertificates)) {\r\n      if (value.cert) {\r\n        value.cert = await toAbsoluteFilename(value.cert, rootDir, true) || value.cert;\r\n      }\r\n      if (value.key) {\r\n        value.key = await toAbsoluteFilename(value.key, rootDir, true) || value.key;\r\n      }\r\n      if (value.pfx) {\r\n        value.pfx = await toAbsoluteFilename(value.pfx, rootDir, true) || value.pfx;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\ninterface PackageJson{\r\n  dependencies?: Record<string, unknown>,\r\n  devDependencies?: Record<string, unknown>\r\n}\r\n\r\n\r\nexport async function getPlugins(rootDir: PathLike) : Promise<Record<string, ConfigureHooks>> {\r\n  const packageJson = await getPackageJson(rootDir);\r\n  const hooks: Record<string, ConfigureHooks> = {};\r\n  if (packageJson?.json) {\r\n    const plugins = [\r\n      ...Object.keys(packageJson.json.dependencies || {}),\r\n      ...Object.keys(packageJson.json.devDependencies || {})\r\n    ].filter(isPlugin);\r\n    for (const dep of plugins) {\r\n      const hook = loadModule<ConfigureHooks>(dep, fileProvider.fsPath(packageJson.dir));\r\n      if (hook) {\r\n        hooks[dep] = hook;\r\n      }\r\n    }\r\n  }\r\n  return hooks;\r\n}\r\nasync function getPackageJson(rootDir: PathLike) {\r\n  const packageDir = await findRootDir(rootDir, 'package.json');\r\n\r\n  if (packageDir) {\r\n    return {\r\n      dir: packageDir,\r\n      json: await parseJson<PackageJson>(fileProvider.joinPath(packageDir, 'package.json')),\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction isPlugin(dep: string) {\r\n  return /^(httpyac-|@[\\w-]+(\\.)?[\\w-]+\\/httpyac-)plugin-/u.test(dep);\r\n}\r\n", "export const ENVIRONMENT_NONE = '__NONE__';\r\n\r\nexport function toEnvironmentKey(env: string[] | undefined): string {\r\n  if (env && env.length > 0) {\r\n    return env.sort().join(',');\r\n  }\r\n  return ENVIRONMENT_NONE;\r\n}\r\n", "import { ErrorDescription } from '../models';\r\n\r\nexport function isError(val: unknown): val is Error {\r\n  if (!val) {\r\n    return false;\r\n  }\r\n  if (val instanceof Error) {\r\n    return true;\r\n  }\r\n  const err = val as Error;\r\n  return !!err.message && !!err.stack && !!err.name;\r\n}\r\n\r\nexport function parseError(err: Error) : ErrorDescription {\r\n  if (err.stack) {\r\n    const match = /^(?<error>.*):\\s*(?<message>.*)\\r?\\n\\s*at (?<file>.*):(?<line>\\d*):(?<offset>\\d*)/mu.exec(err.stack);\r\n\r\n    if (match && match.groups?.error) {\r\n      return {\r\n        error: err,\r\n        errorType: match.groups.error,\r\n        message: match.groups.message,\r\n        file: match.groups.file,\r\n        line: match.groups.line,\r\n        offset: match.groups.offset,\r\n        displayMessage: `${match.groups.error}: ${match.groups.message} - ${match.groups.file}:${match.groups.line}:${match.groups.offset}`\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    error: err,\r\n    displayMessage: err.message,\r\n  };\r\n}\r\n", "import * as models from '../models';\r\nimport { toEnvironmentKey } from './environmentUtils';\r\nimport { cloneResponse } from './requestUtils';\r\n\r\n\r\nexport function getDisplayName(httpRegion?: models.HttpRegion, defaultName = 'global'): string {\r\n  if (httpRegion) {\r\n    if (httpRegion.metaData.title) {\r\n      return httpRegion.metaData.title;\r\n    }\r\n    if (httpRegion.metaData.name) {\r\n      return httpRegion.metaData.name;\r\n    }\r\n    if (httpRegion.request?.url) {\r\n      let indexQuery = httpRegion.request.url.indexOf('?');\r\n      if (indexQuery < 0) {\r\n        indexQuery = httpRegion.request.url.length;\r\n      }\r\n      const line = httpRegion.symbol.children?.find?.(obj => obj.kind === models.HttpSymbolKind.requestLine)?.startLine || httpRegion.symbol.startLine;\r\n      return `${httpRegion.request.method} ${httpRegion.request.url.slice(0, indexQuery)} (line: ${line + 1})`;\r\n    }\r\n  }\r\n  return defaultName;\r\n}\r\n\r\nexport function getRegionDescription(httpRegion: models.HttpRegion, defaultName = '-'): string {\r\n  if (httpRegion.metaData.description) {\r\n    return httpRegion.metaData.description;\r\n  }\r\n  if (httpRegion.request?.url) {\r\n    return `${httpRegion.request.method} ${httpRegion.request.url}`;\r\n  }\r\n  return defaultName;\r\n}\r\n\r\n\r\nexport async function processHttpRegionActions(context: models.ProcessorContext, showProgressBar?: boolean): Promise<boolean> {\r\n  delete context.httpRegion.response;\r\n  delete context.httpRegion.testResults;\r\n\r\n  const variables = context.variables;\r\n  try {\r\n    context.scriptConsole?.collectMessages?.();\r\n\r\n\r\n    if (context.progress) {\r\n      context.showProgressBar = showProgressBar;\r\n    }\r\n    if (context.progress?.report) {\r\n      context.progress.report({ message: `${context.httpRegion.symbol.name}` });\r\n    }\r\n\r\n    context.variables = initRegionScopedVariables(context);\r\n\r\n    const result = await context.httpRegion.hooks.execute.trigger(context);\r\n    const processedHttpRegion = toProcessedHttpRegion(context);\r\n    processedHttpRegion.response = await logResponse(processedHttpRegion?.response, context);\r\n    if (context.processedHttpRegions && !isGlobalHttpRegion(context.httpRegion)) {\r\n      context.processedHttpRegions.push(processedHttpRegion);\r\n    }\r\n    delete context.httpRegion.response;\r\n    return result !== models.HookCancel && result.every(obj => !!obj);\r\n  } finally {\r\n    if (!context.httpRegion.metaData.noLog) {\r\n      context.scriptConsole?.flush?.();\r\n      const newVariables = context.variables;\r\n      context.variables = variables;\r\n      autoShareNewVariables(newVariables, context);\r\n    }\r\n\r\n  }\r\n}\r\nfunction initRegionScopedVariables(context: models.ProcessorContext) {\r\n  const env = toEnvironmentKey(context.httpFile.activeEnvironment);\r\n  const variables = Object.assign(\r\n    {},\r\n    context.variables,\r\n    ...(context.config?.useRegionScopedVariables ? context.httpFile.httpRegions.filter(obj => isGlobalHttpRegion(obj)) : context.httpFile.httpRegions)\r\n      .map(obj => obj.variablesPerEnv[env])\r\n  );\r\n\r\n  if (context.config?.useRegionScopedVariables) {\r\n    Object.assign(\r\n      variables,\r\n      ...context.httpFile.httpRegions.filter(obj => isGlobalHttpRegion(obj))\r\n        .map(obj => obj.variablesPerEnv[env])\r\n    );\r\n  } else {\r\n    Object.assign(\r\n      variables,\r\n      ...context.httpFile.httpRegions\r\n        .map(obj => obj.variablesPerEnv[env])\r\n    );\r\n  }\r\n  return variables;\r\n}\r\n\r\nfunction autoShareNewVariables(variables: models.Variables, context: models.ProcessorContext) {\r\n  for (const [key, value] of Object.entries(variables)) {\r\n    if (!context.variables[key]) {\r\n      context.variables[key] = value;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport async function logResponse(response: models.HttpResponse | undefined, context: models.ProcessorContext): Promise<models.HttpResponse | undefined> {\r\n  if (response) {\r\n    const clone = cloneResponse(response);\r\n    const responseLoggingResult = await context.httpFile.hooks.responseLogging.trigger(clone, context);\r\n    if (responseLoggingResult === models.HookCancel) {\r\n      return undefined;\r\n    }\r\n    if (!context.httpRegion.metaData.noLog\r\n      && clone\r\n      && context.logResponse) {\r\n      await context.logResponse(clone, context.httpRegion);\r\n    }\r\n    return clone;\r\n  }\r\n  return response;\r\n}\r\n\r\nexport async function executeGlobalScripts(context: {\r\n  variables: models.Variables,\r\n  httpClient: models.HttpClient,\r\n  httpFile: models.HttpFile,\r\n  options: Record<string, unknown>\r\n}): Promise<boolean> {\r\n  for (const httpRegion of context.httpFile.httpRegions) {\r\n    if (isGlobalHttpRegion(httpRegion) && !httpRegion.metaData.disabled) {\r\n      if (!await processHttpRegionActions({\r\n        ...context,\r\n        httpRegion,\r\n      })) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function toProcessedHttpRegion(context: models.ProcessorContext): models.ProcessedHttpRegion {\r\n  return {\r\n    metaData: context.httpRegion.metaData && {\r\n      ...context.httpRegion.metaData,\r\n    },\r\n    symbol: context.httpRegion.symbol,\r\n    testResults: context.httpRegion.testResults,\r\n    request: context.httpRegion.request && {\r\n      ...context.httpRegion.request,\r\n    },\r\n    response: context.httpRegion.response && cloneResponse(context.httpRegion.response),\r\n  };\r\n}\r\n\r\n\r\nexport function isGlobalHttpRegion(httpRegion: models.HttpRegion) : boolean {\r\n  return !(httpRegion.request || httpRegion.metaData.name);\r\n}\r\n\r\n\r\nexport function isHttpRegionSendContext(context: models.SendContext): context is models.HttpRegionSendContext {\r\n  const guard = context as models.HttpRegionSendContext;\r\n  return !!guard?.httpRegion;\r\n}\r\n\r\nexport function isHttpRegionsSendContext(context: models.SendContext): context is models.HttpRegionsSendContext {\r\n  const guard = context as models.HttpRegionsSendContext;\r\n  return Array.isArray(guard?.httpRegions);\r\n}\r\n\r\nexport function isProcessorContext(context: models.SendContext): context is models.ProcessorContext {\r\n  const guard = context as models.ProcessorContext;\r\n  return !!guard.httpRegion && !!guard.variables && !!guard.options;\r\n}\r\n", "import { HttpResponse, Request } from '../models';\r\nimport { isString, toMultiLineString } from './stringUtils';\r\n\r\nexport function toHttpString(response: HttpResponse, options?: {\r\n  responseBody?: boolean,\r\n  requestBody?: boolean,\r\n  prettyPrint?: boolean,\r\n}) : string {\r\n  const result: Array<string> = [];\r\n\r\n  if (response.request) {\r\n    result.push(...toHttpStringRequest(response.request, {\r\n      body: !!options?.requestBody\r\n    }));\r\n    result.push('');\r\n  }\r\n  result.push(...toHttpStringResponse(response, {\r\n    prettyPrint: !!options?.prettyPrint,\r\n    body: !!options?.responseBody\r\n  }));\r\n\r\n  return toMultiLineString(result);\r\n}\r\n\r\nexport function toHttpStringResponse(response: HttpResponse, options?: {\r\n  prettyPrint?: boolean;\r\n  body?: boolean;\r\n}) : Array<string> {\r\n  const result: Array<string> = [];\r\n  result.push(`${response.protocol} ${response.statusCode} ${response.statusMessage ? ` - ${response.statusMessage}` : ''}`);\r\n  if (response.headers) {\r\n    result.push(...toHttpStringHeader(response.headers));\r\n  }\r\n  if (options?.body && isString(response.body)) {\r\n    result.push('');\r\n    result.push(options?.prettyPrint && response.prettyPrintBody ? response.prettyPrintBody : response.body);\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\nexport function toHttpStringRequest(request: Request, options?: {\r\n  body?: boolean;\r\n}) : Array<string> {\r\n  const result: Array<string> = [];\r\n  result.push(`${request.method} ${request.url}`);\r\n  if (request.headers) {\r\n    result.push(...toHttpStringHeader(request.headers));\r\n  }\r\n  if (options?.body && isString(request.body)) {\r\n    result.push('');\r\n    result.push(request.body);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function toHttpStringHeader(headers: Record<string, unknown>): Array<string> {\r\n  return Object.entries(headers)\r\n    .map(([key, value]) => {\r\n      let val = value || '';\r\n      if (value) {\r\n        if (Array.isArray(value)) {\r\n          val = value.join(', ');\r\n        } else if (!isString(value)) {\r\n          val = JSON.stringify(value);\r\n        }\r\n      }\r\n      return `${key}: ${val}`;\r\n    });\r\n}\r\n", "import { log } from '../io';\r\nimport * as models from '../models';\r\n\r\nexport function report(context: { progress?: models.Progress }, message: string) {\r\n  log.debug(message);\r\n  context.progress?.report?.({\r\n    message\r\n  });\r\n}\r\n", "import { EOL } from 'os';\r\nimport * as models from '../models';\r\nimport { isString, toMultiLineArray } from './stringUtils';\r\nimport * as mimeTypeUtils from './mimeTypeUtils';\r\n\r\nexport function toMarkdown(response: models.HttpResponse, options?: {\r\n  responseBody?: boolean,\r\n  requestBody?: boolean,\r\n  timings?: boolean,\r\n  meta?: boolean,\r\n  prettyPrint?: boolean;\r\n  testResults?: Array<models.TestResult>,\r\n}) : string {\r\n  const result: Array<string> = [];\r\n\r\n  if (response.request) {\r\n    result.push(...toMarkdownRequest(response.request, {\r\n      body: !!options?.requestBody\r\n    }));\r\n    result.push('');\r\n  }\r\n  result.push(...toMarkdownResponse(response, {\r\n    prettyPrint: !!options?.prettyPrint,\r\n    body: !!options?.responseBody\r\n  }));\r\n\r\n  if (options?.testResults) {\r\n    result.push('');\r\n    result.push('');\r\n    result.push(...toMarkdownTestResults(options.testResults));\r\n  }\r\n\r\n  if (options?.timings && response.timings) {\r\n    result.push('');\r\n    result.push('');\r\n    result.push(...toMarkdownTimings(response.timings));\r\n  }\r\n\r\n  if (options?.meta && response.meta) {\r\n    result.push('');\r\n    result.push('');\r\n    result.push(...toMarkdownMeta(response.meta));\r\n  }\r\n\r\n\r\n  return joinMarkdown(result);\r\n}\r\n\r\nexport function toMarkdownResponse(response: models.HttpResponse, options?: {\r\n  prettyPrint?: boolean;\r\n  body?: boolean;\r\n}) : Array<string> {\r\n  const result: Array<string> = [];\r\n  result.push(`\\`${response.protocol} ${response.statusCode}${response.statusMessage ? ` - ${response.statusMessage}` : ''}\\``);\r\n  if (response.headers) {\r\n    result.push(...toMarkdownHeader(response.headers));\r\n  }\r\n  if (options?.body && isString(response.body)) {\r\n    result.push('');\r\n    result.push(`\\`\\`\\`${getMarkdownSyntax(response.contentType)}`);\r\n    result.push(joinMarkdown(toMultiLineArray(options.prettyPrint && response.prettyPrintBody ? response.prettyPrintBody : response.body)));\r\n    result.push('```');\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function getMarkdownSyntax(contentType: models.ContentType | undefined) : string {\r\n  if (mimeTypeUtils.isMimeTypeJSON(contentType)) {\r\n    return 'json';\r\n  }\r\n  if (mimeTypeUtils.isMimeTypeXml(contentType)) {\r\n    return 'xml';\r\n  }\r\n  if (mimeTypeUtils.isMimeTypeHtml(contentType)) {\r\n    return 'html';\r\n  }\r\n  if (mimeTypeUtils.isMimeTypeJavascript(contentType)) {\r\n    return 'js';\r\n  }\r\n  if (mimeTypeUtils.isMimeTypeCSS(contentType)) {\r\n    return 'css';\r\n  }\r\n  if (mimeTypeUtils.isMimeTypeMarkdown(contentType)) {\r\n    return 'markdown';\r\n  }\r\n  return '';\r\n}\r\n\r\nexport function toMarkdownRequest(request: models.Request, options?: {\r\n  body?: boolean;\r\n}) : Array<string> {\r\n  const result: Array<string> = [];\r\n  result.push(`\\`${request.method} ${request.url}\\``);\r\n  if (request.headers) {\r\n    result.push(...toMarkdownHeader(request.headers));\r\n  }\r\n  if (options?.body && isString(request.body)) {\r\n    result.push('');\r\n    result.push('```json');\r\n    result.push(joinMarkdown(toMultiLineArray(request.body)));\r\n    result.push('```');\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function toMarkdownTestResults(testResults: Array<models.TestResult>) : Array<string> {\r\n  const result: Array<string> = [];\r\n  result.push('`TestResults`');\r\n  result.push('');\r\n  for (const testResult of testResults) {\r\n    let message = `${testResult.result ? models.testSymbols.ok : models.testSymbols.error}: ${testResult.message}`;\r\n    if (testResult.error) {\r\n      message += ` (${testResult.error.displayMessage})`;\r\n    }\r\n    result.push(message);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function toMarkdownHeader(headers: Record<string, unknown>) : Array<string> {\r\n  return Object.entries(headers)\r\n    .map(([key, value]) => {\r\n      let val = value || '';\r\n      if (value) {\r\n        if (Array.isArray(value)) {\r\n          val = value.join(', ');\r\n        } else if (!isString(value)) {\r\n          val = JSON.stringify(value);\r\n        }\r\n      }\r\n      return `*${key}*: ${val}`;\r\n    })\r\n    .sort();\r\n}\r\n\r\nexport function toMarkdownMeta(meta: Record<string, unknown>) : Array<string> {\r\n  const result: Array<string> = [];\r\n  result.push('`Meta`');\r\n  result.push('');\r\n  for (const [key, value] of Object.entries(meta)) {\r\n    if (Array.isArray(value)) {\r\n      if (value.length > 0) {\r\n        result.push(`*${key}*: ${value.join(',')}`);\r\n      }\r\n    } else {\r\n      result.push(`*${key}*: ${value}`);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function toMarkdownTimings(timings: models.HttpTimings) : Array<string> {\r\n  const result: Array<string> = [];\r\n\r\n  result.push('`Timings`');\r\n  result.push('');\r\n  if (timings.wait) {\r\n    result.push(`*Wait*: ${timings.wait} ms`);\r\n  }\r\n  if (timings.dns) {\r\n    result.push(`*DNS*: ${timings.dns} ms`);\r\n  }\r\n  if (timings.tcp) {\r\n    result.push(`*TCP*: ${timings.tcp} ms`);\r\n  }\r\n  if (timings.tls) {\r\n    result.push(`*TLS*: ${timings.tls} ms`);\r\n  }\r\n  if (timings.request) {\r\n    result.push(`*Reqeust*: ${timings.request} ms`);\r\n  }\r\n  if (timings.firstByte) {\r\n    result.push(`*First Byte*: ${timings.firstByte} ms`);\r\n  }\r\n  if (timings.download) {\r\n    result.push(`*Download*: ${timings.download} ms`);\r\n  }\r\n  if (timings.total) {\r\n    result.push(`*Total*: ${timings.total} ms`);\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\nexport function joinMarkdown(lines: string[]) : string {\r\n  return lines.join(`  ${EOL}`);\r\n}\r\n", "import * as models from '../models';\r\nimport { toAbsoluteFilename } from './fsUtils';\r\nimport { isString } from './stringUtils';\r\nimport * as io from '../io';\r\nimport { toEnvironmentKey } from './environmentUtils';\r\nimport { log } from '../io';\r\n\r\nexport function expandVariables(variables: models.Variables) : models.Variables {\r\n  for (const [key, value] of Object.entries(variables)) {\r\n    expandVariable(key, value, variables);\r\n  }\r\n  return variables;\r\n}\r\n\r\nexport function expandVariable(key: string, value: unknown, variables: models.Variables) : unknown {\r\n  if (value && isString(value)) {\r\n    let result = value;\r\n    let match: RegExpExecArray | null;\r\n    const variableRegex = /\\{{2}([a-zA-Z0-9_]+)\\}{2}/gu;\r\n    while ((match = variableRegex.exec(result)) !== null) {\r\n      const [searchValue, variableName] = match;\r\n      const val = expandVariable(variableName, variables[variableName], variables);\r\n      result = result.replace(searchValue, `${val}`);\r\n    }\r\n    variables[key] = result;\r\n  } else {\r\n    variables[key] = value;\r\n  }\r\n  return value;\r\n}\r\n\r\nexport async function replaceVariables(\r\n  text: unknown,\r\n  type: models.VariableType | string,\r\n  context: models.ProcessorContext\r\n): Promise<typeof models.HookCancel | unknown> {\r\n  if (context.progress?.isCanceled?.()) {\r\n    log.trace('processs canceled by user');\r\n    return models.HookCancel;\r\n  }\r\n  return await context.httpFile.hooks.replaceVariable.trigger(text, type, context);\r\n}\r\n\r\nexport async function replaceFilePath<T>(\r\n  fileName: string, context:\r\n    models.ProcessorContext,\r\n  action: (path: models.PathLike) => Promise<T>\r\n): Promise<T | undefined> {\r\n  const file = await replaceVariables(fileName, models.VariableType.filePath, context);\r\n  if (isString(file)) {\r\n    const normalizedPath = await toAbsoluteFilename(file, context.httpFile.fileName);\r\n    if (normalizedPath) {\r\n      return await action(normalizedPath);\r\n    }\r\n    const message = `file not found: ${fileName}`;\r\n    io.userInteractionProvider.showWarnMessage?.(message);\r\n    io.log.warn(message);\r\n\r\n  } else {\r\n    const message = `file replace made file invalid: ${fileName} <> ${file}`;\r\n    io.userInteractionProvider.showWarnMessage?.(message);\r\n    io.log.warn(message);\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function setVariableInContext(variables: models.Variables, context: models.ProcessorContext) {\r\n  Object.assign(context.variables, variables);\r\n  const envKey = toEnvironmentKey(context.httpFile.activeEnvironment);\r\n  if (!context.httpRegion.variablesPerEnv[envKey]) {\r\n    context.httpRegion.variablesPerEnv[envKey] = {};\r\n  }\r\n  Object.assign(context.httpRegion.variablesPerEnv[envKey], variables);\r\n}\r\n\r\nexport function unsetVariableInContext(variables: models.Variables, context: models.ProcessorContext) {\r\n  const envKey = toEnvironmentKey(context.httpFile.activeEnvironment);\r\n  const envVariables = context.httpRegion.variablesPerEnv[envKey];\r\n  for (const key of Object.keys(variables)) {\r\n    delete context.variables[key];\r\n    if (envVariables) {\r\n      delete envVariables[key];\r\n    }\r\n  }\r\n}\r\n", "import { HttpClient, HttpClientContext, HttpRequest, HttpResponse, RepeatOrder, VariableProviderContext } from '../models';\r\nimport * as utils from '../utils';\r\nimport { default as got, OptionsOfUnknownResponseBody, CancelError, Response } from 'got';\r\nimport merge from 'lodash/merge';\r\nimport { HttpProxyAgent } from 'http-proxy-agent';\r\nimport { HttpsProxyAgent } from 'https-proxy-agent';\r\nimport { default as filesize } from 'filesize';\r\nimport { log } from './logger';\r\n\r\nexport function gotHttpClientFactory(defaultsOverride: HttpRequest | undefined) : HttpClient {\r\n  return async function gotHttpClient(request: HttpRequest, context: HttpClientContext) : Promise<HttpResponse | false> {\r\n    try {\r\n      const defaults: OptionsOfUnknownResponseBody = {\r\n        decompress: true,\r\n        retry: 0,\r\n        throwHttpErrors: false,\r\n        headers: {\r\n          'accept': '*/*',\r\n          'user-agent': 'httpyac',\r\n        }\r\n      };\r\n\r\n      const url = request.url;\r\n\r\n      if (!url) {\r\n        throw new Error('empty url');\r\n      }\r\n      const mergedRequest: HttpRequest = merge({}, defaults,\r\n        defaultsOverride,\r\n        request);\r\n      delete mergedRequest.url;\r\n      initProxy(mergedRequest);\r\n\r\n      const options: OptionsOfUnknownResponseBody = toGotOptions(mergedRequest);\r\n      log.debug('request', options);\r\n      let response: HttpResponse | undefined;\r\n      if (context.repeat && context.repeat.count > 0) {\r\n        response = await loadRepeat(url, options, context);\r\n      } else {\r\n        response = await load(url, options, context);\r\n      }\r\n\r\n      if (response) {\r\n        return response;\r\n      }\r\n      throw new Error('no response');\r\n\r\n    } catch (err) {\r\n      if (err instanceof CancelError) {\r\n        return false;\r\n      }\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  function toGotOptions(mergedRequest: HttpRequest): OptionsOfUnknownResponseBody {\r\n    const options: OptionsOfUnknownResponseBody = {};\r\n    Object.assign(options, mergedRequest); // HACK ignore type of body\r\n    return options;\r\n  }\r\n}\r\n\r\n\r\nasync function loadRepeat(url: string, options: OptionsOfUnknownResponseBody, context: HttpClientContext) {\r\n\r\n  const loadFunc = async () => toHttpResponse(await got(url, options));\r\n  const loader: Array<() => Promise<HttpResponse>> = [];\r\n  for (let index = 0; index < (context.repeat?.count || 1); index++) {\r\n    loader.push(loadFunc);\r\n  }\r\n  if (context.repeat?.type === RepeatOrder.parallel) {\r\n    const responses = await Promise.all(loader.map(obj => obj()));\r\n    return responses.pop();\r\n  }\r\n  const responses = [];\r\n  for (const load of loader) {\r\n    responses.push(await load());\r\n  }\r\n  return responses.pop();\r\n}\r\n\r\nasync function load(url: string, options: OptionsOfUnknownResponseBody, context: HttpClientContext) {\r\n  const responsePromise = got(url, options);\r\n\r\n  let prevPercent = 0;\r\n  if (context.showProgressBar) {\r\n\r\n    responsePromise.on('downloadProgress', data => {\r\n      const newData = data.percent - prevPercent;\r\n      prevPercent = data.percent;\r\n      if (context.progress?.report) {\r\n        context.progress.report({\r\n          message: 'call http request',\r\n          increment: newData * 100,\r\n        });\r\n      }\r\n    });\r\n  }\r\n  const dispose = context.progress && context.progress.register(() => {\r\n    responsePromise.cancel();\r\n  });\r\n\r\n  const response = await responsePromise;\r\n  if (dispose) {\r\n    dispose();\r\n  }\r\n  return toHttpResponse(response);\r\n}\r\n\r\nfunction initProxy(request: HttpRequest) {\r\n  if (request.proxy) {\r\n    request.agent = {\r\n      http: new HttpProxyAgent(request.proxy),\r\n      https: new HttpsProxyAgent(request.proxy)\r\n    };\r\n    delete request.proxy;\r\n  }\r\n}\r\n\r\n\r\nfunction toHttpResponse(response: Response<unknown>): HttpResponse {\r\n  const httpResponse: HttpResponse = {\r\n    statusCode: response.statusCode,\r\n    protocol: `HTTP/${response.httpVersion}`,\r\n    statusMessage: response.statusMessage,\r\n    body: response.body,\r\n    rawBody: response.rawBody,\r\n    headers: response.headers,\r\n    timings: response.timings.phases,\r\n    httpVersion: response.httpVersion,\r\n    request: {\r\n      method: response.request.options.method,\r\n      url: `${response.request.options.url}`,\r\n      headers: response.request.options.headers,\r\n      body: getBody(response.request.options.body),\r\n    },\r\n    contentType: utils.parseContentType(response.headers),\r\n    meta: {\r\n      ip: response.ip,\r\n      redirectUrls: response.redirectUrls,\r\n      size: filesize(response.rawHeaders.map(obj => obj.length).reduce((size, current) => size + current, 0) + response.rawBody.length),\r\n    }\r\n  };\r\n  delete response.headers[':status'];\r\n  if (httpResponse.httpVersion && httpResponse.httpVersion.startsWith('HTTP/')) {\r\n    httpResponse.httpVersion = httpResponse.httpVersion.slice('HTTP/'.length);\r\n  }\r\n\r\n  return httpResponse;\r\n}\r\n\r\nfunction getBody(body: unknown) {\r\n  if (utils.isString(body)) {\r\n    return body;\r\n  }\r\n  if (Buffer.isBuffer(body)) {\r\n    return body;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport function initHttpClient(content: VariableProviderContext): HttpClient {\r\n  const request = {\r\n    ...content.config?.request || {},\r\n    proxy: content.config?.proxy\r\n  };\r\n  return gotHttpClientFactory(request);\r\n}\r\n", "import { LogLevel, LogHandler, ConsoleLogHandler } from '../models';\r\n\r\nexport class Logger implements ConsoleLogHandler {\r\n  private collectCache: Array<() => void> | undefined;\r\n  constructor(readonly options: {\r\n    level?: LogLevel,\r\n    logMethod?: (level: LogLevel, ...params: unknown[]) => void,\r\n    onlyFailedTests?: boolean;\r\n    noTrace?: boolean;\r\n  }) {\r\n  }\r\n\r\n  collectMessages(): void {\r\n    this.collectCache = [];\r\n  }\r\n\r\n  flush(): void {\r\n    if (this.collectCache) {\r\n      for (const action of this.collectCache) {\r\n        action();\r\n      }\r\n      delete this.collectCache;\r\n    }\r\n  }\r\n\r\n  private writeLog(logLevel: LogLevel, action: (...params: unknown[]) => void, params: unknown[]) {\r\n    if (!this.options?.level || logLevel >= (this.options.level)) {\r\n      const log = this.options?.logMethod ? () => this.options?.logMethod?.(logLevel, ...params) : () => action(...params);\r\n      if (this.collectCache) {\r\n        this.collectCache.push(log);\r\n      } else {\r\n        log();\r\n      }\r\n    }\r\n  }\r\n\r\n  info(...params: unknown[]): void {\r\n    this.writeLog(LogLevel.info, console.info, params);\r\n  }\r\n  log(...params: unknown[]): void {\r\n    this.writeLog(LogLevel.info, console.log, params);\r\n  }\r\n  trace(...params: unknown[]): void {\r\n    this.writeLog(LogLevel.trace, this.options.noTrace ? console.debug : console.trace, params);\r\n  }\r\n  debug(...params: unknown[]): void {\r\n    this.writeLog(LogLevel.debug, console.debug, params);\r\n  }\r\n  error(...params: unknown[]): void {\r\n    this.writeLog(LogLevel.error, console.error, params);\r\n  }\r\n  warn(...params: unknown[]): void {\r\n    this.writeLog(LogLevel.warn, console.warn, params);\r\n  }\r\n  logTest(result: boolean, message: string): void {\r\n    if (!this.options?.onlyFailedTests && result) {\r\n      this.writeLog(LogLevel.info, console.info, [message]);\r\n    } else if (!result) {\r\n      this.writeLog(LogLevel.info, console.error, [message]);\r\n    }\r\n  }\r\n  clear(): void {\r\n    console.clear();\r\n  }\r\n}\r\n\r\n\r\nexport const log: LogHandler = new Logger({\r\n  level: LogLevel.warn,\r\n  noTrace: true,\r\n});\r\n", "import { UserInteractonProvider } from '../models';\r\n\r\n\r\nexport const userInteractionProvider: UserInteractonProvider = {\r\n  showNote: async function showNote() {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  showInputPrompt: async function showInputPrompt() {\r\n    throw new Error('Not Implemented');\r\n  },\r\n  showListPrompt: async function showListPrompt() {\r\n    throw new Error('Not Implemented');\r\n  },\r\n};\r\n", "export * from './cookieStore';\r\nexport * from './httpFileStore';\r\nexport * from './userSessionStore';\r\n", "import { Cookie, MemoryCookieStore } from 'tough-cookie';\r\nimport { log } from '../io';\r\nimport * as models from '../models';\r\nimport { toEnvironmentKey } from '../utils';\r\n\r\n\r\ninterface CookieStoreEntry {\r\n  id: string;\r\n  memoryCookieStore: MemoryCookieStore;\r\n}\r\n\r\nclass CookieStore {\r\n  private storeCache: Array<CookieStoreEntry> = [];\r\n\r\n  private getCookieStoreId(httpFile: models.HttpFile) {\r\n    return `Cookies_${toEnvironmentKey(httpFile.activeEnvironment)}_${httpFile.rootDir?.toString?.() || 'none'}`;\r\n  }\r\n\r\n  getCookieStoreEntry(httpFile: models.HttpFile) : CookieStoreEntry {\r\n    const id = this.getCookieStoreId(httpFile);\r\n    let result = this.storeCache.find(obj => obj.id === id);\r\n    if (!result) {\r\n      result = {\r\n        id,\r\n        memoryCookieStore: new MemoryCookieStore(),\r\n      };\r\n      this.storeCache.push(result);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getCookies(httpFile: models.HttpFile) {\r\n    const result: Cookie[] = [];\r\n\r\n    const { memoryCookieStore } = this.getCookieStoreEntry(httpFile);\r\n    if (memoryCookieStore.synchronous) {\r\n      memoryCookieStore.getAllCookies((err, cookies: Array<Cookie>) => {\r\n        if (!err) {\r\n          result.push(...cookies);\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  async reset(httpFile?: models.HttpFile) {\r\n    if (httpFile) {\r\n      const cacheObj = this.getCookieStoreEntry(httpFile);\r\n      cacheObj.memoryCookieStore = new MemoryCookieStore();\r\n    } else {\r\n      this.storeCache = [];\r\n    }\r\n  }\r\n\r\n  removeCookies(httpFile: models.HttpFile, cookies: Cookie[]) {\r\n    const { memoryCookieStore } = this.getCookieStoreEntry(httpFile);\r\n    for (const cookie of cookies) {\r\n      if (cookie.domain && cookie.path) {\r\n        memoryCookieStore.removeCookie(cookie.domain, cookie.path, cookie.key, err => {\r\n          if (err) {\r\n            log.error(err);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n  }\r\n}\r\n\r\nexport const cookieStore = new CookieStore();\r\n", "export * from './commentHttpRegionParser';\r\nexport * from './eventSourceHttpRegionParser';\r\nexport * from './gqlHttpRegionParser';\r\nexport * from './httpFileParser';\r\nexport * from './intellijHttpRegionParser';\r\nexport * from './initHooks';\r\nexport * from './javascriptHttpRegionParser';\r\nexport * from './metaHttpRegionParser';\r\nexport * from './mqtttHttpRegionParser';\r\nexport * from './noteMetaHttpRegionParser';\r\nexport * from './outputRedirectionHttpRegionParser';\r\nexport * from './parserRegex';\r\nexport * from './requestBodyHttpRegionParser';\r\nexport * from './requestHttpRegionParser';\r\nexport * from './responseRefHttpRegionParser';\r\nexport * from './responseHttpRegionParser';\r\nexport * from './protoHttpRegionParser';\r\nexport * from './variableHttpRegionParser';\r\nexport * from './websocketHttpRegionParser';\r\n", "export const ParserRegex = {\r\n  auth: {\r\n    aws: /^\\s*(aws)\\s+(?<accessKeyId>[^\\s]*)\\s+(?<secretAccessKey>[^\\s]*)\\s*(token:\\s*(?<token>[^\\s]*))?\\s*(region:\\s*(?<region>[^\\s]*))?\\s*(service:\\s*(?<service>[^\\s]*))?\\s*$/iu,\r\n    basic: /^\\s*(basic)\\s+(?<user>[^\\s]*)\\s+(?<password>([^\\s]+.*))$/iu,\r\n    basicColon: /^\\s*(basic)\\s+(?<user>.*):(?<password>.*)$/iu,\r\n    clientCert: /^\\s*(cert:\\s*(?<cert>[^\\s]*)\\s*)?(key:\\s*(?<key>[^\\s]*)\\s*)?(pfx:\\s*(?<pfx>[^\\s]*)\\s*)?(passphrase:\\s*(?<passphrase>[^\\s]*)\\s*)?\\s*$/u,\r\n    digest: /^\\s*(digest)\\s+(?<user>[^\\s]*)\\s+(?<password>([^\\s]+.*))$/iu,\r\n    oauth2: /^\\s*(?<type>openid|oauth2)(\\s+(?<flow>client(_credentials)?|(authorization_)?code|device(_code)?|password|implicit|hybrid))?(\\s+(?<variablePrefix>[^\\s]*))?\\s*((token_exchange)\\s+(?<tokenExchangePrefix>[^\\s]*))?\\s*$/iu,\r\n  },\r\n  comment: {\r\n    multilineEnd: /^\\s*\\*\\/\\s*$/u,\r\n    multilineStart: /^\\s*\\/\\*$/u,\r\n    singleline: /^\\s*\\/\\/\\s*(?<comment>.*)\\s*$/u,\r\n  },\r\n  emptyLine: /^\\s*$/u,\r\n  gql: {\r\n    fileImport: /^\\s*gql(\\s+(?<name>[^\\s(]+))?\\s+<\\s+(?<fileName>.+)\\s*$/u,\r\n    fragment: /^\\s*(fragment)\\s+(?<name>[^\\s(]+)\\s+on\\s+/u,\r\n    query: /^\\s*(query|mutation)(\\s+(?<name>[^\\s(]+))?/u,\r\n  },\r\n  grpc: {\r\n    proto: /^\\s*proto\\s+<\\s+(?<fileName>.+)\\s*$/u,\r\n    grpcLine: /^\\s*(GRPC|grpc)\\s*(?<url>.+?)\\s*$/u,\r\n    grpcProtocol: /^\\s*grpc:\\/\\/(?<url>.+?)\\s*$/u,\r\n    grpcUrl: /^\\s*(grpc:\\/\\/)?(?<server>.+?)\\/(?<service>[^/]+?)\\/(?<method>[^/]+?)$/u,\r\n    sslAuthorization: /^\\s*(ssl)\\s+(?<root>[^\\s]*)\\s+(?<cert>[^\\s]*)\\s+(?<key>[^\\s]*)\\s*$/iu,\r\n  },\r\n  stream: {\r\n    websocketLine: /^\\s*(ws|wss|websocket)\\s*(?<url>.+?)\\s*$/ui,\r\n    websocketProtocol: /^\\s*ws(s)?:\\/\\/(?<url>.+?)\\s*$/u,\r\n    mqttLine: /^\\s*(mqtt|mqtts)\\s*(?<url>.+?)\\s*$/ui,\r\n    mqttProtocol: /^\\s*mqtt(s)?:\\/\\/(?<url>.+?)\\s*$/u,\r\n    eventSourceLine: /^\\s*(sse|eventsource)\\s*(?<url>.+?)\\s*$/ui,\r\n  },\r\n  intellij: {\r\n    import: /^\\s*>\\s+(?<fileName>[^\\s{%}]+\\s*)$/u,\r\n    scriptEnd: /^\\s*%\\}\\s*$/u,\r\n    scriptSingleLine: /^\\s*>\\s+\\{%\\s*(?<script>.*)\\s*%\\}\\s*$/u,\r\n    scriptStart: /^\\s*>\\s+\\{%\\s*$/u,\r\n  },\r\n  javascript: {\r\n    scriptStart: /^\\s*\\{\\{(@js\\s+)?(?<modifier>\\+|@)?(?<event>(request|streaming|response|after)?)?\\s*$/u,\r\n    scriptEnd: /^\\s*\\}\\}\\s*$/u,\r\n    scriptSingleLine: /\\{{2}(.+?)\\}{2}/gu,\r\n  },\r\n  meta: {\r\n    all: /^\\s*(#+|\\/{2})/u,\r\n    comment: /^\\s*((#\\s+)|(\\/{2}))/u,\r\n    delimiter: /^\\s*#{3,}(?<title>.*)$/u,\r\n    data: /^\\s*(#+|\\/{2,})\\s+@(?<key>[^\\s]*)(\\s+)?\"?(?<value>.*)?\"?$/u,\r\n    forOf: /^\\s*for\\s+(?<variable>.*)\\s+of\\s+(?<iterable>.*)\\s*/u,\r\n    for: /^\\s*for\\s*(?<counter>\\d*)\\s*$/u,\r\n    while: /^\\s*while\\s*(?<expression>.*)\\s*$/u,\r\n    rateLimit: /^\\s*(slot(:)?\\s*(?<slot>[^\\s]+))?\\s*(minIdleTime(:)?\\s*(?<minIdleTime>\\d*))?\\s*(max(:)?\\s*(?<max>\\d*)\\s*expire(:)?\\s*(?<expire>\\d*))?\\s*$/iu,\r\n  },\r\n  request: {\r\n    fileImport: /^<(?:(?<injectVariables>@)(?<encoding>\\w+)?)?\\s+(?<fileName>.+?)\\s*$/u,\r\n    header: /^\\s*(?<key>[\\w-]+)\\s*:\\s*(?<value>.*?),?\\s*$/u,\r\n    headersSpread: /^\\s*\\.{3}(?<variableName>[^\\s]+),?\\s*$/u,\r\n    queryLine: /^\\s*(\\?|&)([^=\\s]+)=(.*)$/u,\r\n    requestLine: /^\\s*(?<method>GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|CONNECT|TRACE|PROPFIND|PROPPATCH|MKCOL|COPY|MOVE|LOCK|UNLOCK|CHECKOUT|CHECKIN|REPORT|MERGE|MKACTIVITY|MKWORKSPACE|VERSION-CONTROL|BASELINE-CONTROL)\\s*(?<url>.+?)(\\s+HTTP\\/(?<version>(\\S+)))?$/u,\r\n    urlLine: /^\\s*(\\/).*$/u,\r\n  },\r\n  outputRedirection: /^\\s*>>(?<force>!)?\\s+(?<fileName>[^\\s{%}]+\\s*)$/u,\r\n  responseLine: /^\\s*HTTP\\/(?<httpVersion>\\S+)\\s*(?<statusCode>[1-5][0-9][0-9])\\s*(-)?\\s*(?<statusMessage>.*)$/u,\r\n  responseRef: /^\\s*<>\\s*(?<fileName>.+?)\\s*$/u,\r\n  variable: /^\\s*@(?<key>[^\\s=]*)\\s*(?<operator>=\\s*)\"?(?<value>.*)\"?\\s*$/u,\r\n};\r\n", "import { HttpSymbolKind, getHttpLineGenerator, HttpLineGenerator, HttpRegionParserResult, ParserContext } from '../models';\r\nimport { toMultiLineString } from '../utils';\r\nimport { ParserRegex } from './parserRegex';\r\n\r\n\r\nexport async function parseComment(getLineReader: getHttpLineGenerator, { httpRegion }: ParserContext): Promise<HttpRegionParserResult> {\r\n  const lineReader = getLineReader(true);\r\n  const comment = getCommentContent(lineReader);\r\n  if (comment) {\r\n    if (!httpRegion.metaData.description) { // first comment gets description\r\n      httpRegion.metaData.description = comment.comment;\r\n    }\r\n    return {\r\n      nextParserLine: comment.endLine,\r\n      symbols: [{\r\n        name: 'comment',\r\n        description: comment.comment,\r\n        kind: HttpSymbolKind.comment,\r\n        startLine: comment.startLine,\r\n        startOffset: 0,\r\n        endLine: comment.endLine,\r\n        endOffset: comment.endOffset,\r\n      }],\r\n    };\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport interface CommentParserResult{\r\n  startLine: number,\r\n  endLine: number,\r\n  endOffset: number;\r\n  comment: string;\r\n}\r\n\r\n\r\nfunction getCommentContent(lineReader: HttpLineGenerator): CommentParserResult | false {\r\n  let next = lineReader.next();\r\n  if (!next.done) {\r\n\r\n    const startLine = next.value.line;\r\n    const singleLineMatch = ParserRegex.comment.singleline.exec(next.value.textLine);\r\n    if (singleLineMatch?.groups?.comment) {\r\n      return {\r\n        startLine,\r\n        endLine: startLine,\r\n        endOffset: next.value.textLine.length,\r\n        comment: singleLineMatch.groups.comment\r\n      };\r\n    }\r\n\r\n    const multiLineMatch = ParserRegex.comment.multilineStart.exec(next.value.textLine);\r\n    if (multiLineMatch) {\r\n      next = lineReader.next();\r\n      const lines: Array<string> = [];\r\n      while (!next.done) {\r\n        if (ParserRegex.comment.multilineEnd.test(next.value.textLine)) {\r\n          return {\r\n            startLine,\r\n            endLine: next.value.line,\r\n            endOffset: next.value.textLine.length,\r\n            comment: toMultiLineString(lines),\r\n          };\r\n        }\r\n        lines.push(next.value.textLine);\r\n        next = lineReader.next();\r\n      }\r\n\r\n    }\r\n  }\r\n  return false;\r\n}\r\n", "export * from './cookieJarAction';\r\nexport * from './createRequestAction';\r\nexport * from './defaultHeadersAction';\r\nexport * from './envDefaultsHeaderAction';\r\nexport * from './eventSourceClientAction';\r\nexport * from './gqlAction';\r\nexport * from './grpcClientAction';\r\nexport * from './httpClientAction';\r\nexport * from './loopMetaAction';\r\nexport * from './intellijAction';\r\nexport * from './importMetaAction';\r\nexport * from './initHooks';\r\nexport * from './httpClientAction';\r\nexport * from './mqttClientAction';\r\nexport * from './createReqeustBodyInterceptor';\r\nexport * from './responseAsVariableAction';\r\nexport * from './refMetaAction';\r\nexport * from './testMethod';\r\nexport * from './requestVariableReplacer';\r\nexport * from './webSocketClientAction';\r\n", "import { ActionType, HttpRegionAction, ProcessorContext } from '../models';\r\nimport { cookieStore } from '../store';\r\nimport { getHeader, isHttpRequest, isString } from '../utils';\r\nimport { CookieJar } from 'tough-cookie';\r\n\r\nexport class CookieJarAction implements HttpRegionAction {\r\n  id = ActionType.cookieJar;\r\n\r\n  async process({ request, httpRegion, httpFile, config }: ProcessorContext) : Promise<boolean> {\r\n    if (isHttpRequest(request)\r\n      && !httpRegion.metaData.noCookieJar\r\n      && config?.cookieJarEnabled) {\r\n      const jar = new CookieJar(cookieStore.getCookieStoreEntry(httpFile).memoryCookieStore);\r\n      if (request.headers && request.url) {\r\n        const cookieHeader = getHeader(request.headers, 'cookie');\r\n        if (cookieHeader) {\r\n          if (isString(cookieHeader)) {\r\n            await jar.setCookie(cookieHeader, request.url);\r\n          } else if (Array.isArray(cookieHeader)) {\r\n            for (const val of cookieHeader) {\r\n              await jar.setCookie(val, request.url);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      request.cookieJar = jar;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport cloneDeep = require('lodash/cloneDeep');\r\n\r\n\r\nexport class CreateRequestInterceptor implements models.HookInterceptor<models.ProcessorContext, boolean | void> {\r\n\r\n  async beforeTrigger(context: models.HookTriggerContext<models.ProcessorContext, boolean | undefined>): Promise<boolean | undefined> {\r\n    if (context.arg.httpRegion.request && context.index === 0) {\r\n      context.arg.progress?.report?.({\r\n        message: 'init request',\r\n      });\r\n      context.arg.request = cloneDeep(context.arg.httpRegion.request);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import { ActionType, HttpRegionAction, ProcessorContext } from '../models';\r\nimport * as utils from '../utils';\r\n\r\nexport class DefaultHeadersAction implements HttpRegionAction {\r\n  id = ActionType.defaultHeaders;\r\n\r\n  constructor(\r\n    private readonly data: string,\r\n    private readonly setHeaders: (headers: Record<string, unknown>, context: ProcessorContext) => void,\r\n  ) { }\r\n\r\n  async process(context: ProcessorContext) : Promise<boolean> {\r\n    if (this.data && context.variables) {\r\n      utils.report(context, 'set request headers');\r\n      const headers = await utils.evalExpression(this.data, context);\r\n      if (headers) {\r\n        this.setHeaders(Object.assign({}, headers), context);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\n\r\n\r\nexport async function attachDefaultHeaders(request: models.Request, context: models.ProcessorContext) : Promise<models.Request> {\r\n  if (request && context.config?.defaultHeaders) {\r\n    utils.report(context, 'set default request headers');\r\n    const defaultHeaders = context.config.defaultHeaders;\r\n    if (!request.headers) {\r\n      request.headers = {\r\n        ...defaultHeaders\r\n      };\r\n    } else {\r\n      for (const [key, value] of Object.entries(defaultHeaders)) {\r\n        if (!request.headers[key]) {\r\n          request.headers[key] = value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return request;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport EventSource from 'eventsource';\r\nimport * as io from '../io';\r\n\r\n\r\nexport class EventSourceClientAction implements models.HttpRegionAction {\r\n  id = models.ActionType.eventSourceClient;\r\n\r\n  async process(context: models.ProcessorContext): Promise<boolean> {\r\n    const { request } = context;\r\n    if (utils.isEventSourceRequest(request)) {\r\n      return await utils.triggerRequestResponseHooks(async () => {\r\n        if (request.url) {\r\n          utils.report(context, `reqeust Server-Sent Events ${request.url}`);\r\n          return await this.requestEventSource(request, context);\r\n        }\r\n        return false;\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private async requestEventSource(\r\n    request: models.EventSourceRequest,\r\n    context: models.ProcessorContext\r\n  ): Promise<models.HttpResponse> {\r\n    const { httpRegion } = context;\r\n\r\n    if (!request.url) {\r\n      throw new Error('request url undefined');\r\n    }\r\n    const options: EventSource.EventSourceInitDict = {};\r\n    if (httpRegion.metaData.noRejectUnauthorized) {\r\n      options.rejectUnauthorized = false;\r\n    }\r\n    const events = utils.getHeaderArray(request.headers, 'event') || ['data'];\r\n    const headers = { ...request.headers };\r\n    utils.deleteHeader(headers, 'event');\r\n    options.headers = headers;\r\n\r\n    const responseTemplate: Partial<models.HttpResponse> = {\r\n      request\r\n    };\r\n    const eventStream: { [key: string]: Array<unknown> } = {};\r\n    const loadingPromises: Array<Promise<unknown>> = [];\r\n\r\n    let disposeCancellation: models.Dispose | undefined;\r\n    try {\r\n      const client = new EventSource(request.url, options);\r\n      if (context.progress) {\r\n        disposeCancellation = context.progress?.register?.(() => {\r\n          client.close();\r\n        });\r\n      }\r\n      client.addEventListener('open', evt => {\r\n        io.log.debug('SSE open', evt);\r\n      });\r\n\r\n\r\n      for (const eventType of events) {\r\n        client.addEventListener(eventType, evt => {\r\n          io.log.debug(`SSE ${eventType}`, evt);\r\n          if (this.isMessageEvent(evt)) {\r\n            if (!eventStream[evt.type]) {\r\n              eventStream[evt.type] = [];\r\n            }\r\n            eventStream[evt.type].push(evt.data);\r\n            if (!context.httpRegion.metaData.noStreamingLog) {\r\n              if (context.logStream) {\r\n                loadingPromises.push(context.logStream('EventSource', evt.type, evt.data));\r\n              } else {\r\n                loadingPromises.push(utils.logResponse(this.toHttpResponse(evt, responseTemplate), context));\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      client.addEventListener('error', evt => {\r\n        io.log.debug('SSE error', evt);\r\n        eventStream.error = [evt];\r\n      });\r\n      await context.httpRegion.hooks.onStreaming.trigger(context);\r\n      await Promise.all(loadingPromises);\r\n      client.close();\r\n      const response = this.toMergedHttpResponse(eventStream, responseTemplate);\r\n      return response;\r\n    } finally {\r\n      if (disposeCancellation) {\r\n        disposeCancellation();\r\n      }\r\n    }\r\n  }\r\n\r\n  private isEventType(evt: unknown) : evt is {type: string} {\r\n    const data = evt as { type: string };\r\n    return !!data?.type;\r\n  }\r\n\r\n  private toMergedHttpResponse(data: Record<string, Array<unknown>>, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\r\n    const response = this.toHttpResponse(data, responseTemplate);\r\n    if (data.error) {\r\n      response.statusCode = -1;\r\n    }\r\n    return response;\r\n  }\r\n\r\n\r\n  private toHttpResponse(data: unknown, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\r\n    const body = JSON.stringify(data, null, 2);\r\n    const rawBody: Buffer = Buffer.from(body);\r\n    const response: models.HttpResponse = {\r\n      headers: {},\r\n      statusCode: 0,\r\n      ...responseTemplate,\r\n      protocol: 'SSE',\r\n      body,\r\n      prettyPrintBody: body,\r\n      parsedBody: data,\r\n      rawBody,\r\n      contentType: {\r\n        mimeType: 'application/json',\r\n        charset: 'UTF-8',\r\n        contentType: 'application/json; charset=utf-8'\r\n      },\r\n    };\r\n    if (this.isEventType(data) && data.type === 'error') {\r\n      response.statusCode = -1;\r\n    }\r\n    return response;\r\n  }\r\n\r\n  private isMessageEvent(obj: unknown): obj is EventSourceMessageEvent {\r\n    const evt = obj as EventSourceMessageEvent;\r\n    return !!evt.type && utils.isString(evt.type) && !!evt.data;\r\n  }\r\n}\r\n\r\ninterface EventSourceMessageEvent{\r\n  type: string;\r\n  data: unknown;\r\n}\r\n", "import { log, userInteractionProvider } from '../io';\r\nimport { ActionType, HttpRegionAction, ProcessorContext } from '../models';\r\nimport * as utils from '../utils';\r\n\r\nexport type GqlLoadData = string | ((context: ProcessorContext) => Promise<string | undefined>);\r\n\r\nexport interface GqlData{\r\n  operationName?: string;\r\n  query?: GqlLoadData;\r\n  fragments: Record<string, GqlLoadData>\r\n}\r\n\r\nexport interface GqlPostRequest{\r\n  query: string;\r\n  operationName?: string;\r\n  variables?: Record<string, unknown>\r\n}\r\n\r\n\r\nexport class GqlAction implements HttpRegionAction {\r\n  id = ActionType.gql;\r\n  before = [ActionType.httpClient];\r\n\r\n  constructor(private readonly gqlData: GqlData) {}\r\n\r\n  async process(context: ProcessorContext): Promise<boolean> {\r\n    if (context.request?.body && this.gqlData?.query) {\r\n      utils.report(context, 'build GraphQL query');\r\n      let query: string | undefined;\r\n      if (utils.isString(this.gqlData.query)) {\r\n        query = this.gqlData.query;\r\n      } else {\r\n        const result = await this.gqlData.query(context);\r\n        if (result) {\r\n          query = result;\r\n        } else {\r\n          const message = 'query import not found';\r\n          userInteractionProvider.showWarnMessage?.(message);\r\n          log.warn(message);\r\n        }\r\n      }\r\n\r\n      if (query) {\r\n        for (const [key, value] of Object.entries(this.gqlData.fragments)) {\r\n          if (query.indexOf(`...${key}`) >= 0) {\r\n            let fragment: string | undefined;\r\n            if (utils.isString(value)) {\r\n              fragment = value;\r\n            } else {\r\n              const result = await value(context);\r\n              if (result) {\r\n                fragment = result;\r\n              } else {\r\n                const message = `query fragment ${key} not found`;\r\n                userInteractionProvider.showWarnMessage?.(message);\r\n                log.warn(message);\r\n              }\r\n            }\r\n            if (fragment) {\r\n              query = utils.toMultiLineString([query, fragment]);\r\n            }\r\n          }\r\n        }\r\n        const gqlRequestBody: GqlPostRequest = {\r\n          query\r\n        };\r\n        if (this.gqlData.operationName) {\r\n          gqlRequestBody.operationName = this.gqlData.operationName;\r\n        }\r\n        if (utils.isString(context.request.body)) {\r\n          gqlRequestBody.variables = JSON.parse(context.request.body);\r\n        }\r\n        context.request.body = JSON.stringify(gqlRequestBody);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport { log } from '../io';\r\nimport * as utils from '../utils';\r\nimport { ParserRegex, ProtoProcessorContext } from '../parser';\r\nimport * as grpc from '@grpc/grpc-js';\r\nimport { Readable, Writable, Duplex } from 'stream';\r\n\r\n\r\ninterface GrpcError {\r\n  details?: string;\r\n  code?: number;\r\n  message?: string;\r\n}\r\n\r\ntype GrpcStream = Readable | Writable | Duplex;\r\n\r\ntype GrpcStreamAction = (stream: GrpcStream) => void;\r\n\r\nexport class GrpcClientAction implements models.HttpRegionAction {\r\n  id = models.ActionType.grpcClient;\r\n\r\n\r\n  async process(context: ProtoProcessorContext): Promise<boolean> {\r\n    grpc.setLogger(log);\r\n    const { request } = context;\r\n    const protoDefinitions = context.options.protoDefinitions;\r\n    if (utils.isGrpcRequest(request) && request?.url && protoDefinitions) {\r\n      return await utils.triggerRequestResponseHooks(async () => {\r\n        if (request.url) {\r\n          utils.report(context, `reqeust gRPC ${request.url}`);\r\n          const serviceData = this.getService(request.url, protoDefinitions);\r\n          if (serviceData.ServiceClass) {\r\n\r\n            const client = (new serviceData.ServiceClass(serviceData.server, this.getChannelCredentials(request)));\r\n            const method = client[serviceData.method]?.bind?.(client);\r\n            if (method) {\r\n              return await this.requestGrpc(method, serviceData.methodDefinition, request, context);\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private async requestGrpc(method: (...args: unknown[]) => (Readable | Writable | Duplex),\r\n    methodDefinition: grpc.MethodDefinition<unknown, unknown>,\r\n    request: models.GrpcRequest,\r\n    context: models.ProcessorContext): Promise<models.HttpResponse> {\r\n    const data = this.getData(request);\r\n    const metaData = this.getMetaData(request);\r\n\r\n    const startTime = new Date().getTime();\r\n    return await new Promise<models.HttpResponse>((resolve, reject) => {\r\n      const args: Array<unknown> = [\r\n        metaData,\r\n      ];\r\n\r\n      let disposeCancellation: models.Dispose | undefined;\r\n      let responseMetaData: Record<string, unknown> = {};\r\n      const grpcActions: Array<(stream: GrpcStream) => void> = [\r\n        stream => stream.on('metadata', (metaData: grpc.Metadata) => {\r\n          responseMetaData = metaData.getMap();\r\n        }),\r\n        stream => {\r\n          if (context.progress) {\r\n            disposeCancellation = context.progress.register(() => {\r\n              stream.destroy(new Error('Cancellation'));\r\n            });\r\n          }\r\n        },\r\n      ];\r\n\r\n      const getResponseTemplate: (() => Partial<models.HttpResponse>) = () => ({\r\n        headers: responseMetaData,\r\n        request,\r\n        timings: {\r\n          total: new Date().getTime() - startTime,\r\n        }\r\n      });\r\n\r\n      const streamResolve = (response: models.HttpResponse) => {\r\n        if (disposeCancellation) {\r\n          disposeCancellation();\r\n        }\r\n        resolve(response);\r\n      };\r\n\r\n      if (methodDefinition?.requestStream) {\r\n        grpcActions.push(...this.getRequestStreamActions(data, context, reject));\r\n      } else {\r\n        args.splice(0, 0, data);\r\n      }\r\n\r\n      if (methodDefinition?.responseStream) {\r\n        grpcActions.push(...this.getResponseStreamActions(methodDefinition.path, streamResolve, getResponseTemplate, context));\r\n      } else {\r\n        args.push((err: Error, data: unknown) => {\r\n          streamResolve(this.toHttpResponse(err || data, getResponseTemplate()));\r\n        });\r\n      }\r\n\r\n      const grpcStream = method(...args);\r\n      grpcActions.forEach(obj => obj(grpcStream));\r\n    });\r\n  }\r\n\r\n  private getRequestStreamActions(\r\n    data: unknown,\r\n    context: models.ProcessorContext,\r\n    reject: (reason?: unknown) => void\r\n  ): Array<GrpcStreamAction> {\r\n    return [\r\n      stream => {\r\n        if (data && stream instanceof Writable || stream instanceof Duplex) {\r\n          stream.write(data);\r\n        }\r\n      },\r\n      stream => {\r\n        if (stream instanceof Writable || stream instanceof Duplex) {\r\n          utils.setVariableInContext({ grpcStream: stream }, context);\r\n          context.httpRegion.hooks.onStreaming.trigger(context)\r\n            .then(() => stream.end())\r\n            .catch(err => reject(err));\r\n        }\r\n      }\r\n    ];\r\n  }\r\n\r\n  private getResponseStreamActions(\r\n    methodName: string,\r\n    resolve: (value: models.HttpResponse) => void,\r\n    getResponseTemplate: () => Partial<models.HttpResponse>,\r\n    context: models.ProcessorContext\r\n  ): Array<GrpcStreamAction> {\r\n    const loadingPromises: Array<Promise<unknown>> = [];\r\n    const mergedData: Array<unknown> = [];\r\n    let isResolved = false;\r\n    const resolveStreamFactory = (type: string) => async () => {\r\n      log.debug(`GRPC ${type}`);\r\n      if (!isResolved) {\r\n        isResolved = true;\r\n        utils.unsetVariableInContext({ grpcStream: true }, context);\r\n        await Promise.all(loadingPromises);\r\n        const response = this.toMergedHttpResponse(mergedData, getResponseTemplate());\r\n        resolve(response);\r\n      }\r\n    };\r\n    return [\r\n      stream => stream.on('data', chunk => {\r\n        log.debug('GRPC data', chunk);\r\n        mergedData.push(chunk);\r\n        if (!context.httpRegion.metaData.noStreamingLog) {\r\n          if (context.logStream) {\r\n            loadingPromises.push(context.logStream('gRPC', methodName, chunk));\r\n          } else {\r\n            loadingPromises.push(utils.logResponse(this.toHttpResponse(chunk, getResponseTemplate()), context));\r\n          }\r\n        }\r\n      }),\r\n      stream => stream.on('error', err => {\r\n        log.debug('GRPC error', err);\r\n        mergedData.push(err);\r\n      }),\r\n      stream => stream.on('end', resolveStreamFactory('end')),\r\n      stream => stream.on('close', resolveStreamFactory('close')),\r\n    ];\r\n  }\r\n\r\n  private getData(request: models.GrpcRequest): unknown {\r\n    if (utils.isString(request.body)) {\r\n      return JSON.parse(request.body);\r\n    }\r\n    if (Buffer.isBuffer(request.body)) {\r\n      return JSON.parse(request.body.toString('utf-8'));\r\n    }\r\n    return request.body;\r\n  }\r\n\r\n  private getChannelCredentials(request: models.GrpcRequest): grpc.ChannelCredentials {\r\n    if (request.headers) {\r\n      const channelCredentials = utils.getHeader(request.headers, 'channelcredentials') || utils.getHeader(request.headers, 'authorization');\r\n      if (channelCredentials instanceof grpc.ChannelCredentials) {\r\n        return channelCredentials;\r\n      }\r\n    }\r\n    return grpc.credentials.createInsecure();\r\n  }\r\n\r\n  private getMetaData(request: models.GrpcRequest): grpc.Metadata {\r\n    const metaData = new grpc.Metadata();\r\n    const specialKeys = ['authorization', 'channelcredentials'];\r\n    if (request.headers) {\r\n      for (const [key, value] of Object.entries(request.headers)) {\r\n        if (specialKeys.indexOf(key.toLowerCase()) < 0) {\r\n          if (utils.isString(value) || Buffer.isBuffer(value)) {\r\n            metaData.add(key, value);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return metaData;\r\n  }\r\n\r\n  private getService(url: string, protoDefinitions: Record<string, models.ProtoDefinition>) {\r\n    const urlMatch = ParserRegex.grpc.grpcUrl.exec(url);\r\n    if (urlMatch && urlMatch.groups?.service) {\r\n      const { server, service, method } = urlMatch.groups;\r\n      const flatServices = this.flattenProtoDefintions(protoDefinitions);\r\n\r\n      let ServiceClass = flatServices[service];\r\n      if (!ServiceClass) {\r\n        const serviceKey = Object.keys(flatServices).find(key => key.indexOf(service) >= 0);\r\n        if (serviceKey) {\r\n          log.warn(`service ${service} not found. Similar service ${serviceKey} is used.`);\r\n          ServiceClass = flatServices[serviceKey];\r\n        }\r\n      }\r\n      if (typeof ServiceClass === 'function') {\r\n        const methodDefinition = ServiceClass.service[method] || Object.entries(ServiceClass.service)\r\n          .filter(([key]) => key.toLowerCase() === method.toLowerCase())\r\n          .map(([, value]) => value)\r\n          .pop();\r\n        return {\r\n          server,\r\n          service,\r\n          method,\r\n          ServiceClass,\r\n          methodDefinition\r\n        };\r\n      }\r\n      log.error(`Service ${service} does not exist. Available Services`, ...Object.keys(flatServices));\r\n      throw new Error(`Service ${service} does not exist. Available Services: ${Object.keys(flatServices).join(', ')}`);\r\n    } else {\r\n      throw new Error(`Url ${url} does not match pattern <server>/<service>/<method>`);\r\n    }\r\n  }\r\n\r\n  private flattenProtoDefintions(protoDefinitions: Record<string, models.ProtoDefinition>) {\r\n    const result: grpc.GrpcObject = {};\r\n    for (const protoDefinition of Object.values(protoDefinitions)) {\r\n      if (protoDefinition.grpcObject) {\r\n        const grpcObject = this.getFlatGrpcObject(protoDefinition.grpcObject);\r\n        Object.assign(result, grpcObject);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getFlatGrpcObject(grpcObject: grpc.GrpcObject) {\r\n    return Object.entries(grpcObject).reduce((prev, curr) => {\r\n      if (typeof curr[1] === 'function') {\r\n        prev[curr[0]] = curr[1];\r\n      } else if (this.isGrpcObject(curr[1])) {\r\n        for (const [name, value] of Object.entries(this.getFlatGrpcObject(curr[1]))) {\r\n          prev[`${curr[0]}.${name}`] = value;\r\n        }\r\n      }\r\n      return prev;\r\n    }, {} as grpc.GrpcObject);\r\n  }\r\n\r\n  private isGrpcObject(obj: unknown): obj is grpc.GrpcObject {\r\n    const grpcObject = obj as grpc.GrpcObject;\r\n    return grpcObject && !grpcObject.format && typeof obj !== 'function';\r\n  }\r\n\r\n\r\n  private toHttpResponse(data: unknown, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\r\n    const json = JSON.stringify(data, null, 2);\r\n    const response: models.HttpResponse = {\r\n      headers: {},\r\n      ...responseTemplate,\r\n      statusCode: 0,\r\n      statusMessage: 'OK',\r\n      protocol: 'GRPC',\r\n      body: json,\r\n      prettyPrintBody: json,\r\n      parsedBody: data,\r\n      rawBody: Buffer.from(json),\r\n      contentType: {\r\n        mimeType: 'application/grpc+json',\r\n        charset: 'UTF-8',\r\n        contentType: 'application/grpc+json; charset=utf-8'\r\n      },\r\n    };\r\n    if (this.isGrpcError(data)) {\r\n      response.statusCode = data.code || -1;\r\n      response.statusMessage = data.details;\r\n    }\r\n    return response;\r\n  }\r\n\r\n  private toMergedHttpResponse(data: Array<unknown>, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\r\n    const response = this.toHttpResponse(data, responseTemplate);\r\n    const error = data.find(obj => this.isGrpcError(obj));\r\n    if (this.isGrpcError(error)) {\r\n      response.statusCode = error.code || -1;\r\n      response.statusMessage = error.details;\r\n    }\r\n    return response;\r\n  }\r\n\r\n  private isGrpcError(data: unknown): data is Error & GrpcError {\r\n    return data instanceof Error;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\n\r\n\r\nexport class HttpClientAction implements models.HttpRegionAction {\r\n  id = models.ActionType.httpClient;\r\n\r\n  async process(context: models.ProcessorContext): Promise<boolean> {\r\n    const { httpRegion, httpClient, request } = context;\r\n    if (utils.isHttpRequest(request)) {\r\n      request.proxy = httpRegion.metaData.proxy;\r\n      if (httpRegion.metaData.noRedirect) {\r\n        request.followRedirect = !httpRegion.metaData.noRedirect;\r\n      }\r\n      if (httpRegion.metaData.noRejectUnauthorized) {\r\n        request.rejectUnauthorized = false;\r\n      }\r\n      return utils.triggerRequestResponseHooks(async () => await httpClient(request, context), context);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\n\r\n\r\nexport enum LoopMetaType{\r\n  for,\r\n  forOf,\r\n  while,\r\n}\r\n\r\nexport interface LoopMetaData {\r\n  type: LoopMetaType;\r\n  iterable?: string;\r\n  variable?: string;\r\n  counter?: number;\r\n  expression?: string;\r\n}\r\n\r\n\r\nexport class LoopMetaAction implements models.HookInterceptor<models.ProcessorContext, boolean> {\r\n  id = models.ActionType.loop;\r\n  private iteration: AsyncGenerator<{\r\n    index: number;\r\n    variables: models.Variables\r\n  }> | undefined;\r\n\r\n  name: string | undefined;\r\n  constructor(private readonly data: LoopMetaData) { }\r\n\r\n  async beforeLoop(context: models.HookTriggerContext<models.ProcessorContext, boolean>) : Promise<boolean> {\r\n    this.iteration = this.iterate(context.arg);\r\n    this.name = context.arg.httpRegion.metaData.name;\r\n    context.arg.progress?.report?.({\r\n      message: 'start loop',\r\n    });\r\n    const next = await this.iteration.next();\r\n    if (!next.done) {\r\n      Object.assign(context.arg.variables, next.value.variables);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async afterTrigger(context: models.HookTriggerContext<models.ProcessorContext, boolean>): Promise<boolean> {\r\n    if (this.iteration && context.index + 1 === context.length) {\r\n\r\n      const next = await this.iteration.next();\r\n\r\n      if (!next.done) {\r\n        context.arg.progress?.report?.({\r\n          message: `${next.value.index} loop pass`,\r\n        });\r\n        Object.assign(context.arg.variables, next.value.variables);\r\n        await utils.logResponse(context.arg.httpRegion.response, context.arg);\r\n        context.arg.httpRegion = this.createHttpRegionClone(context.arg.httpRegion, next.value.index);\r\n        context.index = -1;\r\n      }\r\n    } else if (this.name && context.arg.variables[this.name]) {\r\n      context.arg.variables[`${this.name}0`] = context.arg.variables[this.name];\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private async *iterate(context: models.ProcessorContext) {\r\n    switch (this.data.type) {\r\n      case LoopMetaType.forOf:\r\n        if (this.data.variable && this.data.iterable) {\r\n          const array = await utils.evalExpression(this.data.iterable, context);\r\n          let iterable: Array<unknown> | undefined;\r\n          if (Array.isArray(array)) {\r\n            iterable = array;\r\n          }\r\n          if (iterable) {\r\n            let index = 0;\r\n            for (const variable of iterable) {\r\n              const variables: models.Variables = {\r\n                '$index': index,\r\n              };\r\n              variables[this.data.variable] = variable;\r\n              yield {\r\n                index,\r\n                variables\r\n              };\r\n              index++;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case LoopMetaType.for:\r\n        if (this.data.counter) {\r\n          for (let index = 0; index < this.data.counter; index++) {\r\n            yield {\r\n              index,\r\n              variables: {\r\n                '$index': index,\r\n              }\r\n            };\r\n          }\r\n        }\r\n        break;\r\n      case LoopMetaType.while:\r\n        if (this.data.expression) {\r\n          let index = 0;\r\n          while (await utils.evalExpression(this.data.expression, context)) {\r\n            yield {\r\n              index,\r\n              variables: {\r\n                '$index': index,\r\n              }\r\n            };\r\n            index++;\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n\r\n  private createHttpRegionClone(httpRegion: models.HttpRegion, index: number): models.HttpRegion {\r\n    return {\r\n      metaData: {\r\n        ...httpRegion.metaData,\r\n        name: this.name ? `${this.name}${index}` : undefined\r\n      },\r\n      request: httpRegion.request ? {\r\n        ...httpRegion.request\r\n      } : undefined,\r\n      symbol: httpRegion.symbol,\r\n      hooks: {\r\n        execute: new models.ExecuteHook(),\r\n        onRequest: new models.OnRequestHook(),\r\n        onStreaming: new models.OnStreaming(),\r\n        onResponse: new models.OnResponseHook(),\r\n      },\r\n      variablesPerEnv: httpRegion.variablesPerEnv,\r\n    };\r\n  }\r\n}\r\n", "import { ok } from 'assert';\r\nimport { ProcessorContext } from '../../models';\r\nimport { testFactory } from '../testMethod';\r\nimport { HttpClient as JetbrainsHttpClient, Variables as JetbrainsVariables } from './http-client';\r\nimport { IntellijVariables } from './intellijVariables';\r\n\r\nexport class IntellijHttpClient implements JetbrainsHttpClient {\r\n  global: JetbrainsVariables;\r\n  constructor(private readonly context: ProcessorContext) {\r\n    this.global = new IntellijVariables(context.variables, context.httpFile.activeEnvironment);\r\n  }\r\n  test(testName: string, func: () => void): void {\r\n    testFactory(this.context)(testName, func);\r\n  }\r\n  assert(condition: boolean, message?: string) : void {\r\n    ok(condition, message);\r\n  }\r\n  log(text: string): void {\r\n    if (this.context.scriptConsole) {\r\n      this.context.scriptConsole.info(text);\r\n    }\r\n  }\r\n}\r\n", "import { ProcessorContext, TestFunction, TestResult, testSymbols } from '../models';\r\nimport * as utils from '../utils';\r\nimport { default as chalk } from 'chalk';\r\n\r\nexport function testFactory({ httpRegion, scriptConsole }: ProcessorContext): TestFunction {\r\n  const testFunction = function test(message: string, testMethod: () => void): void {\r\n    const testResult: TestResult = {\r\n      message,\r\n      result: true\r\n    };\r\n    if (!httpRegion.testResults) {\r\n      httpRegion.testResults = [];\r\n    }\r\n    if (typeof testMethod === 'function') {\r\n      try {\r\n        testMethod();\r\n      } catch (err) {\r\n        process.exitCode = 20;\r\n        testResult.result = false;\r\n        if (utils.isError(err)) {\r\n          testResult.error = utils.parseError(err);\r\n        } else {\r\n          testResult.error = {\r\n            displayMessage: `${err}`,\r\n            error: new Error(`${err}`)\r\n          };\r\n        }\r\n      }\r\n    }\r\n    httpRegion.testResults.push(testResult);\r\n\r\n    scriptConsole?.logTest?.(\r\n      testResult.result,\r\n      testResult.result ? chalk`{green ${testSymbols.ok} ${testResult.message || 'Test passed'}}` : chalk`{red ${testSymbols.error} ${testResult.message || 'Test failed'} (${testResult.error?.displayMessage})}`\r\n    );\r\n  };\r\n\r\n  testFunction.status = (status: number) => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction(`response status equals to ${status}`, () => utils.assertStatusEquals(response, status));\r\n    }\r\n  };\r\n  testFunction.totalTime = (maxTotalTime: number) => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction(`total time exceeded ${maxTotalTime}`, () => utils.assertMaxTotalTime(response, maxTotalTime));\r\n    }\r\n  };\r\n  testFunction.header = (headerKey: string, val: string | string[] | undefined) => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction(`response header equals ${val}`, () => utils.assertHeaderEquals(response, headerKey, val));\r\n    }\r\n  };\r\n  testFunction.headerContains = (headerKey: string, val: string) => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction(`response header contains ${val}`, () => utils.assertHeaderContains(response, headerKey, val));\r\n    }\r\n  };\r\n  testFunction.responseBody = (val: unknown) => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction(`response body equals ${val}`, () => utils.assertResponseBodyEquals(response, val));\r\n    }\r\n  };\r\n\r\n  testFunction.hasResponseBody = () => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction('response body exists', () => utils.assertHasResponseBody(response));\r\n    }\r\n  };\r\n  testFunction.hasNoResponseBody = () => {\r\n    if (httpRegion.response) {\r\n      const response = httpRegion.response;\r\n      testFunction('response body does not exists', () => utils.assertHasNoResponseBody(response));\r\n    }\r\n  };\r\n  return testFunction;\r\n}\r\n", "export * from './dotenvVariableProvider';\r\nexport * from './initHooks';\r\nexport * from './intellijVariableProvider';\r\nexport * from './intellijGlobalVariableProvider';\r\n", "import { fileProvider, log } from '../../io';\r\nimport { PathLike, VariableProviderContext, Variables } from '../../models';\r\nimport { parse } from 'dotenv';\r\nimport * as utils from '../../utils';\r\n\r\nconst defaultFiles: Array<string> = ['.env'];\r\n\r\nexport async function provideDotenvEnvironments(context: VariableProviderContext): Promise<string[]> {\r\n\r\n  const files: Array<string> = [];\r\n\r\n  const globalEnv = process.env.HTTPYAC_ENV;\r\n  if (globalEnv && utils.isString(globalEnv)) {\r\n    const globalEnvAbsolute = await utils.toAbsoluteFilename(globalEnv, context.httpFile.rootDir, true);\r\n    if (globalEnvAbsolute) {\r\n      files.push(...await fileProvider.readdir(globalEnvAbsolute));\r\n    }\r\n  }\r\n  if (context.httpFile.rootDir) {\r\n    files.push(...await fileProvider.readdir(context.httpFile.rootDir));\r\n  }\r\n  if (context.config?.envDirName) {\r\n    const absolute = await utils.toAbsoluteFilename(context.config.envDirName, context.httpFile.rootDir, true);\r\n    if (absolute) {\r\n      files.push(...await fileProvider.readdir(absolute));\r\n    }\r\n    const dirOfFile = await utils.toAbsoluteFilename(fileProvider.dirname(context.httpFile.fileName), context.httpFile.rootDir);\r\n    if (dirOfFile) {\r\n      files.push(...await fileProvider.readdir(dirOfFile));\r\n    }\r\n  }\r\n\r\n  return files\r\n    .filter(file => file.startsWith('.env') || file.endsWith('.env'))\r\n    .filter(fileName => defaultFiles.indexOf(fileName) < 0)\r\n    .map(fileName => {\r\n      if (fileName.startsWith('.env')) {\r\n        return fileName.slice(5);\r\n      }\r\n      return fileName.slice(0, fileName.length - 4);\r\n    });\r\n}\r\n\r\nexport async function provideDotenvVariables(env: string[] | undefined, context: VariableProviderContext): Promise<Variables> {\r\n  const searchFiles = getSearchFiles(env);\r\n  const variables: Array<Variables> = [];\r\n\r\n  const globalEnv = process.env.HTTPYAC_ENV;\r\n  if (globalEnv && utils.isString(globalEnv)) {\r\n    const globalEnvAbsolute = await utils.toAbsoluteFilename(globalEnv, context.httpFile.rootDir, true);\r\n    if (globalEnvAbsolute) {\r\n      variables.push(...await getVariablesOfFolder(searchFiles, globalEnvAbsolute));\r\n    }\r\n  }\r\n\r\n  if (context.httpFile.rootDir) {\r\n    variables.push(...await getVariablesOfFolder(searchFiles, context.httpFile.rootDir));\r\n  }\r\n  if (context.config?.envDirName) {\r\n    const absolute = await utils.toAbsoluteFilename(context.config.envDirName, context.httpFile.rootDir, true);\r\n    if (absolute) {\r\n      variables.push(...await getVariablesOfFolder(searchFiles, absolute));\r\n    }\r\n  }\r\n  const dirOfFile = await utils.toAbsoluteFilename(fileProvider.dirname(context.httpFile.fileName), context.httpFile.rootDir);\r\n  if (dirOfFile) {\r\n    variables.push(...await getVariablesOfFolder(searchFiles, dirOfFile));\r\n  }\r\n  const result = Object.assign({}, ...variables);\r\n  return utils.expandVariables(result);\r\n}\r\n\r\nfunction getSearchFiles(env: string[] | undefined) {\r\n  const searchFiles = [...defaultFiles];\r\n  if (env) {\r\n    for (const environment of env) {\r\n      searchFiles.push(`${environment}.env`, `.env.${environment}`);\r\n    }\r\n  }\r\n  return searchFiles;\r\n}\r\n\r\nasync function getVariablesOfFolder(searchFiles: string[], workingDir: PathLike) {\r\n  const files = await fileProvider.readdir(workingDir);\r\n  const foundFiles = searchFiles.filter(file => files.indexOf(file) >= 0);\r\n  const vars = [];\r\n  for (const fileName of foundFiles) {\r\n    const envFileName = fileProvider.joinPath(workingDir, fileName);\r\n    try {\r\n      const content = await fileProvider.readFile(envFileName, 'utf-8');\r\n      const variables = parse(content);\r\n      vars.push(variables);\r\n    } catch (err) {\r\n      log.trace(`${fileProvider.toString(workingDir)}/${fileName} not found`);\r\n    }\r\n  }\r\n  return vars;\r\n}\r\n", "import { VariableProviderContext, Variables } from '../../models';\r\nimport { expandVariables } from '../../utils';\r\n\r\n\r\nconst DEFAULT_ENV = '$shared';\r\n\r\n\r\nexport async function provideConfigEnvironments(context: VariableProviderContext): Promise<string[]> {\r\n  if (context.config?.environments) {\r\n    return Object.keys(context.config.environments).filter(obj => obj !== DEFAULT_ENV);\r\n  }\r\n  return [];\r\n}\r\n\r\nexport async function provideConfigVariables(envs: string[] | undefined, context: VariableProviderContext): Promise<Variables> {\r\n\r\n  const variables: Variables[] = [];\r\n\r\n  if (context.config?.environments) {\r\n    const environments = context.config.environments;\r\n\r\n    variables.push(environments[DEFAULT_ENV]);\r\n    if (envs) {\r\n      variables.push(...envs.map(env => environments[env]));\r\n    }\r\n  }\r\n  return expandVariables(Object.assign({}, ...variables));\r\n}\r\n", "import { fileProvider, log } from '../../io';\r\nimport { PathLike, VariableProviderContext, Variables } from '../../models';\r\nimport { expandVariables, toAbsoluteFilename } from '../../utils';\r\n\r\nconst defaultFiles: Array<string> = ['http-client.env.json', 'http-client.private.env.json'];\r\n\r\nexport async function provideIntellijEnvironments(context: VariableProviderContext): Promise<string[]> {\r\n  const environments = await getAllEnvironmentVariables(context);\r\n  return environments\r\n    .reduce((prev, current) => {\r\n      for (const [env] of Object.entries(current)) {\r\n        prev.push(env);\r\n      }\r\n      return prev;\r\n    }, [] as Array<string>);\r\n}\r\n\r\nasync function getAllEnvironmentVariables(context: VariableProviderContext) {\r\n  const environments: Array<Record<string, Variables>> = [];\r\n\r\n  if (context.httpFile.rootDir) {\r\n    environments.push(...await getEnvironmentVariables(context.httpFile.rootDir));\r\n  }\r\n  if (context.config?.envDirName) {\r\n    const absolute = await toAbsoluteFilename(context.config.envDirName, context.httpFile.rootDir, true);\r\n    if (absolute) {\r\n      environments.push(...await getEnvironmentVariables(absolute));\r\n    }\r\n  }\r\n  const dirOfFile = await toAbsoluteFilename(fileProvider.dirname(context.httpFile.fileName), context.httpFile.rootDir);\r\n  if (dirOfFile) {\r\n    environments.push(...await getEnvironmentVariables(dirOfFile));\r\n  }\r\n  return environments;\r\n}\r\n\r\nexport async function provideIntellijVariables(envs: string[] | undefined, context: VariableProviderContext): Promise<Variables> {\r\n  const environments = await getAllEnvironmentVariables(context);\r\n  const variables: Array<Variables> = [];\r\n  if (envs) {\r\n    for (const env of envs) {\r\n      variables.push(...environments\r\n        .filter(obj => !!obj[env])\r\n        .map(obj => obj[env]));\r\n    }\r\n  }\r\n  return expandVariables(Object.assign({}, ...variables));\r\n}\r\n\r\nasync function getEnvironmentVariables(workingDir: PathLike) {\r\n  const environments: Array<Record<string, Variables>> = [];\r\n  for (const file of defaultFiles) {\r\n    try {\r\n      const fileName = fileProvider.joinPath(workingDir, file);\r\n      if (await fileProvider.exists(fileName)) {\r\n        const content = await fileProvider.readFile(fileName, 'utf-8');\r\n        environments.push(JSON.parse(content));\r\n      }\r\n    } catch (err) {\r\n      log.trace(`${fileProvider.toString(workingDir)}/${file} not found`);\r\n    }\r\n  }\r\n  return environments;\r\n}\r\n", "import { Variables } from '../../models';\r\nimport { toEnvironmentKey } from '../../utils';\r\n\r\nexport const intellijVariableCache: Record<string, Variables> = {};\r\n\r\n\r\nexport async function provideIntellijGlobalVariables(env: string[] | undefined): Promise<Variables> {\r\n  const envkey = toEnvironmentKey(env);\r\n  if (!intellijVariableCache[envkey]) {\r\n    intellijVariableCache[envkey] = {};\r\n  }\r\n  return intellijVariableCache[envkey];\r\n}\r\n", "import { provideConfigVariables, provideConfigEnvironments } from './configVariableProvider';\r\nimport { provideDotenvVariables, provideDotenvEnvironments } from './dotenvVariableProvider';\r\nimport { provideIntellijVariables, provideIntellijEnvironments } from './intellijVariableProvider';\r\nimport { provideIntellijGlobalVariables } from './intellijGlobalVariableProvider';\r\nimport { ProvideVariablesHook, ProvideEnvironmentsHook } from '../../models';\r\n\r\nexport enum VariableProviderType{\r\n  config = 'config',\r\n  dotenv = 'dotenv',\r\n  httpFileImports = 'httpFileImports',\r\n  httpFile = 'httpFile',\r\n  intellij = 'intellij',\r\n  intellijGlobal = 'intellijGlobal',\r\n}\r\n\r\nexport function initProvideVariablesHook(): ProvideVariablesHook {\r\n  const hook = new ProvideVariablesHook();\r\n\r\n  hook.addHook(VariableProviderType.config, provideConfigVariables);\r\n  hook.addHook(VariableProviderType.dotenv, provideDotenvVariables);\r\n  hook.addHook(VariableProviderType.intellij, provideIntellijVariables);\r\n  hook.addHook(VariableProviderType.intellijGlobal, provideIntellijGlobalVariables);\r\n\r\n  return hook;\r\n}\r\n\r\n\r\nexport function initProvideEnvironmentsHook(): ProvideEnvironmentsHook {\r\n  const hook = new ProvideEnvironmentsHook();\r\n\r\n  hook.addHook(VariableProviderType.config, provideConfigEnvironments);\r\n  hook.addHook(VariableProviderType.dotenv, provideDotenvEnvironments);\r\n  hook.addHook(VariableProviderType.intellij, provideIntellijEnvironments);\r\n\r\n\r\n  return hook;\r\n}\r\n", "import { Variables } from '../../models';\r\nimport { Variables as JetbrainsVariables } from './http-client';\r\n\r\nimport { intellijVariableCache } from '../../variables/provider';\r\nimport { toEnvironmentKey } from '../../utils';\r\n\r\nexport class IntellijVariables implements JetbrainsVariables {\r\n  constructor(\r\n    private readonly variables: Variables,\r\n    private readonly env: string[] | undefined\r\n  ) { }\r\n\r\n  private get globalCache() {\r\n    return intellijVariableCache[toEnvironmentKey(this.env)];\r\n  }\r\n\r\n  set(varName: string, varValue: string): void {\r\n    this.globalCache[varName] = varValue;\r\n    this.variables[varName] = varValue;\r\n  }\r\n  get(varName: string): unknown {\r\n    return this.variables[varName];\r\n  }\r\n  isEmpty(): boolean {\r\n    return Object.entries(this.globalCache).length === 0;\r\n  }\r\n  clear(varName: string): void {\r\n    delete this.globalCache[varName];\r\n    delete this.variables[varName];\r\n  }\r\n  clearAll(): void {\r\n    for (const [key] of Object.entries(this.globalCache)) {\r\n      delete this.globalCache[key];\r\n      delete this.variables[key];\r\n    }\r\n  }\r\n}\r\n", "import { HttpResponse } from '../../models';\r\nimport { isString } from '../../utils';\r\nimport {\r\n  HttpResponse as JetbrainsHttpResponse,\r\n  ContentType as JetbrainsContentType,\r\n  ResponseHeaders as JetbrainsResponseHeaders\r\n} from './http-client';\r\n\r\n\r\nexport class IntellijHttpResponse implements JetbrainsHttpResponse {\r\n  body: unknown;\r\n  status: number;\r\n  contentType: JetbrainsContentType;\r\n  headers: JetbrainsResponseHeaders;\r\n\r\n  constructor(response: HttpResponse) {\r\n    this.body = response.parsedBody || response.body;\r\n    this.status = response.statusCode;\r\n    this.contentType = {\r\n      mimeType: response.contentType?.mimeType || 'application/octet-stream',\r\n      charset: response.contentType?.charset || 'utf-8'\r\n    };\r\n    this.headers = new IntellijHeaders(response.headers);\r\n  }\r\n}\r\n\r\nexport class IntellijHeaders implements JetbrainsResponseHeaders {\r\n\r\n  constructor(private readonly headers: Record<string, unknown> | undefined) {}\r\n\r\n  valueOf(headerName: string): string | null {\r\n    if (this.headers) {\r\n      const obj = this.headers[headerName];\r\n      if (obj && isString(obj)) {\r\n        return obj;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  valuesOf(headerName: string): string[] {\r\n    if (this.headers) {\r\n      const obj = this.headers[headerName];\r\n      if (obj && Array.isArray(obj)) {\r\n        return obj;\r\n      }\r\n    }\r\n    return [];\r\n  }\r\n\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { fileProvider, userInteractionProvider, log } from '../io';\r\n\r\n\r\nimport * as intellij from './intellij';\r\n\r\nexport interface IntellijScriptData{\r\n  fileName: string;\r\n}\r\n\r\n\r\nexport class IntellijAction implements models.HttpRegionAction {\r\n  id = models.ActionType.intellij;\r\n\r\n  constructor(private readonly scriptData: models.ScriptData | IntellijScriptData) { }\r\n\r\n  async process(context: models.ProcessorContext): Promise<boolean> {\r\n    const intellijVars = initIntellijVariables(context);\r\n\r\n    let data: models.ScriptData;\r\n    if (this.isIntellijScriptData(this.scriptData)) {\r\n      const script = await this.loadScript(this.scriptData.fileName, context);\r\n      if (!script) {\r\n        return false;\r\n      }\r\n      data = {\r\n        script,\r\n        lineOffset: 0\r\n      };\r\n    } else {\r\n      data = this.scriptData;\r\n    }\r\n\r\n    utils.report(context, 'execute intellij javascript');\r\n    await utils.runScript(data.script, {\r\n      fileName: context.httpFile.fileName,\r\n      context: {\r\n        console: context.scriptConsole,\r\n        ...intellijVars,\r\n      },\r\n      lineOffset: data.lineOffset\r\n    });\r\n    return true;\r\n  }\r\n\r\n\r\n  private async loadScript(file: string, context: models.ProcessorContext) {\r\n    try {\r\n      return await utils.replaceFilePath(file, context, path => fileProvider.readFile(path, 'utf-8'));\r\n    } catch (err) {\r\n      userInteractionProvider.showErrorMessage?.(`error loading script ${file}`);\r\n      log.error(file, err);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private isIntellijScriptData(scriptData: IntellijScriptData | models.ScriptData): scriptData is IntellijScriptData {\r\n    const guard = scriptData as IntellijScriptData;\r\n    return !!guard.fileName;\r\n  }\r\n}\r\n\r\n\r\nfunction initIntellijVariables(context: models.ProcessorContext) {\r\n  let response: unknown;\r\n  if (context.httpRegion.response) {\r\n    response = new intellij.IntellijHttpResponse(context.httpRegion.response);\r\n  }\r\n  const client = new intellij.IntellijHttpClient(context);\r\n  return {\r\n    client,\r\n    response,\r\n  };\r\n}\r\n", "import { executeGlobalScripts, toAbsoluteFilename } from '../utils';\r\nimport { ActionType, HttpRegionAction, ProcessorContext, HttpFile } from '../models';\r\nimport { HttpFileStore } from '../store';\r\nimport { fileProvider, log } from '../io';\r\n\r\n\r\nexport interface ImportProcessorContext extends ProcessorContext{\r\n  options: {\r\n    httpFiles?: Array<HttpFile>\r\n  }\r\n}\r\n\r\nexport class ImportMetaAction implements HttpRegionAction {\r\n  id = ActionType.import;\r\n\r\n  constructor(\r\n    private readonly fileName: string,\r\n    private readonly httpFileStore: HttpFileStore\r\n  ) { }\r\n\r\n  async process(context: ImportProcessorContext): Promise<boolean> {\r\n    const absoluteFileName = await toAbsoluteFilename(this.fileName, context.httpFile.fileName);\r\n    if (absoluteFileName) {\r\n      log.trace(`parse imported file ${absoluteFileName}`);\r\n      const text = await fileProvider.readFile(absoluteFileName, 'utf-8');\r\n      const importHttpFile = await this.httpFileStore.getOrCreate(absoluteFileName, () => Promise.resolve(text), 0, {\r\n        workingDir: context.httpFile.rootDir,\r\n        config: context.config,\r\n        activeEnvironment: context.httpFile.activeEnvironment,\r\n      });\r\n      if (!context.options.httpFiles) {\r\n        context.options.httpFiles = [importHttpFile];\r\n      } else {\r\n        context.options.httpFiles.push(importHttpFile);\r\n      }\r\n\r\n      const cloneContext: ImportProcessorContext = {\r\n        ...context,\r\n        httpFile: importHttpFile,\r\n      };\r\n      log.trace(`execute global scripts for import ${absoluteFileName}`);\r\n      return await executeGlobalScripts(cloneContext);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\n\r\n\r\nexport async function requestVariableReplacer(request: models.Request, context: models.ProcessorContext): Promise<models.Request | typeof models.HookCancel> {\r\n  utils.report(context, 'replace variables in request');\r\n  if (request.url) {\r\n    const result = await utils.replaceVariables(request.url, models.VariableType.url, context) || request.url;\r\n    if (result === models.HookCancel) {\r\n      return models.HookCancel;\r\n    }\r\n    if (utils.isString(result)) {\r\n      request.url = result;\r\n    }\r\n  }\r\n  if (await replaceVariablesInBody(request, context) === false) {\r\n    return models.HookCancel;\r\n  }\r\n  if (await replaceVariablesInHeader(request, context) === false) {\r\n    return models.HookCancel;\r\n  }\r\n  return request;\r\n}\r\n\r\nasync function replaceVariablesInBody(replacedReqeust: models.Request, context: models.ProcessorContext) : Promise<boolean> {\r\n  if (replacedReqeust.body) {\r\n    if (utils.isString(replacedReqeust.body)) {\r\n      const result = await utils.replaceVariables(replacedReqeust.body, models.VariableType.body, context);\r\n      if (result === models.HookCancel) {\r\n        return false;\r\n      }\r\n      if (utils.isString(result) || Buffer.isBuffer(result)) {\r\n        replacedReqeust.body = result;\r\n      }\r\n    } else if (Array.isArray(replacedReqeust.body)) {\r\n      const replacedBody: Array<models.HttpRequestBodyLine> = [];\r\n      for (const obj of replacedReqeust.body) {\r\n        if (utils.isString(obj)) {\r\n          const result = await utils.replaceVariables(obj, models.VariableType.body, context);\r\n          if (result === models.HookCancel) {\r\n            return false;\r\n          }\r\n          if (utils.isString(result)) {\r\n            replacedBody.push(result);\r\n          }\r\n        } else {\r\n          replacedBody.push(obj);\r\n        }\r\n      }\r\n      replacedReqeust.body = replacedBody;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nasync function replaceVariablesInHeader(request: models.Request, context: models.ProcessorContext) : Promise<boolean> {\r\n  if (request.headers) {\r\n    for (const [headerName, headerValue] of Object.entries(request.headers)) {\r\n      if (Array.isArray(headerValue)) {\r\n        const result = [];\r\n        for (const headerVal of headerValue) {\r\n          const value = await utils.replaceVariables(headerVal, headerName, context);\r\n          if (value === models.HookCancel) {\r\n            return false;\r\n          }\r\n          result.push(value);\r\n        }\r\n        request.headers[headerName] = result;\r\n      } else {\r\n        const value = await utils.replaceVariables(headerValue, headerName, context);\r\n        if (value === models.HookCancel) {\r\n          return false;\r\n        }\r\n        request.headers[headerName] = value;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport encodeUrl from 'encodeurl';\r\n\r\nexport async function transformRequestBody(request: models.Request): Promise<models.Request> {\r\n  if (request.body) {\r\n    if (utils.isString(request.body)) {\r\n      if (utils.isMimeTypeFormUrlEncoded(request.contentType)) {\r\n        request.body = encodeUrl(request.body);\r\n      }\r\n    } else if (Array.isArray(request.body)\r\n      && request.body.some(obj => typeof obj === 'function')\r\n      && request.body.every(obj => ['function', 'string'].indexOf(typeof obj) >= 0)) {\r\n      request.body = await normalizeBody(request.body);\r\n    }\r\n  }\r\n  return request;\r\n}\r\n\r\n\r\nasync function normalizeBody(body: Array<models.HttpRequestBodyLine>) : Promise<Buffer> {\r\n  const buffers: Array<Buffer> = [];\r\n  for (const obj of body) {\r\n    if (utils.isString(obj)) {\r\n      buffers.push(Buffer.from(obj));\r\n    } else {\r\n      buffers.push(await obj());\r\n    }\r\n  }\r\n  return Buffer.concat(buffers);\r\n}\r\n", "import { log, userInteractionProvider } from '../io';\r\nimport * as models from '../models';\r\nimport * as utils from '../utils';\r\n\r\n\r\nexport async function responseAsVariable(response: models.HttpResponse, context: models.ProcessorContext): Promise<models.HttpResponse> {\r\n  const body = response.parsedBody || response.body;\r\n  context.variables.response = response;\r\n  if (context.httpRegion.metaData.name || context.httpRegion.metaData.jwt) {\r\n    handleJWTMetaData(body, context);\r\n    handleNameMetaData(body, context);\r\n  }\r\n  return response;\r\n}\r\n\r\nfunction handleNameMetaData(body: unknown, context: models.ProcessorContext) {\r\n  const { httpRegion } = context;\r\n  if (httpRegion.metaData.name) {\r\n    const name = httpRegion.metaData.name\r\n      .trim()\r\n      .replace(/\\s/u, '_')\r\n      .replace(/-./gu, value => value[1].toUpperCase());\r\n    if (utils.isValidVariableName(name)) {\r\n      utils.setVariableInContext({ [name]: body }, context);\r\n    } else {\r\n      const message = `Javascript Keyword ${name} not allowed as name`;\r\n      userInteractionProvider.showWarnMessage?.(message);\r\n      log.warn(message);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction handleJWTMetaData(body: unknown, { httpRegion }: models.ProcessorContext) {\r\n  if (httpRegion.metaData.jwt && httpRegion.response) {\r\n    if (body && typeof body === 'object') {\r\n      const entries = Object.entries(body);\r\n\r\n      let checkEntries = entries;\r\n      if (utils.isString(httpRegion.metaData.jwt)) {\r\n        const jwt = httpRegion.metaData.jwt;\r\n        checkEntries = entries.filter(([key]) => jwt.indexOf(key) >= 0);\r\n      }\r\n      for (const [key, value] of checkEntries) {\r\n        const val = parseJwtToken(value);\r\n        if (val) {\r\n          entries.push([`${key}_parsed`, val]);\r\n        }\r\n      }\r\n      httpRegion.response.parsedBody = Object.fromEntries(entries);\r\n      httpRegion.response.prettyPrintBody = httpRegion.response.body = JSON.stringify(httpRegion.response.parsedBody, null, 2);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nfunction parseJwtToken(value: unknown) : utils.JWTToken | null {\r\n  if (utils.isString(value)) {\r\n    try {\r\n      return utils.decodeJWT(value);\r\n    } catch (err) {\r\n      log.error(err);\r\n    }\r\n  }\r\n  return null;\r\n}\r\n", "import { setAdditionalResponseBody } from '../utils';\r\nimport * as models from '../models';\r\nimport { attachDefaultHeaders } from './envDefaultsHeaderAction';\r\nimport { requestVariableReplacer } from './requestVariableReplacer';\r\nimport { transformRequestBody } from './transformRequestBodyAction';\r\nimport { responseAsVariable } from './responseAsVariableAction';\r\n\r\nexport function initOnRequestHook(): models.OnRequestHook {\r\n  const hook = new models.OnRequestHook();\r\n  hook.addHook('attachDefaultHeaders', attachDefaultHeaders);\r\n  hook.addHook('requestVariableReplacer', requestVariableReplacer);\r\n  hook.addHook('transformRequestBody', transformRequestBody);\r\n  return hook;\r\n}\r\n\r\nexport function initOnResponseHook(): models.OnResponseHook {\r\n  const hook = new models.OnResponseHook();\r\n  hook.addHook('addAdditionalBody', setAdditionalResponseBody);\r\n  hook.addHook('responseAsVariable', responseAsVariable);\r\n  return hook;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport * as io from '../io';\r\nimport { connect, IClientOptions, QoS, MqttClient } from 'mqtt';\r\n\r\n\r\ninterface MQTTMessage{\r\n  topic: string;\r\n  message: string;\r\n  date: Date,\r\n}\r\n\r\nexport class MQTTClientAction implements models.HttpRegionAction {\r\n  id = models.ActionType.websocketClient;\r\n\r\n\r\n  async process(context: models.ProcessorContext): Promise<boolean> {\r\n    const { request } = context;\r\n    if (utils.isMQTTRequest(request)) {\r\n      return await utils.triggerRequestResponseHooks(async () => {\r\n        if (request.url) {\r\n          utils.report(context, `request MQTT ${request.url}`);\r\n\r\n          return await this.requestMQTT(request, context);\r\n        }\r\n        return false;\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private async requestMQTT(\r\n    request: models.MQTTRequest,\r\n    context: models.ProcessorContext\r\n  ): Promise<models.HttpResponse> {\r\n    const { httpRegion } = context;\r\n\r\n\r\n    return await new Promise<models.HttpResponse>((resolve, reject) => {\r\n      if (!request.url) {\r\n        reject(new Error('request url undefined'));\r\n        return;\r\n      }\r\n\r\n      const options: IClientOptions = {\r\n        clientId: `httpyac_${Math.random().toString(16).slice(2, 8)}`,\r\n        username: utils.getHeader(request.headers, 'username'),\r\n        password: utils.getHeader(request.headers, 'password'),\r\n        keepalive: utils.toNumber(utils.getHeader(request.headers, 'keepalive')),\r\n        clean: !!utils.getHeader(request.headers, 'clean'),\r\n        ...request.options,\r\n      };\r\n\r\n      if (httpRegion.metaData.noRejectUnauthorized) {\r\n        options.rejectUnauthorized = false;\r\n      }\r\n\r\n      const responseTemplate: Partial<models.HttpResponse> = {\r\n        request\r\n      };\r\n      const mergedData: Array<MQTTMessage | Error> = [];\r\n      const loadingPromises: Array<Promise<unknown>> = [];\r\n\r\n      let disposeCancellation: models.Dispose | undefined;\r\n      if (context.progress) {\r\n        disposeCancellation = context.progress?.register?.(() => {\r\n          client.end(true, undefined, err => err && io.log.error('error on close', err));\r\n        });\r\n      }\r\n\r\n      const client = connect(request.url, options);\r\n      const mqttVariables = { mqttClient: client };\r\n      client.on('connect', packet => {\r\n        io.log.debug('MQTT connect', packet);\r\n        responseTemplate.protocol = packet.protocolId || 'MQTT';\r\n        responseTemplate.headers = packet.properties;\r\n        if (packet.protocolVersion) {\r\n          responseTemplate.httpVersion = `${packet.protocolVersion}`;\r\n        }\r\n      });\r\n      client.on('reconnect', () => io.log.debug('MQTT reconnect'));\r\n      client.on('message', (topic, message, packet) => {\r\n        io.log.debug('MQTT message', message, packet);\r\n        mergedData.push({\r\n          topic,\r\n          message: message.toString('utf-8'),\r\n          date: new Date(),\r\n        });\r\n        if (!context.httpRegion.metaData.noStreamingLog) {\r\n          if (context.logStream) {\r\n            loadingPromises.push(context.logStream('MQTT', topic, message));\r\n          }\r\n        }\r\n      });\r\n      client.on('packetsend', packet => io.log.debug('MQTT packetsend', packet));\r\n      client.on('packetreceive', packet => io.log.debug('MQTT packetreceive', packet));\r\n      client.on('disconnect', packet => io.log.debug('MQTT disconnect', packet));\r\n      client.on('close', () => io.log.debug('MQTT close'));\r\n      client.on('offline', () => io.log.debug('MQTT offline'));\r\n      client.on('error', err => {\r\n        io.log.debug('MQTT error', err);\r\n        mergedData.push(err);\r\n      });\r\n      client.on('end', async () => {\r\n        io.log.debug('MQTT end');\r\n        if (disposeCancellation) {\r\n          disposeCancellation();\r\n        }\r\n        utils.unsetVariableInContext(mqttVariables, context);\r\n        await Promise.all(loadingPromises);\r\n        resolve(this.toMergedHttpResponse(mergedData, responseTemplate));\r\n      });\r\n\r\n\r\n      const subscribeArray = utils.getHeaderArray(request.headers, 'subscribe');\r\n      if (subscribeArray) {\r\n        this.subscribeToTopics(client, subscribeArray, this.toQoS(utils.getHeader(request.headers, 'qos')));\r\n      }\r\n      const publishArray = utils.getHeaderArray(request.headers, 'publish');\r\n      if (publishArray) {\r\n        this.publishToTopics(client, publishArray, request);\r\n      }\r\n      const topics = utils.getHeaderArray(request.headers, 'topic');\r\n      if (topics) {\r\n        this.subscribeToTopics(client, topics, this.toQoS(utils.getHeader(request.headers, 'qos')));\r\n        this.publishToTopics(client, topics, request);\r\n      }\r\n      utils.setVariableInContext(mqttVariables, context);\r\n      context.httpRegion.hooks.onStreaming.trigger(context)\r\n        .then(() => client.end())\r\n        .catch(err => reject(err));\r\n    });\r\n  }\r\n\r\n  private subscribeToTopics(client: MqttClient, topics: string[], qos: QoS) {\r\n    for (const topic of topics) {\r\n      client.subscribe(topic, {\r\n        qos,\r\n      });\r\n    }\r\n  }\r\n  private publishToTopics(client: MqttClient, topics: string[], request: models.MQTTRequest) {\r\n    if (request.body) {\r\n      for (const topic of topics) {\r\n        client.publish(topic, request.body, {\r\n          qos: this.toQoS(utils.getHeader(request.headers, 'qos')),\r\n          retain: !!utils.getHeader(request.headers, 'retain')\r\n        }, err => err && io.log.error('publish error', err));\r\n      }\r\n    }\r\n  }\r\n\r\n  private toQoS(qos: string |undefined) : QoS {\r\n    switch (qos) {\r\n      case '2': return 2;\r\n      case '1': return 1;\r\n      default: return 0;\r\n    }\r\n  }\r\n\r\n  private toMergedHttpResponse(\r\n    data: Array< MQTTMessage | Error>,\r\n    responseTemplate: Partial<models.HttpResponse>\r\n  ): models.HttpResponse {\r\n    const body = JSON.stringify(data, null, 2);\r\n    const rawBody: Buffer = Buffer.isBuffer(data) ? data : Buffer.from(body);\r\n    const response: models.HttpResponse = {\r\n      statusCode: 0,\r\n      protocol: 'MQTT',\r\n      contentType: {\r\n        mimeType: 'application/json',\r\n        charset: 'UTF-8',\r\n        contentType: 'application/json; charset=utf-8'\r\n      },\r\n      headers: {},\r\n      ...responseTemplate,\r\n      body,\r\n      rawBody,\r\n    };\r\n\r\n    const error = data.find(obj => this.isMQTTError(obj));\r\n    if (error && this.isMQTTError(error)) {\r\n      response.statusCode = error.errno || -1;\r\n      response.statusMessage = error.code;\r\n    }\r\n    return response;\r\n  }\r\n\r\n\r\n  private isMQTTError(data: unknown): data is Error & { code: string, errno: number;} {\r\n    return data instanceof Error;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { fileProvider } from '../io';\r\nimport { EOL } from 'os';\r\n\r\n\r\nexport class CreateRequestBodyInterceptor implements models.HookInterceptor<models.ProcessorContext, boolean | void> {\r\n\r\n  constructor(private readonly rawBody: Array<string | models.RequestBodyImport>) {}\r\n\r\n  async beforeTrigger(context: models.HookTriggerContext<models.ProcessorContext, boolean | undefined>): Promise<boolean | undefined> {\r\n    if (context.arg.request && context.index === 0) {\r\n      const contentType = context.arg.request.contentType;\r\n      const requestBodyLines = await this.normalizeBody(this.rawBody, context.arg);\r\n      if (requestBodyLines.length > 0) {\r\n        context.arg.progress?.report?.({\r\n          message: 'init request body',\r\n        });\r\n        if (utils.isMimeTypeFormUrlEncoded(contentType)) {\r\n          context.arg.request.body = this.formUrlEncodedJoin(requestBodyLines);\r\n        } else {\r\n          if (requestBodyLines.every(obj => utils.isString(obj)) && utils.isMimeTypeNewlineDelimitedJSON(contentType)) {\r\n            requestBodyLines.push('');\r\n          }\r\n\r\n          const body: Array<models.HttpRequestBodyLine> = [];\r\n          const strings: Array<string> = [];\r\n          const lineEnding = utils.isMimeTypeMultiPartFormData(contentType) ? '\\r\\n' : EOL;\r\n\r\n          for (const line of requestBodyLines) {\r\n            if (utils.isString(line)) {\r\n              strings.push(line);\r\n            } else {\r\n              if (strings.length > 0) {\r\n                strings.push(lineEnding);\r\n                body.push(strings.join(lineEnding));\r\n                strings.length = 0;\r\n              }\r\n              body.push(line);\r\n              strings.push('');\r\n            }\r\n          }\r\n\r\n          if (strings.length > 0 && body.length === 0) {\r\n            context.arg.request.body = strings.join(lineEnding);\r\n          } else {\r\n            if (strings.length > 0) {\r\n              body.push(strings.join(lineEnding));\r\n            }\r\n            context.arg.request.body = body;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private async normalizeBody(rawBody: Array<string | models.RequestBodyImport>, context: models.ProcessorContext) {\r\n    const result: Array<models.HttpRequestBodyLine> = [];\r\n    const forceInjectVariables = (filename: string) => {\r\n      if (context.httpRegion.metaData.injectVariables) {\r\n        return true;\r\n      }\r\n      if (context.config?.requestBodyInjectVariablesExtensions) {\r\n        const extname = utils.extensionName(filename);\r\n        if (extname) {\r\n          return context.config.requestBodyInjectVariablesExtensions\r\n            .indexOf(extname) >= 0;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n\r\n    for (const line of rawBody) {\r\n      if (utils.isString(line)) {\r\n        result.push(line);\r\n      } else {\r\n        const buffer = await utils.replaceFilePath(line.fileName, context, async (path: models.PathLike) => {\r\n          if (forceInjectVariables(line.fileName) || line.injectVariables) {\r\n            return await fileProvider.readFile(path, line.encoding);\r\n          }\r\n          return () => fileProvider.readBuffer(path);\r\n        });\r\n        if (buffer) {\r\n          result.push(buffer);\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private formUrlEncodedJoin(body: Array<models.HttpRequestBodyLine>): string {\r\n    const result = body.reduce((previousValue, currentValue, currentIndex) => {\r\n      let prev = previousValue;\r\n      if (utils.isString(currentValue)) {\r\n        prev += `${(currentIndex === 0 || currentValue.startsWith('&') ? '' : EOL)}${currentValue}`;\r\n      }\r\n      return prev;\r\n    }, '');\r\n    if (utils.isString(result)) {\r\n      return result;\r\n    }\r\n    return '';\r\n  }\r\n}\r\n", "import * as utils from '../utils';\r\nimport { ActionType, HttpRegionAction } from '../models';\r\nimport { ImportProcessorContext } from './importMetaAction';\r\nimport { log } from '../io';\r\nexport interface RefMetaHttpRegionData {\r\n  name: string;\r\n  force: boolean;\r\n}\r\n\r\nexport class RefMetaAction implements HttpRegionAction {\r\n  id = ActionType.ref;\r\n\r\n  constructor(private readonly data: RefMetaHttpRegionData) { }\r\n\r\n  async process(context: ImportProcessorContext): Promise<boolean> {\r\n    utils.report(context, `load reference ${this.data.name}`);\r\n    for (const refHttpRegion of context.httpFile.httpRegions) {\r\n      if (refHttpRegion.metaData.name === this.data.name\r\n        && !refHttpRegion.metaData.disabled\r\n        && refHttpRegion !== context.httpRegion) {\r\n        const envkey = utils.toEnvironmentKey(context.httpFile.activeEnvironment);\r\n        log.trace('import variables', refHttpRegion.variablesPerEnv[envkey]);\r\n        Object.assign(context.variables, refHttpRegion.variablesPerEnv[envkey]);\r\n        if (this.data.force || !context.variables[this.data.name]) {\r\n          const refContext = { ...context, httpRegion: refHttpRegion };\r\n          await utils.processHttpRegionActions(refContext);\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    if (context.options.httpFiles) {\r\n      for (const refHttpFile of context.options.httpFiles) {\r\n        const cloneContext = {\r\n          ...context,\r\n          options: {\r\n            ...context.options,\r\n          },\r\n          httpFile: refHttpFile\r\n        };\r\n        delete cloneContext.options.httpFiles;\r\n        await this.process(cloneContext);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport WebSocket, { ClientOptions } from 'ws';\r\nimport * as io from '../io';\r\n\r\n\r\nconst WEBSOCKET_CLOSE_NORMAL = 1000;\r\nconst WEBSOCKET_CLOSE_GOING_AWAY = 1001;\r\nexport class WebSocketClientAction implements models.HttpRegionAction {\r\n  id = models.ActionType.websocketClient;\r\n\r\n\r\n  async process(context: models.ProcessorContext): Promise<boolean> {\r\n    const { request } = context;\r\n    if (utils.isWebsocketRequest(request)) {\r\n      return await utils.triggerRequestResponseHooks(async () => {\r\n        if (request.url) {\r\n          utils.report(context, `reqeust websocket ${request.url}`);\r\n          return await this.requestWebsocket(request, context);\r\n        }\r\n        return false;\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private async requestWebsocket(\r\n    request: models.WebsocketRequest,\r\n    context: models.ProcessorContext\r\n  ): Promise<models.HttpResponse> {\r\n    const { httpRegion } = context;\r\n\r\n    const startTime = new Date().getTime();\r\n\r\n    return await new Promise<models.HttpResponse>((resolve, reject) => {\r\n      if (!request.url) {\r\n        reject(new Error('request url undefined'));\r\n        return;\r\n      }\r\n      const options: ClientOptions = Object.assign({}, request.options);\r\n      if (httpRegion.metaData.noRedirect) {\r\n        options.followRedirects = !httpRegion.metaData.noRedirect;\r\n      }\r\n      if (httpRegion.metaData.noRejectUnauthorized) {\r\n        options.rejectUnauthorized = false;\r\n      }\r\n      options.headers = request.headers;\r\n\r\n      const responseTemplate: Partial<models.HttpResponse> = {\r\n        request\r\n      };\r\n      const mergedData: Array<unknown> = [];\r\n      const loadingPromises: Array<Promise<unknown>> = [];\r\n\r\n      const getResponseTemplate: (() => Partial<models.HttpResponse>) = () => {\r\n        responseTemplate.timings = {\r\n          total: new Date().getTime() - startTime,\r\n        };\r\n        return responseTemplate;\r\n      };\r\n\r\n      const client = new WebSocket(request.url, options);\r\n      const webSocketVariables = { websocketClient: client };\r\n      let disposeCancellation: models.Dispose | undefined;\r\n      if (context.progress) {\r\n        disposeCancellation = context.progress?.register?.(() => {\r\n          client.close(WEBSOCKET_CLOSE_GOING_AWAY, 'CLOSE_GOING_AWAY');\r\n        });\r\n      }\r\n\r\n      client.on('open', () => {\r\n        io.log.debug('WebSocket open');\r\n        if (request.body) {\r\n          client.send(request.body, err => io.log.error(err));\r\n        }\r\n        utils.setVariableInContext(webSocketVariables, context);\r\n        context.variables.websocketClient = client;\r\n        context.httpRegion.hooks.onStreaming.trigger(context)\r\n          .then(() => client.close(WEBSOCKET_CLOSE_NORMAL, 'CLOSE_NORMAL'))\r\n          .catch(err => reject(err));\r\n      });\r\n      client.on('upgrade', message => {\r\n        io.log.debug('WebSocket upgrade', message);\r\n        responseTemplate.headers = message.headers;\r\n        responseTemplate.statusCode = message.statusCode;\r\n        responseTemplate.statusMessage = message.statusMessage;\r\n        responseTemplate.httpVersion = message.httpVersion;\r\n      });\r\n\r\n      const handleResponseFactory = (type: string) => (data: Buffer | WebSocket.RawData) => {\r\n        const body = this.toStringBody(data);\r\n        io.log.debug(`WebSocket ${type}`, body);\r\n        mergedData.push({ type, body });\r\n        if (!context.httpRegion.metaData.noStreamingLog) {\r\n          if (context.logStream) {\r\n            loadingPromises.push(context.logStream('WebSocket', type, body));\r\n          } else {\r\n            loadingPromises.push(utils.logResponse(this.toHttpResponse(body, getResponseTemplate()), context));\r\n          }\r\n        }\r\n      };\r\n\r\n      client.on('ping', handleResponseFactory('ping'));\r\n      client.on('pong', handleResponseFactory('pong'));\r\n      client.on('message', handleResponseFactory('message'));\r\n      client.on('error', err => {\r\n        io.log.debug('WebSocket error', err);\r\n        mergedData.push(err);\r\n      });\r\n\r\n      client.on('close', async (code, reason) => {\r\n        io.log.debug('WebSocket close', code, reason);\r\n        if (disposeCancellation) {\r\n          disposeCancellation();\r\n        }\r\n        utils.unsetVariableInContext(webSocketVariables, context);\r\n        await Promise.all(loadingPromises);\r\n        resolve(this.toMergedHttpResponse(code, reason, mergedData, getResponseTemplate()));\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  private toMergedHttpResponse(\r\n    code: number,\r\n    reason: Buffer | string,\r\n    data: Array<unknown>,\r\n    responseTemplate: Partial<models.HttpResponse>\r\n  ): models.HttpResponse {\r\n    const response = this.toHttpResponse(data, responseTemplate);\r\n    response.statusCode = code;\r\n    response.statusMessage = Buffer.isBuffer(reason) ? reason.toString('utf-8') : reason;\r\n    return response;\r\n  }\r\n\r\n  private toStringBody(data: unknown) : string {\r\n    if (Buffer.isBuffer(data)) {\r\n      return data.toString('utf-8');\r\n    }\r\n    let jsonData = data;\r\n    if (Array.isArray(data) && data.every(obj => Buffer.isBuffer(obj))) {\r\n      jsonData = data.map(obj => Buffer.isBuffer(obj) && obj.toString('utf8'));\r\n    }\r\n    return JSON.stringify(jsonData, null, 2);\r\n  }\r\n\r\n  private toHttpResponse(data: string | Array<unknown>, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\r\n    const body = utils.isString(data) ? data : JSON.stringify(data, null, 2);\r\n    const rawBody: Buffer = Buffer.from(body);\r\n    const response: models.HttpResponse = {\r\n      headers: {},\r\n      statusCode: 200,\r\n      ...responseTemplate,\r\n      protocol: 'WebSocket',\r\n      body,\r\n      prettyPrintBody: body,\r\n      parsedBody: data,\r\n      rawBody,\r\n      contentType: {\r\n        mimeType: 'application/json',\r\n        charset: 'UTF-8',\r\n        contentType: 'application/json; charset=utf-8'\r\n      },\r\n    };\r\n    if (this.isWebsocketError(data)) {\r\n      response.statusCode = -1;\r\n      response.statusMessage = data.code;\r\n    }\r\n    return response;\r\n  }\r\n\r\n  private isWebsocketError(data: unknown): data is Error & {code: string} {\r\n    return data instanceof Error;\r\n  }\r\n\r\n}\r\n", "import * as models from '../../models';\r\n\r\nexport function defaultMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\r\n  context.httpRegion.metaData = Object.assign(context.httpRegion.metaData || {}, {\r\n    [type]: value || true,\r\n  });\r\n  return true;\r\n}\r\n", "import { ImportMetaAction } from '../../actions';\r\nimport * as models from '../../models';\r\n\r\nexport function importMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\r\n  if (type === 'import' && value) {\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new ImportMetaAction(\r\n      value, context.httpFileStore\r\n    ));\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n", "import { RefMetaAction } from '../../actions';\r\nimport * as models from '../../models';\r\n\r\nexport function refMetaDataHandler(type: string, name: string | undefined, context: models.ParserContext) : boolean {\r\n  if (['ref', 'forceRef'].indexOf(type) >= 0 && name) {\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new RefMetaAction({\r\n      name,\r\n      force: type === 'forceRef'\r\n    }));\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n", "import { LoopMetaAction, LoopMetaType } from '../../actions';\r\nimport * as models from '../../models';\r\nimport { ParserRegex } from '../parserRegex';\r\n\r\nexport function loopMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) : boolean {\r\n  if (type === 'loop' && value) {\r\n    const forOfMatch = ParserRegex.meta.forOf.exec(value);\r\n    if (forOfMatch?.groups?.iterable && forOfMatch?.groups?.variable) {\r\n      context.httpRegion.hooks.execute.addInterceptor(new LoopMetaAction({\r\n        type: LoopMetaType.forOf,\r\n        variable: forOfMatch.groups.variable,\r\n        iterable: forOfMatch.groups.iterable,\r\n      }));\r\n      return true;\r\n    }\r\n    const forMatch = ParserRegex.meta.for.exec(value);\r\n    if (forMatch?.groups?.counter) {\r\n      context.httpRegion.hooks.execute.addInterceptor(new LoopMetaAction({\r\n        type: LoopMetaType.for,\r\n        counter: Number.parseInt(forMatch.groups.counter, 10),\r\n      }));\r\n      return true;\r\n    }\r\n    const whileMatch = ParserRegex.meta.while.exec(value);\r\n    if (whileMatch?.groups?.expression) {\r\n      context.httpRegion.hooks.execute.addInterceptor(new LoopMetaAction({\r\n        type: LoopMetaType.while,\r\n        expression: whileMatch.groups.expression,\r\n      }));\r\n      return true;\r\n    }\r\n\r\n\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../../models';\r\nimport { userSessionStore } from '../../store';\r\nimport * as utils from '../../utils';\r\n\r\nexport function keepStreamingMetaDataHandler(type: string, _value: string | undefined, context: models.ParserContext) {\r\n  if (type === 'keepStreaming') {\r\n    context.httpRegion.hooks.onStreaming.addHook('keepStreaming', async (context: models.ProcessorContext) => {\r\n      if (context.request) {\r\n        const streamSession: models.UserSession = {\r\n          id: getStreamSessionId(context.request),\r\n          type: 'Stream',\r\n          title: `${context.request.method} ${context.request.url}`,\r\n          description: 'Pending Stream',\r\n          details: context.request.headers || {}\r\n        };\r\n        utils.report(context, 'stream until manual cancellation');\r\n        await new Promise(resolve => {\r\n          userSessionStore.setUserSession(streamSession);\r\n          streamSession.delete = () => resolve(true);\r\n        });\r\n\r\n      }\r\n    });\r\n    context.httpRegion.hooks.onResponse.addHook('keepStreaming', (_response, context) => {\r\n      if (context.request) {\r\n        userSessionStore.removeUserSession(getStreamSessionId(context.request));\r\n      }\r\n    });\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function getStreamSessionId(request: models.Request) {\r\n  return `${request.method}_${request.url}_${Object.values(request.headers || {}).join('_')}`;\r\n}\r\n", "import * as models from '../../models';\r\nimport { ParserRegex } from '../parserRegex';\r\nimport { userSessionStore } from '../../store';\r\nimport * as utils from '../../utils';\r\nimport { log } from '../../io';\r\n\r\nexport function rateLimitMetaDataHandler(type: string, value: string | undefined, { httpRegion }: models.ParserContext) {\r\n  if (type === 'ratelimit' && value) {\r\n    const match = ParserRegex.meta.rateLimit.exec(value);\r\n    if (match?.groups) {\r\n      const slot = match.groups.slot || 'rateLimit';\r\n      const minIdleTime = match.groups.minIdleTime || '0';\r\n      const max = match.groups.max || '0';\r\n      const expire = match.groups.expire || '0';\r\n\r\n      httpRegion.hooks.execute.addHook('rateLimit', async context => {\r\n        const rateLimitSession = getRateLimitSession(slot,\r\n          Number.parseInt(minIdleTime, 10),\r\n          Number.parseInt(max, 10),\r\n          Number.parseInt(expire, 10));\r\n\r\n        rateLimitSession.requests.push(await checkRateLimit(rateLimitSession, context));\r\n        return true;\r\n      });\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nasync function checkRateLimit(rateLimitSession: RateLimitSession, context: models.ProcessorContext) {\r\n  while (rateLimitSession.requests.length > 0) {\r\n    const currentRequest = new Date();\r\n    removeExpiredRequests(rateLimitSession.requests, currentRequest, rateLimitSession.expire);\r\n\r\n    if (rateLimitSession.max > 0 && rateLimitSession.requests.length >= rateLimitSession.max) {\r\n      const first = rateLimitSession.requests[0];\r\n      const freeSlotTime = rateLimitSession.expire + first.getTime() - currentRequest.getTime();\r\n\r\n      if (freeSlotTime > 0) {\r\n        utils.report(context, `rate limit max reached. wait for ${freeSlotTime}`);\r\n        log.debug(`rate limit max reached. wait for ${freeSlotTime} (slot ${rateLimitSession.slot})`);\r\n        await utils.sleep(freeSlotTime);\r\n        log.trace('rate limit max waited');\r\n      }\r\n      continue;\r\n    }\r\n    if (rateLimitSession.requests.length > 0) {\r\n      const lastRequest = rateLimitSession.requests[rateLimitSession.requests.length - 1];\r\n      if (lastRequest && rateLimitSession.minIdleTime > 0) {\r\n        const minIdleTime = lastRequest.getTime() + rateLimitSession.minIdleTime - currentRequest.getTime();\r\n        if (minIdleTime > 0) {\r\n          utils.report(context, `rate limit minIdleTime, wait for ${minIdleTime}`);\r\n          log.debug(`rate limit minIdleTime, wait for ${minIdleTime} (slot ${rateLimitSession.slot})`);\r\n          await utils.sleep(minIdleTime);\r\n          log.trace('rate limit minIdleTime waited');\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n    return currentRequest;\r\n  }\r\n  return new Date();\r\n}\r\n\r\ninterface RateLimitSession extends models.UserSession{\r\n  slot: string;\r\n  minIdleTime: number;\r\n  max: number;\r\n  expire: number,\r\n  lastRequest?: Date;\r\n  requests: Array<Date>;\r\n}\r\n\r\n\r\nfunction isRateLimitSession(session: unknown): session is RateLimitSession {\r\n  const rateLimitSession = session as RateLimitSession;\r\n  return !!rateLimitSession?.requests && rateLimitSession.type === 'RateLimit';\r\n}\r\n\r\nfunction getRateLimitSession(slot: string, minIdleTime: number, max: number, expire: number) {\r\n  const sessionId = `ratelimit_${slot}`;\r\n  const session = userSessionStore.getUserSession(sessionId);\r\n\r\n  if (isRateLimitSession(session)) {\r\n    session.max = max;\r\n    session.minIdleTime = minIdleTime;\r\n    session.expire = expire;\r\n    return session;\r\n  }\r\n\r\n  const description = [];\r\n  if (minIdleTime > 0) {\r\n    description.push(`minIdleTime ${minIdleTime}ms`);\r\n  }\r\n  if (expire > 0) {\r\n    description.push(`max ${max} with expire ${expire}ms`);\r\n  }\r\n\r\n  const result: RateLimitSession = {\r\n    id: sessionId,\r\n    type: 'RateLimit',\r\n    title: `rate limit slot ${slot}`,\r\n    details: {\r\n      slot,\r\n      minIdleTime,\r\n      max,\r\n      expire,\r\n    },\r\n    description: description.join(', '),\r\n    slot,\r\n    minIdleTime,\r\n    max,\r\n    expire,\r\n    requests: []\r\n  };\r\n  userSessionStore.setUserSession(result);\r\n  return result;\r\n}\r\n\r\nfunction removeExpiredRequests(requests: Array<Date>, current: Date, expire: number) {\r\n  if (expire > 0) {\r\n    let index = 0;\r\n    for (const request of requests) {\r\n      if (current.getTime() - request.getTime() >= expire) {\r\n        index++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    requests.splice(0, index);\r\n  } else {\r\n    requests.splice(0, requests.length - 1);\r\n  }\r\n}\r\n", "import * as models from '../../models';\r\n\r\nexport function responseRefMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\r\n  if (type === 'responseRef' && value) {\r\n    if (!context.httpRegion.responseRefs) {\r\n      context.httpRegion.responseRefs = [];\r\n    }\r\n    context.httpRegion.responseRefs.push(value);\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../../models';\r\nimport { sleep, evalExpression } from '../../utils';\r\n\r\nexport function sleepMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\r\n  if (type === 'sleep' && value) {\r\n    context.httpRegion.hooks.execute.addHook('sleep', async ctx => {\r\n      const timeout = await evalExpression(value, ctx);\r\n      if (Number.isSafeInteger(timeout)) {\r\n        await sleep(timeout as number);\r\n      }\r\n      return true;\r\n    });\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../../models';\r\nimport { log } from '../../io';\r\nexport function verboseMetaDataHandler(type: string, _value: string | undefined, context: models.ParserContext) {\r\n  if (type === 'verbose' || type === 'debug') {\r\n    const level = type === 'debug' ? models.LogLevel.debug : models.LogLevel.trace;\r\n    log.options.level = level;\r\n    context.httpRegion.hooks.execute.addInterceptor({\r\n      async beforeLoop() {\r\n        log.options.level = level;\r\n        return true;\r\n      }\r\n    });\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { ParserRegex } from './parserRegex';\r\nimport { log } from '../io';\r\nimport * as metaData from './metaData';\r\n\r\n\r\nexport async function parseMetaData(getLineReader: models.getHttpLineGenerator, context: models.ParserContext): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const { httpRegion, data } = context;\r\n  if (data.metaTitle) {\r\n    httpRegion.metaData.title = data.metaTitle.trim();\r\n    if (!httpRegion.metaData.name) {\r\n      httpRegion.metaData.name = data.metaTitle.trim();\r\n    }\r\n    delete data.metaTitle;\r\n  }\r\n\r\n  const next = lineReader.next();\r\n  if (!next.done) {\r\n    const textLine = next.value.textLine;\r\n    if (ParserRegex.meta.all.test(textLine)) {\r\n      if (isMarkdownRequest(context)) {\r\n        if (textLine.trim() !== '###') {\r\n          log.debug('request with markdown only supports delimiter after request line');\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const result: models.HttpRegionParserResult = {\r\n        nextParserLine: next.value.line,\r\n        symbols: [],\r\n      };\r\n      const delimiterMatch = ParserRegex.meta.delimiter.exec(textLine);\r\n      if (delimiterMatch) {\r\n        result.endRegionLine = next.value.line - 1;\r\n        result.symbols.push({\r\n          name: 'separator',\r\n          description: delimiterMatch.groups?.title || '-',\r\n          kind: models.HttpSymbolKind.metaData,\r\n          startLine: next.value.line,\r\n          startOffset: 0,\r\n          endLine: next.value.line,\r\n          endOffset: textLine.length\r\n        });\r\n        data.metaTitle = delimiterMatch.groups?.title;\r\n      } else {\r\n        const commentResult = parseComments(next.value, context, ParserRegex.meta.all);\r\n        if (commentResult) {\r\n          result.symbols = commentResult.symbols;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport function parseComments(httpLine: models.HttpLine, context: models.ParserContext, metaRegex: RegExp): models.SymbolParserResult | false {\r\n  if (metaRegex.test(httpLine.textLine)) {\r\n    const result: models.SymbolParserResult = {\r\n      symbols: [{\r\n        name: 'comment',\r\n        description: httpLine.textLine,\r\n        kind: models.HttpSymbolKind.metaData,\r\n        startLine: httpLine.line,\r\n        startOffset: 0,\r\n        endLine: httpLine.line,\r\n        endOffset: httpLine.textLine.length\r\n      }]\r\n    };\r\n    const match = ParserRegex.meta.data.exec(httpLine.textLine);\r\n    if (match && match.groups && match.groups.key) {\r\n      const key = match.groups.key.replace(/-./gu, value => value[1].toUpperCase());\r\n      result.symbols[0].children = [{\r\n        name: key,\r\n        description: match.groups.value || '-',\r\n        kind: models.HttpSymbolKind.metaData,\r\n        startLine: httpLine.line,\r\n        startOffset: 0,\r\n        endLine: httpLine.line,\r\n        endOffset: httpLine.textLine.length,\r\n        children: [{\r\n          name: key,\r\n          description: knownMetaData.find(obj => obj.name === key)?.description || 'key of meta data',\r\n          kind: models.HttpSymbolKind.key,\r\n          startLine: httpLine.line,\r\n          startOffset: httpLine.textLine.indexOf(match.groups.key),\r\n          endLine: httpLine.line,\r\n          endOffset: httpLine.textLine.indexOf(match.groups.key) + match.groups.key.length,\r\n        }]\r\n      }];\r\n      if (match.groups.value) {\r\n        result.symbols[0].children.push({\r\n          name: match.groups.value,\r\n          description: 'value of meta data',\r\n          kind: models.HttpSymbolKind.value,\r\n          startLine: httpLine.line,\r\n          startOffset: httpLine.textLine.indexOf(match.groups.value),\r\n          endLine: httpLine.line,\r\n          endOffset: httpLine.textLine.indexOf(match.groups.value) + match.groups.value.length,\r\n        });\r\n      }\r\n      const metaDataHandlers = [\r\n        metaData.importMetaDataHandler,\r\n        metaData.keepStreamingMetaDataHandler,\r\n        metaData.loopMetaDataHandler,\r\n        metaData.rateLimitMetaDataHandler,\r\n        metaData.refMetaDataHandler,\r\n        metaData.responseRefMetaDataHandler,\r\n        metaData.sleepMetaDataHandler,\r\n        metaData.verboseMetaDataHandler,\r\n      ];\r\n      metaDataHandlers.push(metaData.defaultMetaDataHandler);\r\n      for (const metaDataHandler of metaDataHandlers) {\r\n        if (metaDataHandler(key, match.groups.value, context)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction isMarkdownRequest(context: models.ParserContext) {\r\n  if (context.httpRegion.request?.headers) {\r\n    const contentType = utils.parseContentType(context.httpRegion.request.headers);\r\n    if (utils.isMimeTypeMarkdown(contentType)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport const knownMetaData: Array<{\r\n  name: string,\r\n  description: string;\r\n  completions?: Array<string>\r\n}> = [\r\n  {\r\n    name: 'name',\r\n    description: 'responses of a requests with a name are automatically added as variables and can be reused by other requests',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'debug',\r\n    description: 'enable debug log level',\r\n  }, {\r\n    name: 'description',\r\n    description: 'additional description of region',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'disabled',\r\n    description: 'requests can be disabled',\r\n  }, {\r\n    name: 'extension',\r\n    description: 'extension of file for save or openWith.',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'forceRef',\r\n    description: 'When the request is called, it is ensured that the referenced request is always called beforehand',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'import',\r\n    description: 'reference Requests from other files.',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'injectVariables',\r\n    description: 'Inject Variables in request body (needed because of compatibility with Intellij).',\r\n  }, {\r\n    name: 'jwt',\r\n    description: 'supports auto decode of jwt token.',\r\n  }, {\r\n    name: 'language',\r\n    description: 'language id of the response view',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'loop',\r\n    description: 'allows multiple Invocations of a Request with different parameters.',\r\n    completions: ['for ${1} of ${2}', 'for ${1}', 'while ${1}']\r\n  }, {\r\n    name: 'keepStreaming',\r\n    description: 'keep streaming until the user session is ended manually',\r\n  }, {\r\n    name: 'noLog',\r\n    description: 'prevent logging of request data in output console',\r\n  }, {\r\n    name: 'noCookieJar',\r\n    description: 'cookieJar support is disabled for this request',\r\n  }, {\r\n    name: 'noClientCert',\r\n    description: 'SSL client certificate is not send for this request',\r\n  }, {\r\n    name: 'noRejectUnauthorized',\r\n    description: 'all invalid SSL certificates will be ignored and no error will be thrown.',\r\n  }, {\r\n    name: 'noResponseView',\r\n    description: 'prevent output in editor document.',\r\n  }, {\r\n    name: 'noStreamingLog',\r\n    description: 'prevent logging of streaming request data in output console',\r\n  }, {\r\n    name: 'note',\r\n    description: 'shows a confirmation dialog before sending request',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'openWith',\r\n    description: 'viewType of custom editor to preview files',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'ref',\r\n    description: 'When the request is called, it is ensured that the referenced request is called beforehand',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'ratelimit',\r\n    description: 'allows throttling requests',\r\n    completions: ['minIdleTime ${1}', 'max ${1} expire ${2}', 'minIdleTime ${1} max ${2} expire ${3}']\r\n  }, {\r\n    name: 'save',\r\n    description: 'If specified, the response will not be displayed but saved directly.',\r\n  }, {\r\n    name: 'sleep',\r\n    description: 'wait specified millisecondes, before next step.',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'title',\r\n    description: 'additional title of region',\r\n    completions: ['${1}']\r\n  }, {\r\n    name: 'verbose',\r\n    description: 'enable trace log level',\r\n  }\r\n];\r\n", "import * as actions from '../actions';\r\nimport * as models from '../models';\r\nimport { ParserRegex } from './parserRegex';\r\nimport { parseComments as parseMetaComments } from './metaHttpRegionParser';\r\n\r\nexport type ParseLineMethod = (httpLine: models.HttpLine, context: models.ParserContext) => (models.SymbolParserResult | false);\r\n\r\nexport interface ParseSubsequentLinesResult{\r\n  nextLine?: number;\r\n  parseResults: Array<models.SymbolParserResult>\r\n}\r\n\r\nexport function parseSubsequentLines(\r\n  lineReader: models.HttpLineGenerator,\r\n  requestLineParser: Array<ParseLineMethod>,\r\n  context: models.ParserContext\r\n): ParseSubsequentLinesResult {\r\n  const result: ParseSubsequentLinesResult = {\r\n    parseResults: [],\r\n  };\r\n  let next = lineReader.next();\r\n  while (!next.done) {\r\n    let hasResult = false;\r\n    for (const lineParser of requestLineParser) {\r\n      const parseResult = lineParser(next.value, context);\r\n      if (parseResult) {\r\n        result.parseResults.push(parseResult);\r\n        hasResult = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!hasResult) {\r\n      break;\r\n    }\r\n    result.nextLine = next.value.line;\r\n\r\n    next = lineReader.next();\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\nexport function parseRequestHeaderFactory(headers: Record<string, unknown>): ParseLineMethod {\r\n  return function parseRequestHeader(httpLine: models.HttpLine) {\r\n    const headerMatch = ParserRegex.request.header.exec(httpLine.textLine);\r\n    if (headerMatch?.groups?.key && headerMatch?.groups?.value) {\r\n      const headerName = headerMatch.groups.key;\r\n      const headerValue = headerMatch.groups.value;\r\n\r\n      const existingHeader = headers[headerName];\r\n      if (existingHeader) {\r\n        if (Array.isArray(existingHeader)) {\r\n          existingHeader.push(headerValue);\r\n        } else {\r\n          headers[headerName] = [existingHeader, headerValue];\r\n        }\r\n      } else {\r\n        headers[headerName] = headerValue;\r\n      }\r\n\r\n      return {\r\n        symbols: [{\r\n          name: headerName,\r\n          description: headerValue,\r\n          kind: models.HttpSymbolKind.requestHeader,\r\n          startLine: httpLine.line,\r\n          startOffset: httpLine.textLine.indexOf(headerName),\r\n          endLine: httpLine.line,\r\n          endOffset: httpLine.textLine.length,\r\n          children: [{\r\n            name: headerName,\r\n            description: 'request header key',\r\n            kind: models.HttpSymbolKind.key,\r\n            startLine: httpLine.line,\r\n            startOffset: httpLine.textLine.indexOf(headerName),\r\n            endLine: httpLine.line,\r\n            endOffset: httpLine.textLine.indexOf(headerName) + headerName.length,\r\n          }, {\r\n            name: headerValue,\r\n            description: 'request header value',\r\n            kind: models.HttpSymbolKind.value,\r\n            startLine: httpLine.line,\r\n            startOffset: httpLine.textLine.indexOf(headerValue),\r\n            endLine: httpLine.line,\r\n            endOffset: httpLine.textLine.indexOf(headerValue) + headerValue.length,\r\n          }\r\n          ]\r\n        }]\r\n      };\r\n    }\r\n    return false;\r\n  };\r\n}\r\n\r\n\r\nexport function parseDefaultHeadersFactory(\r\n  setHeaders: (headers: Record<string, unknown>, context: models.ProcessorContext) => void\r\n): ParseLineMethod {\r\n  return function parseDefaultHeaders(httpLine: models.HttpLine, parserContext: models.ParserContext): models.SymbolParserResult | false {\r\n    const fileHeaders = ParserRegex.request.headersSpread.exec(httpLine.textLine);\r\n    if (fileHeaders?.groups?.variableName) {\r\n      parserContext.httpRegion.hooks.execute.addObjHook(obj => obj.process, new actions.DefaultHeadersAction(fileHeaders.groups.variableName, setHeaders));\r\n      const val = httpLine.textLine.trim();\r\n      return {\r\n        symbols: [{\r\n          name: val,\r\n          description: 'header variable',\r\n          kind: models.HttpSymbolKind.requestHeader,\r\n          startLine: httpLine.line,\r\n          startOffset: httpLine.textLine.indexOf(val),\r\n          endOffset: httpLine.textLine.length,\r\n          endLine: httpLine.line,\r\n        }],\r\n      };\r\n    }\r\n    return false;\r\n  };\r\n}\r\n\r\n\r\nexport function parseUrlLineFactory(attachUrl: ((url: string) => void)) : ParseLineMethod {\r\n  return function parseUrlLine(httpLine: models.HttpLine) {\r\n    if (ParserRegex.request.urlLine.test(httpLine.textLine)) {\r\n      const val = httpLine.textLine.trim();\r\n      attachUrl(val);\r\n      return {\r\n        symbols: [{\r\n          name: val,\r\n          description: 'urlpart',\r\n          kind: models.HttpSymbolKind.url,\r\n          startLine: httpLine.line,\r\n          startOffset: httpLine.textLine.indexOf(val),\r\n          endOffset: httpLine.textLine.length,\r\n          endLine: httpLine.line,\r\n        }]\r\n      };\r\n    }\r\n    return false;\r\n  };\r\n}\r\n\r\nexport function parseQueryLineFactory(attachUrl: ((url: string) => void)): ParseLineMethod {\r\n  return function parseQueryLine(httpLine: models.HttpLine): models.SymbolParserResult | false {\r\n    if (ParserRegex.request.queryLine.test(httpLine.textLine)) {\r\n      const val = httpLine.textLine.trim();\r\n      attachUrl(val);\r\n      return {\r\n        symbols: [{\r\n          name: val,\r\n          description: 'query',\r\n          kind: models.HttpSymbolKind.url,\r\n          startLine: httpLine.line,\r\n          startOffset: httpLine.textLine.indexOf(val),\r\n          endOffset: httpLine.textLine.length,\r\n          endLine: httpLine.line,\r\n        }]\r\n      };\r\n    }\r\n    return false;\r\n  };\r\n}\r\n\r\n\r\nexport function parseComments(httpLine: models.HttpLine, context: models.ParserContext): models.SymbolParserResult | false {\r\n  return parseMetaComments(httpLine, context, ParserRegex.meta.comment);\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport * as actions from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as parserUtils from './parserUtils';\r\n\r\nexport async function parseEventSource(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done && isValidEventSource(next.value.textLine)) {\r\n    if (context.httpRegion.request) {\r\n      return {\r\n        endRegionLine: next.value.line - 1,\r\n        nextParserLine: next.value.line - 1,\r\n        symbols: [],\r\n      };\r\n    }\r\n\r\n\r\n    const eventSourceLine = getEventSourceLine(next.value.textLine, next.value.line);\r\n    if (!eventSourceLine) {\r\n      return false;\r\n    }\r\n    context.httpRegion.request = eventSourceLine.request;\r\n    const requestSymbol: models.HttpSymbol = {\r\n      name: next.value.textLine,\r\n      description: 'websocket request-line',\r\n      kind: models.HttpSymbolKind.requestLine,\r\n      startLine: next.value.line,\r\n      startOffset: 0,\r\n      endLine: next.value.line,\r\n      endOffset: next.value.textLine.length,\r\n      children: [eventSourceLine.symbol],\r\n    };\r\n\r\n    const result: models.HttpRegionParserResult = {\r\n      nextParserLine: next.value.line,\r\n      symbols: [requestSymbol],\r\n    };\r\n\r\n\r\n    const headers = {};\r\n    eventSourceLine.request.headers = headers;\r\n\r\n    const headersResult = parserUtils.parseSubsequentLines(lineReader, [\r\n      parserUtils.parseComments,\r\n      parserUtils.parseRequestHeaderFactory(headers),\r\n      parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\r\n      parserUtils.parseUrlLineFactory(url => (eventSourceLine.request.url += url)),\r\n    ], context);\r\n\r\n    if (headersResult) {\r\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\r\n      for (const parseResult of headersResult.parseResults) {\r\n        result.symbols?.push?.(...parseResult.symbols);\r\n      }\r\n    }\r\n\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process,\r\n      new actions.EventSourceClientAction());\r\n\r\n    context.httpRegion.hooks.execute.addInterceptor(new actions.CreateRequestInterceptor());\r\n\r\n    return result;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction getEventSourceLine(textLine: string, line: number): { request: models.EventSourceRequest, symbol: models.HttpSymbol } | undefined {\r\n  const lineMatch = ParserRegex.stream.eventSourceLine.exec(textLine);\r\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: lineMatch.groups.url,\r\n        method: 'SSE'\r\n      },\r\n      symbol: {\r\n        name: lineMatch.groups.url,\r\n        description: 'EventSource url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nfunction isValidEventSource(textLine: string) {\r\n  if (utils.isStringEmpty(textLine)) {\r\n    return false;\r\n  }\r\n\r\n  if (ParserRegex.stream.eventSourceLine.exec(textLine)?.groups?.url) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { GqlAction, GqlData } from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\nimport { fileProvider } from '../io';\r\n\r\n\r\nexport async function parseGraphql(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n\r\n  if (context.httpRegion.metaData.noGqlParsing) {\r\n    return false;\r\n  }\r\n\r\n  const gqlContent = await getGQLContent(lineReader);\r\n  if (gqlContent) {\r\n    const gqlData: GqlData = {\r\n      fragments: getGqlFragments(context),\r\n    };\r\n\r\n    if (context.httpRegion.request) {\r\n      gqlData.query = gqlContent.gql;\r\n      if (gqlContent.name) {\r\n        gqlData.operationName = gqlContent.name;\r\n        if (!context.httpRegion.metaData.name) {\r\n          context.httpRegion.metaData.name = gqlContent.name;\r\n        }\r\n      }\r\n      context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new GqlAction(gqlData));\r\n    } else if (gqlContent.name) {\r\n      gqlData.fragments[gqlContent.name] = gqlContent.gql;\r\n    }\r\n    return {\r\n      nextParserLine: gqlContent.endLine,\r\n      symbols: [{\r\n        name: 'gql',\r\n        description: 'gql',\r\n        kind: models.HttpSymbolKind.gql,\r\n        startLine: gqlContent.startLine,\r\n        startOffset: 0,\r\n        endLine: gqlContent.endLine,\r\n        endOffset: gqlContent.endOffset,\r\n      }]\r\n    };\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getGqlFragments(context: models.ParserContext) {\r\n  let result = context.data.gql;\r\n  if (!result) {\r\n    result = {};\r\n    context.data.gql = result;\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\nasync function getGQLContent(lineReader: models.HttpLineGenerator): Promise<GqlParserResult | false> {\r\n  const next = lineReader.next();\r\n  if (!next.done) {\r\n\r\n    const startLine = next.value.line;\r\n\r\n    const fileMatches = ParserRegex.gql.fileImport.exec(next.value.textLine);\r\n    if (fileMatches && fileMatches.groups?.fileName) {\r\n\r\n      const parserPath = fileMatches.groups.fileName;\r\n      return {\r\n        startLine,\r\n        endLine: startLine,\r\n        endOffset: next.value.textLine.length,\r\n        name: fileMatches.groups.name || fileMatches.groups.fileName,\r\n        gql: (context: models.ProcessorContext) => utils.replaceFilePath(\r\n          parserPath,\r\n          context,\r\n          (path: models.PathLike) => fileProvider.readFile(path, 'utf-8')\r\n        )\r\n      };\r\n    }\r\n    const queryMatch = ParserRegex.gql.query.exec(next.value.textLine);\r\n    if (queryMatch) {\r\n      return matchGqlContent(next.value, lineReader, queryMatch.groups?.name);\r\n    }\r\n    const fragmentMatch = ParserRegex.gql.fragment.exec(next.value.textLine);\r\n    if (fragmentMatch) {\r\n      return matchGqlContent(next.value, lineReader, fragmentMatch.groups?.name);\r\n    }\r\n\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction matchGqlContent(value: { textLine: string; line: number }, lineReader: models.HttpLineGenerator, name: string | undefined): GqlParserResult | false {\r\n  const startLine = value.line;\r\n  let next = lineReader.next();\r\n  const gqlLines: Array<string> = [value.textLine];\r\n  while (!next.done) {\r\n    if (ParserRegex.emptyLine.test(next.value.textLine)) {\r\n      return {\r\n        name,\r\n        startLine,\r\n        endLine: next.value.line,\r\n        endOffset: next.value.textLine.length,\r\n        gql: utils.toMultiLineString(gqlLines),\r\n      };\r\n    }\r\n    gqlLines.push(next.value.textLine);\r\n    next = lineReader.next();\r\n  }\r\n  return false;\r\n}\r\n\r\nexport interface GqlParserResult{\r\n  name?: string,\r\n  startLine: number,\r\n  endLine: number,\r\n  endOffset: number;\r\n  gql: string | ((context: models.ProcessorContext) => Promise<string | undefined>);\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { ParserRegex } from './parserRegex';\r\nimport { HttpFileStore } from '../store';\r\n\r\nexport async function parseHttpFile(httpFile: models.HttpFile, text: string, httpFileStore: HttpFileStore): Promise<models.HttpFile> {\r\n\r\n  const lines = utils.toMultiLineArray(text);\r\n\r\n  const parserContext: models.ParserContext = {\r\n    lines,\r\n    httpFile,\r\n    httpRegion: initHttpRegion(0),\r\n    data: {},\r\n    httpFileStore,\r\n  };\r\n\r\n  for (let line = 0; line < lines.length; line++) {\r\n\r\n    const httpRegionParserResult = await httpFile.hooks.parse.trigger(createReaderFactory(line, lines), parserContext);\r\n    if (httpRegionParserResult && httpRegionParserResult !== models.HookCancel) {\r\n      if (httpRegionParserResult.endRegionLine !== undefined && httpRegionParserResult.endRegionLine >= 0) {\r\n        parserContext.httpRegion.symbol.endLine = httpRegionParserResult.endRegionLine;\r\n        parserContext.httpRegion.symbol.endOffset = lines[httpRegionParserResult.endRegionLine].length;\r\n        await closeHttpRegion(parserContext);\r\n        parserContext.httpRegion = initHttpRegion(httpRegionParserResult.nextParserLine + 1);\r\n      }\r\n      if (httpRegionParserResult.symbols) {\r\n        if (parserContext.httpRegion.symbol.children) {\r\n          parserContext.httpRegion.symbol.children.push(...httpRegionParserResult.symbols);\r\n        } else {\r\n          parserContext.httpRegion.symbol.children = httpRegionParserResult.symbols;\r\n        }\r\n      }\r\n      line = httpRegionParserResult.nextParserLine;\r\n    }\r\n  }\r\n\r\n\r\n  await closeHttpRegion(parserContext);\r\n  parserContext.httpRegion.symbol.endLine = lines.length - 1;\r\n  parserContext.httpRegion.symbol.endOffset = lines[lines.length - 1].length;\r\n  setSource(httpFile.httpRegions, lines);\r\n  return httpFile;\r\n}\r\n\r\nasync function closeHttpRegion(parserContext: models.ParserContext) : Promise<void> {\r\n  await parserContext.httpFile.hooks.parseEndRegion.trigger(parserContext);\r\n\r\n  const { httpRegion } = parserContext;\r\n  parserContext.httpRegion.symbol.name = utils.getDisplayName(httpRegion);\r\n  parserContext.httpRegion.symbol.description = utils.getRegionDescription(httpRegion);\r\n  parserContext.httpFile.httpRegions.push(parserContext.httpRegion);\r\n}\r\n\r\nfunction setSource(httpRegions: Array<models.HttpRegion>, lines: Array<string>) {\r\n  for (const httpRegion of httpRegions) {\r\n    setSymbolSource(httpRegion.symbol, lines);\r\n  }\r\n}\r\n\r\nfunction setSymbolSource(symbol: models.HttpSymbol, lines: Array<string>): void {\r\n  symbol.source = utils.toMultiLineString(lines.slice(symbol.startLine, symbol.endLine + 1));\r\n  let endOffset: number | undefined = symbol.endOffset - lines[symbol.endLine].length;\r\n  if (endOffset >= 0) {\r\n    endOffset = undefined;\r\n  }\r\n  symbol.source = symbol.source.slice(symbol.startOffset, endOffset);\r\n  if (symbol.children) {\r\n    for (const child of symbol.children) {\r\n      setSymbolSource(child, lines);\r\n    }\r\n  }\r\n}\r\n\r\nfunction initHttpRegion(start: number): models.HttpRegion {\r\n  return {\r\n    metaData: {},\r\n    symbol: {\r\n      name: '-',\r\n      description: '-',\r\n      kind: models.HttpSymbolKind.request,\r\n      startLine: start,\r\n      startOffset: 0,\r\n      endLine: start,\r\n      endOffset: 0,\r\n    },\r\n    hooks: {\r\n      execute: new models.ExecuteHook(),\r\n      onRequest: new models.OnRequestHook(),\r\n      onStreaming: new models.OnStreaming(),\r\n      onResponse: new models.OnResponseHook(),\r\n    },\r\n    variablesPerEnv: {}\r\n  };\r\n}\r\n\r\nfunction createReaderFactory(startLine: number, lines: Array<string>) {\r\n  return function *createReader(noStopOnMetaTag?: boolean) {\r\n    for (let line = startLine; line < lines.length; line++) {\r\n      const textLine = lines[line];\r\n      yield {\r\n        textLine,\r\n        line\r\n      };\r\n      if (!noStopOnMetaTag) {\r\n        // if parser region is not closed stop at delimiter\r\n        if (ParserRegex.meta.delimiter.test(textLine)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n", "import * as models from '../models';\r\nimport { toMultiLineString } from '../utils';\r\nimport { IntellijScriptData, IntellijAction } from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\n\r\n\r\nexport interface IntelliJParserResult {\r\n  startLine: number,\r\n  endLine: number,\r\n  endOffset: number;\r\n  data: models.ScriptData | IntellijScriptData;\r\n}\r\n\r\n\r\nexport async function parseIntellijScript(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  { httpRegion }: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  if (httpRegion.request) {\r\n\r\n    const intellijContent = getIntellijContent(lineReader);\r\n\r\n    if (intellijContent) {\r\n      httpRegion.hooks.execute.addObjHook(obj => obj.process, new IntellijAction(intellijContent.data));\r\n      return {\r\n        nextParserLine: intellijContent.endLine,\r\n        symbols: [{\r\n          name: 'Intellij Script',\r\n          description: 'Intellij Script',\r\n          kind: models.HttpSymbolKind.script,\r\n          startLine: intellijContent.startLine,\r\n          startOffset: 0,\r\n          endLine: intellijContent.endLine,\r\n          endOffset: intellijContent.endOffset,\r\n        }],\r\n      };\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction getIntellijContent(lineReader: models.HttpLineGenerator): IntelliJParserResult | false {\r\n  let next = lineReader.next();\r\n  if (!next.done) {\r\n\r\n    const startLine = next.value.line;\r\n\r\n    const fileMatches = ParserRegex.intellij.import.exec(next.value.textLine);\r\n    if (fileMatches?.groups?.fileName) {\r\n      return {\r\n        startLine,\r\n        endLine: startLine,\r\n        endOffset: next.value.textLine.length,\r\n        data: {\r\n          fileName: fileMatches.groups.fileName\r\n        }\r\n      };\r\n    }\r\n\r\n    const singleLineMatch = ParserRegex.intellij.scriptSingleLine.exec(next.value.textLine);\r\n    if (singleLineMatch?.groups?.script) {\r\n      return {\r\n        startLine,\r\n        endLine: startLine,\r\n        endOffset: next.value.textLine.length,\r\n        data: {\r\n          script: singleLineMatch.groups.script,\r\n          lineOffset: startLine,\r\n        }\r\n      };\r\n    }\r\n\r\n    const multiLineMatch = ParserRegex.intellij.scriptStart.exec(next.value.textLine);\r\n    if (multiLineMatch) {\r\n      next = lineReader.next();\r\n      const scriptLines: Array<string> = [];\r\n      while (!next.done) {\r\n        if (ParserRegex.intellij.scriptEnd.test(next.value.textLine)) {\r\n          return {\r\n            startLine,\r\n            endLine: next.value.line,\r\n            endOffset: next.value.textLine.length,\r\n            data: {\r\n              script: toMultiLineString(scriptLines),\r\n              lineOffset: startLine\r\n            }\r\n          };\r\n        }\r\n        scriptLines.push(next.value.textLine);\r\n        next = lineReader.next();\r\n      }\r\n\r\n    }\r\n  }\r\n  return false;\r\n}\r\n", "import { testFactory } from '../actions';\r\nimport * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as httpyac from '..';\r\nimport * as grpc from '@grpc/grpc-js';\r\nimport { default as got } from 'got';\r\nimport { default as chalk } from 'chalk';\r\n\r\nexport interface ScriptData {\r\n  script: string;\r\n  lineOffset: number;\r\n}\r\n\r\nexport async function parseJavascript(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  { httpRegion, data }: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  let next = lineReader.next();\r\n\r\n  if (!next.done) {\r\n    const match = ParserRegex.javascript.scriptStart.exec(next.value.textLine);\r\n    if (match?.groups) {\r\n\r\n\r\n      const lineOffset = next.value.line;\r\n      next = lineReader.next();\r\n      const script: Array<string> = [];\r\n      while (!next.done) {\r\n\r\n        if (ParserRegex.javascript.scriptEnd.test(next.value.textLine)) {\r\n          const scriptData: ScriptData = {\r\n            script: utils.toMultiLineString(script),\r\n            lineOffset,\r\n          };\r\n\r\n          if (!match.groups.modifier || match.groups.modifier === '@') {\r\n            switch (match.groups.event) {\r\n              case 'request':\r\n                httpRegion.hooks.onRequest.addHook(models.ActionType.js, async (_request, context) => {\r\n                  await executeScriptData(scriptData, context, 'request');\r\n                });\r\n                break;\r\n              case 'streaming':\r\n                httpRegion.hooks.onStreaming.addHook(models.ActionType.js, async context => {\r\n                  await executeScriptData(scriptData, context, 'streaming');\r\n                });\r\n                break;\r\n              case 'response':\r\n                httpRegion.hooks.onResponse.addHook(models.ActionType.js, async (_response, context) => {\r\n                  await executeScriptData(scriptData, context, 'response');\r\n                });\r\n                break;\r\n              case 'after':\r\n                httpRegion.hooks.execute.addInterceptor(new AfterJavascriptHookInterceptor(scriptData));\r\n                break;\r\n              default:\r\n                httpRegion.hooks.execute.addHook(models.ActionType.js, context => executeScriptData(scriptData, context));\r\n                break;\r\n            }\r\n          } else if (match.groups.modifier === '+') {\r\n            let onEveryRequestArray = data.jsOnEveryRequest;\r\n            if (!onEveryRequestArray) {\r\n              data.jsOnEveryRequest = onEveryRequestArray = [];\r\n            }\r\n            onEveryRequestArray.push({\r\n              scriptData,\r\n              event: match.groups.event\r\n            });\r\n          }\r\n\r\n          return {\r\n            nextParserLine: next.value.line,\r\n            symbols: [{\r\n              name: 'script',\r\n              description: 'nodejs script',\r\n              kind: models.HttpSymbolKind.script,\r\n              startLine: lineOffset,\r\n              startOffset: 0,\r\n              endLine: next.value.line,\r\n              endOffset: next.value.textLine.length,\r\n            }]\r\n          };\r\n        }\r\n        script.push(next.value.textLine);\r\n        next = lineReader.next();\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport async function injectOnEveryRequestJavascript({ data, httpRegion }: models.ParserContext): Promise<void> {\r\n  const onEveryRequestArray = data.jsOnEveryRequest;\r\n  if (onEveryRequestArray && httpRegion.request) {\r\n    for (const everyRequestScript of onEveryRequestArray) {\r\n      const scriptData = everyRequestScript.scriptData;\r\n      switch (everyRequestScript.event) {\r\n        case 'streaming':\r\n          httpRegion.hooks.onStreaming.addHook(models.ActionType.js, async context => {\r\n            await executeScriptData(scriptData, context, 'streaming');\r\n          });\r\n          break;\r\n        case 'response':\r\n\r\n          httpRegion.hooks.onResponse.addHook(models.ActionType.js, async (_response, context) => {\r\n            await executeScriptData(scriptData, context, 'response');\r\n          });\r\n          break;\r\n        case 'after':\r\n          httpRegion.hooks.execute.addHook(models.ActionType.js, async context => {\r\n            await executeScriptData(scriptData, context, 'after');\r\n          });\r\n          break;\r\n        case 'request':\r\n          httpRegion.hooks.onRequest.addHook(models.ActionType.js, async (_request, context) => {\r\n            await executeScriptData(scriptData, context, 'request');\r\n          });\r\n          break;\r\n        default:\r\n          httpRegion.hooks.execute.addInterceptor(new BeforeJavascriptHookInterceptor(everyRequestScript.scriptData));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class BeforeJavascriptHookInterceptor implements models.HookInterceptor<models.ProcessorContext, boolean> {\r\n  constructor(private readonly scriptData: ScriptData) { }\r\n  async beforeTrigger(context: models.HookTriggerContext<models.ProcessorContext, boolean | undefined>): Promise<boolean | undefined> {\r\n    return await executeScriptData(this.scriptData, context.arg, 'before');\r\n  }\r\n}\r\nexport class AfterJavascriptHookInterceptor implements models.HookInterceptor<models.ProcessorContext, boolean> {\r\n  constructor(private readonly scriptData: ScriptData) { }\r\n  async afterTrigger(context: models.HookTriggerContext<models.ProcessorContext, boolean | undefined>): Promise<boolean | undefined> {\r\n    return await executeScriptData(this.scriptData, context.arg, 'after');\r\n  }\r\n}\r\nasync function executeScriptData(scriptData: ScriptData, context: models.ProcessorContext, eventName?: string) {\r\n  utils.report(context, eventName ? `execute javascript (@${eventName})` : 'execute javascript');\r\n  const result = await utils.runScript(scriptData.script, {\r\n    fileName: context.httpFile.fileName,\r\n    context: {\r\n      request: context.request,\r\n      sleep: utils.sleep,\r\n      test: testFactory(context),\r\n      httpFile: context.httpFile,\r\n      httpRegion: context.httpRegion,\r\n      console: context.scriptConsole,\r\n      ...context.variables,\r\n    },\r\n    lineOffset: scriptData.lineOffset,\r\n    require: {\r\n      httpyac,\r\n      chalk,\r\n      got,\r\n      '@grpc/grpc-js': grpc,\r\n      ...context.require,\r\n    }\r\n  });\r\n  if (result) {\r\n    utils.setVariableInContext(result, context);\r\n  }\r\n  return !result.$cancel;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport { CreateRequestBodyInterceptor } from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\n\r\n\r\nexport async function parseRequestBody(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n\r\n  if (context.httpRegion.request) {\r\n    const requestBody = getRequestBody(context);\r\n    const next = lineReader.next();\r\n    if (!next.done) {\r\n\r\n\r\n      if (requestBody.rawBody.length > 0 || !utils.isStringEmpty(next.value.textLine)) {\r\n\r\n        requestBody.rawBody.push(parseLine(next.value.textLine));\r\n        const symbols: Array<models.HttpSymbol> = [];\r\n\r\n\r\n        if (!requestBody.symbol || requestBody.symbol.endLine !== next.value.line - 1) {\r\n          requestBody.symbol = {\r\n            name: 'request body',\r\n            description: 'request body',\r\n            kind: models.HttpSymbolKind.requestBody,\r\n            startLine: next.value.line,\r\n            startOffset: 0,\r\n            endLine: next.value.line,\r\n            endOffset: next.value.textLine.length,\r\n          };\r\n          symbols.push(requestBody.symbol);\r\n        } else {\r\n          requestBody.symbol.endLine = next.value.line;\r\n          requestBody.symbol.endOffset = next.value.textLine.length;\r\n        }\r\n\r\n        return {\r\n          nextParserLine: next.value.line,\r\n          symbols,\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getRequestBody(context: models.ParserContext) {\r\n  let result = context.data.request_body;\r\n  if (!result) {\r\n    result = {\r\n      rawBody: [],\r\n    };\r\n    context.data.request_body = result;\r\n  }\r\n  return result;\r\n}\r\nfunction getAndRemoveRequestBody(context: models.ParserContext) {\r\n  const result = context.data.request_body;\r\n  if (result) {\r\n    delete context.data.request_body;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction parseLine(textLine: string) {\r\n  const fileImport = ParserRegex.request.fileImport.exec(textLine);\r\n  if (fileImport && fileImport.length === 4 && fileImport.groups) {\r\n    return {\r\n      fileName: fileImport.groups.fileName,\r\n      injectVariables: !!fileImport.groups.injectVariables,\r\n      encoding: getBufferEncoding(fileImport.groups.encoding),\r\n    };\r\n  }\r\n  return textLine;\r\n}\r\n\r\nfunction isBufferEncoding(encoding: string): encoding is BufferEncoding {\r\n  return ['ascii', 'utf8', 'utf-8',\r\n    'utf16le', 'ucs2', 'ucs-2',\r\n    'base64', 'latin1', 'binary', 'hex']\r\n    .indexOf(encoding) >= 0;\r\n}\r\n\r\nfunction getBufferEncoding(encoding: string) : BufferEncoding {\r\n  if (encoding && isBufferEncoding(encoding)) {\r\n    return encoding;\r\n  }\r\n  return 'utf8';\r\n}\r\n\r\nexport async function closeRequestBody(context: models.ParserContext): Promise<void> {\r\n  const requestBody = getAndRemoveRequestBody(context);\r\n  if (context.httpRegion.request && !!requestBody) {\r\n    removeTrailingEmptyLines(requestBody.rawBody);\r\n    context.httpRegion.hooks.execute.addInterceptor(new CreateRequestBodyInterceptor(requestBody.rawBody));\r\n  }\r\n}\r\n\r\nfunction removeTrailingEmptyLines(obj: Array<unknown>) : void {\r\n  while (obj.length > 0 && utils.isStringEmpty(obj[obj.length - 1])) {\r\n    obj.pop();\r\n  }\r\n  if (obj.length > 0) {\r\n    const lastLine = obj[obj.length - 1];\r\n    if (utils.isString(lastLine)) {\r\n      if (/\\s*<--->\\s*/u.test(lastLine)) {\r\n        obj.pop();\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport * as actions from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as parserUtils from './parserUtils';\r\n\r\nexport async function parseRequestLine(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done && isValidRequestLine(next.value.textLine, context.httpRegion)) {\r\n    if (context.httpRegion.request) {\r\n      return {\r\n        endRegionLine: next.value.line - 1,\r\n        nextParserLine: next.value.line - 1,\r\n        symbols: [],\r\n      };\r\n    }\r\n\r\n    const requestSymbol: models.HttpSymbol = {\r\n      name: next.value.textLine,\r\n      description: 'http request-line',\r\n      kind: models.HttpSymbolKind.requestLine,\r\n      startLine: next.value.line,\r\n      startOffset: 0,\r\n      endLine: next.value.line,\r\n      endOffset: next.value.textLine.length,\r\n    };\r\n    const symbols = [requestSymbol];\r\n\r\n    const { request, requestSymbols } = getRequestLine(next.value.textLine, next.value.line);\r\n    context.httpRegion.request = request;\r\n    requestSymbol.children = requestSymbols;\r\n\r\n    const result: models.HttpRegionParserResult = {\r\n      nextParserLine: next.value.line,\r\n      symbols\r\n    };\r\n\r\n\r\n    const headers = {};\r\n    request.headers = headers;\r\n\r\n    const headersResult = parserUtils.parseSubsequentLines(lineReader, [\r\n      parserUtils.parseComments,\r\n      parserUtils.parseRequestHeaderFactory(headers),\r\n      parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\r\n      parserUtils.parseQueryLineFactory(url => (request.url += url)),\r\n      parserUtils.parseUrlLineFactory(url => (request.url += url)),\r\n    ], context);\r\n\r\n    if (headersResult) {\r\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\r\n      for (const parseResult of headersResult.parseResults) {\r\n        symbols.push(...parseResult.symbols);\r\n      }\r\n    }\r\n\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process,\r\n      new actions.CookieJarAction(),\r\n      new actions.HttpClientAction());\r\n\r\n    context.httpRegion.hooks.execute.addInterceptor(new actions.CreateRequestInterceptor());\r\n\r\n    if (context.httpRegion.request.headers) {\r\n      const contentType = utils.getHeader(context.httpRegion.request.headers, 'content-type');\r\n      if (utils.isString(contentType)) {\r\n        context.httpRegion.request.contentType = utils.parseMimeType(contentType);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction getRequestLine(textLine: string, line: number): { request: models.HttpRequest, requestSymbols: Array<models.HttpSymbol> } {\r\n  const requestSymbols: Array<models.HttpSymbol> = [];\r\n  const requestLineMatch = ParserRegex.request.requestLine.exec(textLine);\r\n  if (requestLineMatch && requestLineMatch.length > 1 && requestLineMatch.groups) {\r\n    requestSymbols.push({\r\n      name: requestLineMatch.groups.method,\r\n      description: 'request method',\r\n      kind: models.HttpSymbolKind.requestHeader,\r\n      startLine: line,\r\n      startOffset: textLine.indexOf(requestLineMatch.groups.method),\r\n      endLine: line,\r\n      endOffset: textLine.indexOf(requestLineMatch.groups.method) + requestLineMatch.groups.method.length,\r\n    }, {\r\n      name: requestLineMatch.groups.url,\r\n      description: 'request url',\r\n      kind: models.HttpSymbolKind.url,\r\n      startLine: line,\r\n      startOffset: textLine.indexOf(requestLineMatch.groups.url),\r\n      endLine: line,\r\n      endOffset: textLine.length,\r\n    });\r\n\r\n    return {\r\n      request: {\r\n        url: requestLineMatch.groups.url,\r\n        method: utils.isHttpRequestMethod(requestLineMatch.groups.method) ? requestLineMatch.groups.method : 'GET',\r\n        http2: requestLineMatch.groups.version ? ['1.1', '1.0'].indexOf(requestLineMatch.groups.version) < 0 : undefined,\r\n      },\r\n      requestSymbols\r\n    };\r\n  }\r\n  requestSymbols.push({\r\n    name: textLine.trim(),\r\n    description: 'request url',\r\n    kind: models.HttpSymbolKind.url,\r\n    startLine: line,\r\n    startOffset: 0,\r\n    endLine: line,\r\n    endOffset: textLine.length,\r\n  });\r\n  return {\r\n    request: {\r\n      url: textLine.trim(),\r\n      method: 'GET',\r\n    },\r\n    requestSymbols\r\n  };\r\n}\r\n\r\n\r\nfunction isValidRequestLine(textLine: string, httpRegion: models.HttpRegion) {\r\n  if (utils.isStringEmpty(textLine)) {\r\n    return false;\r\n  }\r\n  if (httpRegion.request) {\r\n    if (ParserRegex.request.requestLine.exec(textLine)?.groups?.method) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n", "import { getHttpLineGenerator, HttpRegionParserResult, HttpSymbolKind, ParserContext } from '../models';\r\nimport { ParserRegex } from './parserRegex';\r\nimport { toMultiLineString, parseContentType, setAdditionalResponseBody } from '../utils';\r\n\r\n\r\nexport async function parseResponse(getLineReader: getHttpLineGenerator, context: ParserContext): Promise<HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n\r\n  let next = lineReader.next();\r\n  if (!next.done) {\r\n    const responseSymbol = context.data.httpResponseSymbol;\r\n    if (responseSymbol) {\r\n      responseSymbol.body.push(next.value.textLine);\r\n\r\n      responseSymbol.symbol.endLine = next.value.line;\r\n      responseSymbol.symbol.endOffset = next.value.textLine.length;\r\n      return {\r\n        nextParserLine: next.value.line,\r\n        symbols: [],\r\n      };\r\n    }\r\n    const match = ParserRegex.responseLine.exec(next.value.textLine);\r\n    if (match && match.groups?.statusCode) {\r\n\r\n      context.httpRegion.response = {\r\n        protocol: `HTTP/${match.groups.httpVersion || '1.1'}`,\r\n        httpVersion: match.groups.httpVersion,\r\n        statusCode: +match.groups.statusCode,\r\n        statusMessage: match.groups.statusMessage,\r\n        headers: {}\r\n      };\r\n      const symbol = {\r\n        name: 'response',\r\n        description: 'response',\r\n        kind: HttpSymbolKind.response,\r\n        startLine: next.value.line,\r\n        startOffset: 0,\r\n        endLine: next.value.line,\r\n        endOffset: next.value.textLine.length,\r\n      };\r\n\r\n      next = lineReader.next();\r\n      while (!next.done) {\r\n        symbol.endLine = next.value.line;\r\n        symbol.endOffset = next.value.textLine.length;\r\n        const headerMatch = ParserRegex.request.header.exec(next.value.textLine);\r\n        if (headerMatch?.groups?.key && headerMatch?.groups?.value) {\r\n\r\n          context.httpRegion.response.headers = Object.assign(context.httpRegion.response?.headers, { [headerMatch.groups.key]: headerMatch.groups.value });\r\n        } else {\r\n          break;\r\n        }\r\n        next = lineReader.next();\r\n      }\r\n\r\n      context.data.httpResponseSymbol = {\r\n        symbol,\r\n        body: [],\r\n      };\r\n\r\n      return {\r\n        nextParserLine: symbol.endLine,\r\n        symbols: [symbol],\r\n      };\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport async function closeResponseBody(context: ParserContext): Promise<void> {\r\n  if (context.data.httpResponseSymbol) {\r\n    if (context.httpRegion.response\r\n        && context.data.httpResponseSymbol.body.length > 0) {\r\n      const response = context.httpRegion.response;\r\n      const body = toMultiLineString(context.data.httpResponseSymbol.body);\r\n      response.body = body;\r\n      response.rawBody = Buffer.from(body);\r\n      if (response.headers) {\r\n        response.contentType = parseContentType(response.headers);\r\n      }\r\n      setAdditionalResponseBody(response);\r\n    }\r\n\r\n    delete context.data.httpResponseSymbol;\r\n  }\r\n}\r\n", "import { HttpSymbolKind, getHttpLineGenerator, HttpRegionParserResult, ParserContext } from '../models';\r\nimport { ParserRegex } from './parserRegex';\r\n\r\nexport async function parseResponseRef(getLineReader: getHttpLineGenerator, { httpRegion }: ParserContext): Promise<HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n\r\n  const next = lineReader.next();\r\n  if (!next.done) {\r\n    const textLine = next.value.textLine;\r\n\r\n    const match = ParserRegex.responseRef.exec(textLine);\r\n    if (match && match.groups?.fileName) {\r\n      if (!httpRegion.responseRefs) {\r\n        httpRegion.responseRefs = [];\r\n      }\r\n\r\n      httpRegion.responseRefs.push(match.groups.fileName);\r\n      return {\r\n        nextParserLine: next.value.line,\r\n        symbols: [{\r\n          name: match.groups.key,\r\n          description: match.groups.value,\r\n          kind: HttpSymbolKind.response,\r\n          startLine: next.value.line,\r\n          startOffset: 0,\r\n          endLine: next.value.line,\r\n          endOffset: next.value.textLine.length,\r\n        }],\r\n      };\r\n    }\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../models';\r\nimport { ParserRegex } from './parserRegex';\r\nimport { fileProvider, log } from '../io';\r\n\r\n\r\nexport async function parseOutputRedirection(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  { httpRegion }: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n\r\n  const next = lineReader.next();\r\n  if (!next.done) {\r\n    const textLine = next.value.textLine;\r\n\r\n    const match = ParserRegex.outputRedirection.exec(textLine);\r\n    if (match && match.groups?.fileName) {\r\n\r\n      const fileName = match.groups.fileName;\r\n      const force = !!match.groups.force;\r\n\r\n\r\n      httpRegion.hooks.onResponse.addHook('outputRedirection', async (response, context) => {\r\n        try {\r\n          if (response.rawBody) {\r\n            const file = await getOutputRedirectionFileName(fileName, force, context.httpFile.fileName);\r\n            if (file) {\r\n              await fileProvider.writeBuffer(file, response.rawBody);\r\n            } else {\r\n              log.debug(`file ${fileName} not found`);\r\n            }\r\n          }\r\n        } catch (err) {\r\n          log.error(`outputredirection failed for ${fileName}`, err);\r\n        }\r\n        return response;\r\n      });\r\n      return {\r\n        nextParserLine: next.value.line,\r\n        symbols: [{\r\n          name: match.groups.key,\r\n          description: match.groups.value,\r\n          kind: models.HttpSymbolKind.response,\r\n          startLine: next.value.line,\r\n          startOffset: 0,\r\n          endLine: next.value.line,\r\n          endOffset: next.value.textLine.length,\r\n        }],\r\n      };\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nasync function getOutputRedirectionFileName(fileName: string, force: boolean, baseName: models.PathLike) {\r\n  let file = await toAbsoluteFileName(fileName, baseName);\r\n\r\n  if (!force) {\r\n    if (await fileProvider.exists(file)) {\r\n      const dotIndex = fileName.lastIndexOf('.');\r\n      if (dotIndex > 0 && dotIndex < fileName.length - 2) {\r\n        const path = fileName.slice(0, dotIndex);\r\n        const extension = fileName.slice(dotIndex + 1);\r\n        let index = 1;\r\n\r\n        file = await toAbsoluteFileName(`${path}-${index}.${extension}`, baseName);\r\n        while (await fileProvider.exists(file)) {\r\n          file = await toAbsoluteFileName(`${path}-${index++}.${extension}`, baseName);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return file;\r\n}\r\nasync function toAbsoluteFileName(fileName: string, baseName: models.PathLike) {\r\n  if (!await fileProvider.isAbsolute(fileName)) {\r\n    const dirName = fileProvider.dirname(baseName);\r\n    if (dirName) {\r\n      return fileProvider.joinPath(dirName, fileName);\r\n    }\r\n  }\r\n  return fileName;\r\n}\r\n", "import * as models from '../models';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as utils from '../utils';\r\nimport { log, userInteractionProvider } from '../io';\r\n\r\nconst VariableHookId = 'variable';\r\n\r\nexport async function parseVariable(getLineReader: models.getHttpLineGenerator, { httpRegion }: models.ParserContext): Promise<models.HttpRegionParserResult> {\r\n\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done) {\r\n    const textLine = next.value.textLine;\r\n\r\n    const match = ParserRegex.variable.exec(textLine);\r\n\r\n    if (match && match.groups && match.groups.key && match.groups.value) {\r\n      const key = match.groups.key;\r\n      const value = match.groups.value;\r\n      if (!httpRegion.hooks.execute.hasHook(VariableHookId)) {\r\n        httpRegion.hooks.execute.addInterceptor(new VariableInterceptor());\r\n      }\r\n      httpRegion.hooks.execute.addHook(VariableHookId, context => {\r\n        context.options.replaceVariables = true;\r\n        if (utils.isValidVariableName(key)) {\r\n          utils.setVariableInContext({\r\n            [key]: value\r\n          }, context);\r\n        } else {\r\n          const message = `Javascript Keyword ${key} not allowed as variable`;\r\n          userInteractionProvider.showWarnMessage?.(message);\r\n          log.warn(message);\r\n        }\r\n        return true;\r\n      });\r\n\r\n      return {\r\n        nextParserLine: next.value.line,\r\n        symbols: [{\r\n          name: match.groups.key,\r\n          description: match.groups.value,\r\n          kind: models.HttpSymbolKind.variable,\r\n          startLine: next.value.line,\r\n          startOffset: 0,\r\n          endLine: next.value.line,\r\n          endOffset: next.value.textLine.length,\r\n          children: [{\r\n            name: match.groups.key,\r\n            description: 'key',\r\n            kind: models.HttpSymbolKind.key,\r\n            startLine: next.value.line,\r\n            startOffset: next.value.textLine.indexOf(match.groups.key),\r\n            endLine: next.value.line,\r\n            endOffset: next.value.textLine.indexOf(match.groups.key) + match.groups.key.length,\r\n          }, {\r\n            name: match.groups.value,\r\n            description: 'value',\r\n            kind: models.HttpSymbolKind.value,\r\n            startLine: next.value.line,\r\n            startOffset: next.value.textLine.indexOf(match.groups.value),\r\n            endLine: next.value.line,\r\n            endOffset: next.value.textLine.indexOf(match.groups.value) + match.groups.value.length,\r\n          }]\r\n        }],\r\n      };\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nclass VariableInterceptor implements models.HookInterceptor<models.ProcessorContext, boolean> {\r\n  id = models.ActionType.variable;\r\n\r\n  async beforeTrigger(context: models.HookTriggerContext<models.ProcessorContext, true>) {\r\n    if (context.hookItem?.id !== VariableHookId) {\r\n      if (context.arg.options.replaceVariables) {\r\n        await this.replaceAllVariables(context.arg);\r\n        delete context.arg.options.replaceVariables;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private async replaceAllVariables(context: models.ProcessorContext) : Promise<boolean> {\r\n    for (const [key, value] of Object.entries(context.variables)) {\r\n      const result: typeof models.HookCancel | unknown = await utils.replaceVariables(value, models.VariableType.variable, context);\r\n      if (result !== models.HookCancel) {\r\n        context.variables[key] = result;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as parserUtils from './parserUtils';\r\nimport { load } from '@grpc/proto-loader';\r\nimport * as utils from '../utils';\r\nimport { fileProvider, log, userInteractionProvider } from '../io';\r\nimport { loadPackageDefinition } from '@grpc/grpc-js';\r\n\r\n\r\nexport interface ProtoProcessorContext extends models.ProcessorContext{\r\n  options: {\r\n    protoDefinitions?: Record<string, models.ProtoDefinition>\r\n  }\r\n}\r\n\r\n\r\nexport async function parseProtoImport(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done) {\r\n\r\n    const matchProto = ParserRegex.grpc.proto.exec(next.value.textLine);\r\n\r\n    if (matchProto?.groups?.fileName) {\r\n      const protoDefinition = new models.ProtoDefinition(matchProto.groups.fileName);\r\n\r\n      const protoSymbol: models.HttpSymbol = {\r\n        name: next.value.textLine,\r\n        description: 'proto import',\r\n        kind: models.HttpSymbolKind.proto,\r\n        startLine: next.value.line,\r\n        startOffset: 0,\r\n        endLine: next.value.line,\r\n        endOffset: next.value.textLine.length,\r\n      };\r\n      const symbols = [protoSymbol];\r\n\r\n      const result: models.HttpRegionParserResult = {\r\n        nextParserLine: next.value.line,\r\n        symbols\r\n      };\r\n\r\n      const headersResult = parserUtils.parseSubsequentLines(lineReader, [\r\n        parserUtils.parseComments,\r\n        parserUtils.parseRequestHeaderFactory(protoDefinition.loaderOptions),\r\n        parserUtils.parseDefaultHeadersFactory(\r\n          (headers, context: ProtoProcessorContext) => Object.assign(context.options.protoDefinitions?.[protoDefinition.fileName].loaderOptions, headers)\r\n        ),\r\n      ], context);\r\n\r\n      if (headersResult) {\r\n        result.nextParserLine = headersResult.nextLine || result.nextParserLine;\r\n        for (const parseResult of headersResult.parseResults) {\r\n          symbols.push(...parseResult.symbols);\r\n        }\r\n      }\r\n\r\n      context.httpRegion.hooks.execute.addObjHook(obj => obj.process,\r\n        new ProtoImportAction(protoDefinition));\r\n\r\n      context.httpRegion.hooks.execute.addInterceptor(new ProtoDefinitionCreationInterceptor(protoDefinition));\r\n      return result;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport class ProtoImportAction implements models.HttpRegionAction {\r\n  id = models.ActionType.protoImport;\r\n\r\n  constructor(private readonly protoDefinition: models.ProtoDefinition) {}\r\n\r\n  async process(context: ProtoProcessorContext): Promise<boolean> {\r\n    utils.report(context, `import proto ${this.protoDefinition.fileName}`);\r\n    const definition = context.options.protoDefinitions?.[this.protoDefinition.fileName];\r\n    if (definition) {\r\n      const options = await this.convertLoaderOptions(definition.loaderOptions, context);\r\n      definition.packageDefinition = await utils.replaceFilePath(\r\n        this.protoDefinition.fileName,\r\n        context,\r\n        (path: models.PathLike) => load(fileProvider.fsPath(path), options)\r\n      );\r\n      if (definition.packageDefinition) {\r\n        definition.grpcObject = loadPackageDefinition(definition.packageDefinition);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private async convertLoaderOptions(loaderOptions: Record<string, unknown>, context: models.ProcessorContext) {\r\n    const options = { ...loaderOptions };\r\n\r\n    const optionsScript = utils.toMultiLineString(\r\n      Object.entries(options)\r\n        .filter(([, value]) => utils.isString(value))\r\n        .map(([key, value]) => `${key}: ${value},`)\r\n    );\r\n    try {\r\n      Object.assign(options, await utils.evalExpression(`{${optionsScript}}`, context));\r\n    } catch (err) {\r\n      const message = `proto-loader options convert failed: ${optionsScript}`;\r\n      userInteractionProvider.showWarnMessage?.(message);\r\n      log.warn(message, err);\r\n    }\r\n    return options;\r\n  }\r\n}\r\n\r\n\r\nexport class ProtoDefinitionCreationInterceptor implements models.HookInterceptor<models.ProcessorContext, boolean | void> {\r\n  id = models.ActionType.protoCreate;\r\n\r\n  constructor(private readonly protoDefinition: models.ProtoDefinition) { }\r\n\r\n  async beforeLoop(context: models.HookTriggerContext<ProtoProcessorContext, boolean | undefined>): Promise<boolean | undefined> {\r\n    context.arg.options.protoDefinitions = Object.assign({}, context.arg.options.protoDefinitions, {\r\n      [this.protoDefinition.fileName]: {\r\n        fileName: this.protoDefinition.fileName,\r\n        loaderOptions: {\r\n          ...this.protoDefinition.loaderOptions\r\n        }\r\n      }\r\n    });\r\n\r\n    return true;\r\n  }\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport * as actions from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as parserUtils from './parserUtils';\r\n\r\nexport async function parseGrpcLine(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done && isValidGrpc(next.value.textLine, context.httpRegion)) {\r\n    if (context.httpRegion.request) {\r\n      return {\r\n        endRegionLine: next.value.line - 1,\r\n        nextParserLine: next.value.line - 1,\r\n        symbols: [],\r\n      };\r\n    }\r\n\r\n\r\n    const grpcLine = getGrpcLine(next.value.textLine, next.value.line);\r\n    if (!grpcLine) {\r\n      return false;\r\n    }\r\n    context.httpRegion.request = grpcLine.request;\r\n    const requestSymbol: models.HttpSymbol = {\r\n      name: next.value.textLine,\r\n      description: 'grpc request-line',\r\n      kind: models.HttpSymbolKind.requestLine,\r\n      startLine: next.value.line,\r\n      startOffset: 0,\r\n      endLine: next.value.line,\r\n      endOffset: next.value.textLine.length,\r\n      children: [grpcLine.symbol],\r\n    };\r\n\r\n    const result: models.HttpRegionParserResult = {\r\n      nextParserLine: next.value.line,\r\n      symbols: [requestSymbol],\r\n    };\r\n\r\n\r\n    const headers = {};\r\n    grpcLine.request.headers = headers;\r\n\r\n    const headersResult = parserUtils.parseSubsequentLines(lineReader, [\r\n      parserUtils.parseComments,\r\n      parserUtils.parseRequestHeaderFactory(headers),\r\n      parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\r\n      parserUtils.parseUrlLineFactory(url => (grpcLine.request.url += url)),\r\n    ], context);\r\n\r\n    if (headersResult) {\r\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\r\n      for (const parseResult of headersResult.parseResults) {\r\n        result.symbols?.push?.(...parseResult.symbols);\r\n      }\r\n    }\r\n\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process,\r\n      new actions.GrpcClientAction());\r\n\r\n    context.httpRegion.hooks.execute.addInterceptor(new actions.CreateRequestInterceptor());\r\n\r\n    return result;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction getGrpcLine(textLine: string, line: number): { request: models.GrpcRequest, symbol: models.HttpSymbol } | undefined {\r\n  const lineMatch = ParserRegex.grpc.grpcLine.exec(textLine);\r\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: lineMatch.groups.url,\r\n        method: 'GRPC'\r\n      },\r\n      symbol: {\r\n        name: lineMatch.groups.url,\r\n        description: 'grpc url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  const protocolMatch = ParserRegex.grpc.grpcProtocol.exec(textLine);\r\n  if (protocolMatch && protocolMatch.length > 1 && protocolMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: protocolMatch.groups.url,\r\n        method: 'GRPC'\r\n      },\r\n      symbol: {\r\n        name: protocolMatch.groups.url,\r\n        description: 'grpc url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nfunction isValidGrpc(textLine: string, httpRegion: models.HttpRegion) {\r\n  if (utils.isStringEmpty(textLine)) {\r\n    return false;\r\n  }\r\n\r\n  if (ParserRegex.grpc.grpcLine.exec(textLine)?.groups?.url) {\r\n    return true;\r\n  }\r\n  if (!httpRegion.request) {\r\n    return ParserRegex.grpc.grpcProtocol.exec(textLine)?.groups?.url;\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport * as actions from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as parserUtils from './parserUtils';\r\n\r\nexport async function parseWebsocketLine(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done && isValidWebsocket(next.value.textLine, context.httpRegion)) {\r\n    if (context.httpRegion.request) {\r\n      return {\r\n        endRegionLine: next.value.line - 1,\r\n        nextParserLine: next.value.line - 1,\r\n        symbols: [],\r\n      };\r\n    }\r\n\r\n    const requestLine = getWebsocketLine(next.value.textLine, next.value.line);\r\n    if (!requestLine) {\r\n      return false;\r\n    }\r\n    context.httpRegion.request = requestLine.request;\r\n    const requestSymbol: models.HttpSymbol = {\r\n      name: next.value.textLine,\r\n      description: 'WebSocket request-line',\r\n      kind: models.HttpSymbolKind.requestLine,\r\n      startLine: next.value.line,\r\n      startOffset: 0,\r\n      endLine: next.value.line,\r\n      endOffset: next.value.textLine.length,\r\n      children: [requestLine.symbol],\r\n    };\r\n\r\n    const result: models.HttpRegionParserResult = {\r\n      nextParserLine: next.value.line,\r\n      symbols: [requestSymbol],\r\n    };\r\n\r\n\r\n    const headers = {};\r\n    requestLine.request.headers = headers;\r\n\r\n    const headersResult = parserUtils.parseSubsequentLines(lineReader, [\r\n      parserUtils.parseComments,\r\n      parserUtils.parseRequestHeaderFactory(headers),\r\n      parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\r\n      parserUtils.parseUrlLineFactory(url => (requestLine.request.url += url)),\r\n    ], context);\r\n\r\n    if (headersResult) {\r\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\r\n      for (const parseResult of headersResult.parseResults) {\r\n        result.symbols?.push?.(...parseResult.symbols);\r\n      }\r\n    }\r\n\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process,\r\n      new actions.WebSocketClientAction());\r\n\r\n    context.httpRegion.hooks.execute.addInterceptor(new actions.CreateRequestInterceptor());\r\n\r\n    return result;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction getWebsocketLine(textLine: string, line: number): { request: models.WebsocketRequest, symbol: models.HttpSymbol } | undefined {\r\n  const lineMatch = ParserRegex.stream.websocketLine.exec(textLine);\r\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: lineMatch.groups.url,\r\n        method: 'WS'\r\n      },\r\n      symbol: {\r\n        name: lineMatch.groups.url,\r\n        description: 'WebSocket Url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  const protocolMatch = ParserRegex.stream.websocketProtocol.exec(textLine);\r\n  if (protocolMatch && protocolMatch.length > 1 && protocolMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: protocolMatch.groups.url,\r\n        method: 'WS'\r\n      },\r\n      symbol: {\r\n        name: protocolMatch.groups.url,\r\n        description: 'WebSocket Url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nfunction isValidWebsocket(textLine: string, httpRegion: models.HttpRegion) {\r\n  if (utils.isStringEmpty(textLine)) {\r\n    return false;\r\n  }\r\n\r\n  if (ParserRegex.stream.websocketLine.exec(textLine)?.groups?.url) {\r\n    return true;\r\n  }\r\n  if (!httpRegion.request) {\r\n    return ParserRegex.stream.websocketProtocol.exec(textLine)?.groups?.url;\r\n  }\r\n  return false;\r\n}\r\n", "import * as models from '../models';\r\nimport * as utils from '../utils';\r\nimport * as actions from '../actions';\r\nimport { ParserRegex } from './parserRegex';\r\nimport * as parserUtils from './parserUtils';\r\n\r\nexport async function parseMQTTLine(\r\n  getLineReader: models.getHttpLineGenerator,\r\n  context: models.ParserContext\r\n): Promise<models.HttpRegionParserResult> {\r\n  const lineReader = getLineReader();\r\n  const next = lineReader.next();\r\n  if (!next.done && isValidMQTT(next.value.textLine, context.httpRegion)) {\r\n    if (context.httpRegion.request) {\r\n      return {\r\n        endRegionLine: next.value.line - 1,\r\n        nextParserLine: next.value.line - 1,\r\n        symbols: [],\r\n      };\r\n    }\r\n\r\n\r\n    const requestLine = getMQTTLine(next.value.textLine, next.value.line);\r\n    if (!requestLine) {\r\n      return false;\r\n    }\r\n    context.httpRegion.request = requestLine.request;\r\n    const requestSymbol: models.HttpSymbol = {\r\n      name: next.value.textLine,\r\n      description: 'MQTT request-line',\r\n      kind: models.HttpSymbolKind.requestLine,\r\n      startLine: next.value.line,\r\n      startOffset: 0,\r\n      endLine: next.value.line,\r\n      endOffset: next.value.textLine.length,\r\n      children: [requestLine.symbol],\r\n    };\r\n\r\n    const result: models.HttpRegionParserResult = {\r\n      nextParserLine: next.value.line,\r\n      symbols: [requestSymbol],\r\n    };\r\n\r\n    const headers = {};\r\n    requestLine.request.headers = headers;\r\n\r\n    const headersResult = parserUtils.parseSubsequentLines(lineReader, [\r\n      parserUtils.parseComments,\r\n      parserUtils.parseRequestHeaderFactory(headers),\r\n      parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\r\n      parserUtils.parseUrlLineFactory(url => (requestLine.request.url += url)),\r\n    ], context);\r\n\r\n    if (headersResult) {\r\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\r\n      for (const parseResult of headersResult.parseResults) {\r\n        result.symbols?.push?.(...parseResult.symbols);\r\n      }\r\n    }\r\n\r\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process,\r\n      new actions.MQTTClientAction());\r\n\r\n    context.httpRegion.hooks.execute.addInterceptor(new actions.CreateRequestInterceptor());\r\n\r\n    return result;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction getMQTTLine(textLine: string, line: number): { request: models.MQTTRequest, symbol: models.HttpSymbol } | undefined {\r\n  const lineMatch = ParserRegex.stream.mqttLine.exec(textLine);\r\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: lineMatch.groups.url,\r\n        method: 'MQTT'\r\n      },\r\n      symbol: {\r\n        name: lineMatch.groups.url,\r\n        description: 'MQTT Url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  const protocolMatch = ParserRegex.stream.mqttProtocol.exec(textLine);\r\n  if (protocolMatch && protocolMatch.length > 1 && protocolMatch.groups) {\r\n    return {\r\n      request: {\r\n        url: protocolMatch.groups.url,\r\n        method: 'MQTT'\r\n      },\r\n      symbol: {\r\n        name: protocolMatch.groups.url,\r\n        description: 'MQTT Url',\r\n        kind: models.HttpSymbolKind.url,\r\n        startLine: line,\r\n        startOffset: 0,\r\n        endLine: line,\r\n        endOffset: textLine.length,\r\n      }\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nfunction isValidMQTT(textLine: string, httpRegion: models.HttpRegion) {\r\n  if (utils.isStringEmpty(textLine)) {\r\n    return false;\r\n  }\r\n\r\n  if (ParserRegex.stream.mqttLine.exec(textLine)?.groups?.url) {\r\n    return true;\r\n  }\r\n  if (!httpRegion.request) {\r\n    return ParserRegex.stream.mqttProtocol.exec(textLine)?.groups?.url;\r\n  }\r\n  return false;\r\n}\r\n", "import { ParserContext } from '../models';\r\nimport { getDisplayName } from '../utils';\r\nimport { userInteractionProvider } from '../io';\r\n\r\nexport async function injectNote({ httpRegion }: ParserContext): Promise<void> {\r\n  if (httpRegion.metaData.note) {\r\n    const note = httpRegion.metaData.note || `Are you sure you want to send the request ${getDisplayName(httpRegion)}?`;\r\n\r\n    httpRegion.hooks.execute.addInterceptor({\r\n      beforeLoop: () => userInteractionProvider.showNote(note)\r\n    });\r\n  }\r\n}\r\n", "import { log } from '../io';\r\nimport * as models from '../models';\r\n\r\nexport function registerCancelExecutionIntercepter(parserContext: models.ParserContext) {\r\n\r\n  parserContext.httpRegion.hooks.execute.addInterceptor({\r\n    beforeLoop: async function checkUserCancelation(context: models.HookTriggerContext<models.ProcessorContext, boolean>) {\r\n      if (context.arg.progress?.isCanceled?.()) {\r\n        log.trace('processs canceled by user');\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n  });\r\n\r\n\r\n}\r\n", "import * as models from '../models';\r\n\r\nimport { parseComment } from './commentHttpRegionParser';\r\nimport { parseEventSource } from './eventSourceHttpRegionParser';\r\nimport { parseGraphql } from './gqlHttpRegionParser';\r\nimport { parseIntellijScript } from './intellijHttpRegionParser';\r\nimport { parseJavascript } from './javascriptHttpRegionParser';\r\nimport { parseMetaData } from './metaHttpRegionParser';\r\nimport { parseRequestBody, closeRequestBody } from './requestBodyHttpRegionParser';\r\nimport { parseRequestLine } from './requestHttpRegionParser';\r\nimport { parseResponse, closeResponseBody } from './responseHttpRegionParser';\r\nimport { parseResponseRef } from './responseRefHttpRegionParser';\r\nimport { parseOutputRedirection } from './outputRedirectionHttpRegionParser';\r\nimport { parseVariable } from './variableHttpRegionParser';\r\nimport { parseProtoImport } from './protoHttpRegionParser';\r\nimport { parseGrpcLine } from './grpcHttpRegionParser';\r\nimport { parseWebsocketLine } from './websocketHttpRegionParser';\r\nimport { parseMQTTLine } from './mqtttHttpRegionParser';\r\n\r\nimport { injectOnEveryRequestJavascript } from './javascriptHttpRegionParser';\r\nimport { injectNote } from './noteMetaHttpRegionParser';\r\nimport { registerCancelExecutionIntercepter } from './cancelExecutionInterceptor';\r\n\r\n\r\nexport enum ParserId {\r\n  meta = 'meta',\r\n  comment = 'comment',\r\n  variable = 'variable',\r\n  javascript = 'javascript',\r\n  note = 'note',\r\n  intellijScript = 'intellijScript',\r\n  gql = 'gql',\r\n  outputRedirection = 'outputRedirection',\r\n  request = 'request',\r\n  responseRef = 'responseRef',\r\n  response = 'response',\r\n  requestBody = 'requestBody',\r\n  proto = 'proto',\r\n  grpc = 'grpc',\r\n  eventSource = 'eventSource',\r\n  mqtt = 'mqtt',\r\n  websocket = 'websocket',\r\n}\r\n\r\nexport function initParseHook(): models.ParseHook {\r\n  const hook = new models.ParseHook();\r\n\r\n  hook.addHook(ParserId.meta, parseMetaData);\r\n  hook.addHook(ParserId.comment, parseComment);\r\n  hook.addHook(ParserId.variable, parseVariable);\r\n  hook.addHook(ParserId.javascript, parseJavascript);\r\n  hook.addHook(ParserId.intellijScript, parseIntellijScript);\r\n  hook.addHook(ParserId.gql, parseGraphql);\r\n  hook.addHook(ParserId.proto, parseProtoImport);\r\n  hook.addHook(ParserId.grpc, parseGrpcLine);\r\n  hook.addHook(ParserId.websocket, parseWebsocketLine);\r\n  hook.addHook(ParserId.eventSource, parseEventSource);\r\n  hook.addHook(ParserId.mqtt, parseMQTTLine);\r\n  hook.addHook(ParserId.request, parseRequestLine);\r\n  hook.addHook(ParserId.outputRedirection, parseOutputRedirection);\r\n  hook.addHook(ParserId.responseRef, parseResponseRef);\r\n  hook.addHook(ParserId.response, parseResponse);\r\n  hook.addHook(ParserId.requestBody, parseRequestBody);\r\n\r\n  return hook;\r\n}\r\n\r\nexport function initParseEndHook(): models.ParseEndRegionHook {\r\n  const hook = new models.ParseEndRegionHook();\r\n\r\n  hook.addHook('registerCancelExecutionIntercepter', registerCancelExecutionIntercepter);\r\n  hook.addHook(ParserId.note, injectNote);\r\n  hook.addHook(ParserId.javascript, injectOnEveryRequestJavascript);\r\n  hook.addHook(ParserId.response, closeResponseBody);\r\n  hook.addHook(ParserId.requestBody, closeRequestBody);\r\n\r\n  return hook;\r\n}\r\n", "export * as provider from './provider';\r\nexport * as replacer from './replacer';\r\n", "export * from './awsAuthVariableReplacer';\r\nexport * from './basicAuthVariableReplacer';\r\nexport * from './clientCertVariableReplacer';\r\nexport * from './initHooks';\r\nexport * from './digestAuthVariableReplacer';\r\nexport * from './escapeVariableReplacer';\r\nexport * from './hostVariableReplacer';\r\nexport * from './intellijVariableReplacer';\r\nexport * from './oauth2VariableReplacer';\r\nexport * from './javascriptVariableReplacer';\r\nexport * from './restClientVariableReplacer';\r\nexport * from './showInputBoxVariableReplacer';\r\nexport * from './showQuickpickVariableReplacer';\r\n", "import { ProcessorContext } from '../../models';\r\nimport { URL } from 'url';\r\nimport aws4 = require('aws4');\r\nimport { ParserRegex } from '../../parser';\r\nimport * as utils from '../../utils';\r\n\r\nexport async function awsAuthVariableReplacer(text: unknown, type: string, { request }: ProcessorContext) : Promise<unknown> {\r\n  if (type.toLowerCase() === 'authorization'\r\n    && utils.isString(text)\r\n    && utils.isHttpRequest(request)\r\n    && request?.url\r\n  ) {\r\n    const match = ParserRegex.auth.aws.exec(text);\r\n\r\n    if (match && match.groups && match.groups.accessKeyId && match.groups.secretAccessKey) {\r\n      const credentials = {\r\n        accessKeyId: match.groups.accessKeyId,\r\n        secretAccessKey: match.groups.secretAccessKey,\r\n        sessionToken: match.groups.token\r\n      };\r\n      const url = new URL(request.url);\r\n      const requestOptions: aws4.Request = {\r\n        method: request.method,\r\n        headers: request.headers,\r\n        host: url.host,\r\n        path: url.pathname,\r\n        region: match.groups.region,\r\n        service: match.groups.service,\r\n      };\r\n      const result = await aws4.sign(requestOptions, credentials);\r\n\r\n      Object.assign(request, { http2: false });\r\n      return result.headers?.Authorization;\r\n    }\r\n  }\r\n  return text;\r\n}\r\n", "import { ParserRegex } from '../../parser';\r\nimport { isString } from '../../utils';\r\n\r\nexport async function basicAuthVariableReplacer(text: unknown | undefined, type: string): Promise<unknown> {\r\n  if (type.toLowerCase() === 'authorization' && isString(text)) {\r\n    const match = ParserRegex.auth.basicColon.exec(text) || ParserRegex.auth.basic.exec(text);\r\n\r\n    if (match && match.groups && match.groups.user && match.groups.password) {\r\n      return `Basic ${Buffer.from(`${match.groups.user}:${match.groups.password}`).toString('base64')}`;\r\n    }\r\n  }\r\n  return text;\r\n}\r\n", "import { ClientCertificateOptions, HttpFile, HttpRequest, PathLike, ProcessorContext, VariableType } from '../../models';\r\nimport { toAbsoluteFilename, isString, isHttpRequest } from '../../utils';\r\nimport { URL } from 'url';\r\nimport { ParserRegex } from '../../parser';\r\nimport { fileProvider } from '../../io';\r\n\r\nexport async function clientCertVariableReplacer(\r\n  text: unknown,\r\n  type: VariableType | string,\r\n  context: ProcessorContext\r\n): Promise<unknown> {\r\n  const { request, httpRegion, httpFile } = context;\r\n  if (isString(text) && isHttpRequest(request) && !httpRegion.metaData.noClientCert) {\r\n    if (type === VariableType.url && context.config?.clientCertificates) {\r\n      const url = createUrl(text);\r\n      if (url) {\r\n        const clientCertifcateOptions = context.config?.clientCertificates[url.host];\r\n        if (clientCertifcateOptions) {\r\n          await setClientCertificateOptions(request, clientCertifcateOptions, httpFile);\r\n        }\r\n      }\r\n    } else if (type.toLowerCase().endsWith('clientcert')) {\r\n      const match = ParserRegex.auth.clientCert.exec(text);\r\n      if (match?.groups?.cert || match?.groups?.pfx) {\r\n        await setClientCertificateOptions(request, {\r\n          cert: match.groups.cert,\r\n          key: match.groups.key,\r\n          pfx: match.groups.pfx,\r\n          passphrase: match.groups.passphrase,\r\n        }, httpFile);\r\n        return undefined;\r\n      }\r\n    }\r\n  }\r\n  return text;\r\n}\r\n\r\nfunction createUrl(url: string): URL | undefined {\r\n  try {\r\n    return new URL(url);\r\n  } catch (err) {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nasync function setClientCertificateOptions(request: HttpRequest, clientCertifcateOptions: ClientCertificateOptions, httpFile: HttpFile) {\r\n  request.https = Object.assign({}, request.https, {\r\n    certificate: await resolveFile(clientCertifcateOptions.cert, httpFile.fileName),\r\n    key: await resolveFile(clientCertifcateOptions.key, httpFile.fileName),\r\n    pfx: await resolveFile(clientCertifcateOptions.pfx, httpFile.fileName),\r\n    passphrase: clientCertifcateOptions.passphrase\r\n  });\r\n}\r\n\r\n\r\nasync function resolveFile(fileName: PathLike | undefined, currentFilename: PathLike): Promise<Buffer | undefined> {\r\n  if (fileName) {\r\n    if (isString(fileName)) {\r\n      const file = await toAbsoluteFilename(fileName, currentFilename);\r\n      if (file) {\r\n        return await fileProvider.readBuffer(file);\r\n      }\r\n    } else {\r\n      return await fileProvider.readBuffer(fileName);\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n", "import { ProcessorContext } from '../../models';\r\nimport { CancelableRequest, OptionsOfUnknownResponseBody, Response } from 'got';\r\nimport { createHash } from 'crypto';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { URL } from 'url';\r\nimport { ParserRegex } from '../../parser';\r\nimport { isHttpRequest, isString } from '../../utils';\r\n\r\n\r\nexport async function digestAuthVariableReplacer(text: unknown, type: string, { request }: ProcessorContext): Promise<unknown> {\r\n  if (type.toLowerCase() === 'authorization' && isString(text) && isHttpRequest(request)) {\r\n    const match = ParserRegex.auth.digest.exec(text);\r\n\r\n    if (match && match.groups && match.groups.user && match.groups.password) {\r\n      if (!request.hooks) {\r\n        request.hooks = {};\r\n      }\r\n      if (!request.hooks.afterResponse) {\r\n        request.hooks.afterResponse = [];\r\n      }\r\n      request.hooks.afterResponse.push(digestFactory(match.groups.user, match.groups.password));\r\n      return undefined;\r\n    }\r\n  }\r\n  return text;\r\n}\r\n\r\n\r\nfunction digestFactory(username: string, password: string) {\r\n  return function digestAfterResponse(response: Response, retryWithMergedOptions: (options: OptionsOfUnknownResponseBody) => CancelableRequest<Response>) {\r\n    const wwwAuthenticate = response.headers['www-authenticate'];\r\n    if (response.statusCode === 401\r\n      && wwwAuthenticate\r\n      && wwwAuthenticate.toLowerCase().startsWith('digest')) {\r\n\r\n      const url = new URL(response.url);\r\n      const challenge = {\r\n        qop: '',\r\n        algorithm: '',\r\n        realm: '',\r\n        nonce: '',\r\n        opaque: ''\r\n      };\r\n\r\n      /* see https://github.com/request/request/blob/master/lib/auth.js#L63-L123*/\r\n      updateChallenge(challenge, wwwAuthenticate);\r\n\r\n      const qop = /(^|,)\\s*auth\\s*($|,)/u.test(challenge.qop) && 'auth';\r\n      const nc = qop && '00000001';\r\n      const cnonce = qop && uuidv4().replace(/-/gu, '');\r\n      const ha1 = ha1Compute(challenge.algorithm, username, password, challenge.realm, challenge.nonce, cnonce);\r\n      const ha2 = md5(`${response.request.options.method}:${url.pathname}`);\r\n      const digestResponse = qop\r\n        ? md5(`${ha1}:${challenge.nonce}:${nc}:${cnonce}:${qop}:${ha2}`)\r\n        : md5(`${ha1}:${challenge.nonce}:${ha2}`);\r\n\r\n      return retryWithMergedOptions({\r\n        headers: {\r\n          authorization: `Digest ${createDigestHeader({\r\n            username,\r\n            realm: challenge.realm,\r\n            nonce: challenge.nonce,\r\n            uri: url.pathname,\r\n            qop,\r\n            response: digestResponse,\r\n            nc,\r\n            cnonce,\r\n            algorithm: challenge.algorithm,\r\n            opaque: challenge.opaque\r\n          })}`\r\n        }\r\n      });\r\n    }\r\n\r\n    return response;\r\n  };\r\n}\r\n\r\nfunction createDigestHeader(authValues: Record<string, string | boolean>) {\r\n  const authParams: string[] = [];\r\n  for (const [key, value] of Object.entries(authValues)) {\r\n    if (value) {\r\n      if (['qop', 'nc', 'algorithm'].indexOf(key) >= 0) {\r\n        authParams.push(`${key}=${value}`);\r\n      } else {\r\n        authParams.push(`${key}=\"${value}\"`);\r\n      }\r\n    }\r\n  }\r\n  return authParams.join(', ');\r\n}\r\n\r\nfunction md5(value: string | Buffer) {\r\n\r\n  // lgtm [js/weak-cryptographic-algorithm, js/insufficient-password-hash]\r\n  return createHash('md5').update(value).digest('hex');\r\n}\r\n\r\nfunction ha1Compute(algorithm: string | undefined, username: string, password: string, realm: string, nonce: string, cnonce: string | false) {\r\n  const ha1 = md5(`${username}:${realm}:${password}`);\r\n  if (cnonce && algorithm?.toLowerCase() === 'md5-sess') {\r\n    return md5(`${ha1}:${nonce}:${cnonce}`);\r\n  }\r\n  return ha1;\r\n}\r\n\r\n\r\nfunction updateChallenge(challenge: Record<string, string>, wwwAuthenticate: string) {\r\n\r\n  for (const item of wwwAuthenticate.split(',')) {\r\n    const match = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/giu.exec(item);\r\n    if (match) {\r\n      challenge[match[1]] = match[2] || match[3];\r\n    }\r\n  }\r\n}\r\n", "import { isString } from '../../utils';\r\n\r\nexport async function escapeVariableReplacer(text: unknown): Promise<unknown> {\r\n  if (isString(text)) {\r\n    const escapeRegex = /(?:\\\\\\{){2}([^}{2}]+)(?:\\\\\\}){2}/gu;\r\n    let match: RegExpExecArray | null;\r\n    let result = text;\r\n    while (isString(result) && (match = escapeRegex.exec(text)) !== null) {\r\n      const [searchValue, variable] = match;\r\n      result = result.replace(searchValue, `{{${variable}}}`);\r\n    }\r\n    return result;\r\n  }\r\n  return text;\r\n}\r\n", "import { ProcessorContext, VariableType } from '../../models';\r\nimport { isString } from '../../utils';\r\n\r\n\r\nexport async function hostVariableReplacer(text: unknown, type: VariableType | string, { variables }: ProcessorContext): Promise<unknown> {\r\n  if (isString(text) && VariableType.url === type && !!variables.host) {\r\n    if (text.startsWith('/')) {\r\n      return `${variables.host}${text}`;\r\n    }\r\n  }\r\n  return text;\r\n}\r\n", "import { v4 as uuidv4 } from 'uuid';\r\nimport { ParserRegex } from '../../parser';\r\nimport { isString } from '../../utils';\r\n\r\n\r\nexport async function intellijVariableReplacer(text: unknown): Promise<unknown> {\r\n  if (!isString(text)) {\r\n    return text;\r\n  }\r\n  let match: RegExpExecArray | null;\r\n  let result = text;\r\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(text)) !== null) {\r\n    const [searchValue, variable] = match;\r\n\r\n    let replacement: unknown = null;\r\n    switch (variable.trim()) {\r\n      case '$uuid':\r\n        replacement = uuidv4();\r\n        break;\r\n      case '$timestamp':\r\n        replacement = Date.now();\r\n        break;\r\n      case '$randomInt':\r\n        replacement = Math.floor(Math.random() * 1000);\r\n        break;\r\n      default:\r\n        replacement = null;\r\n        break;\r\n    }\r\n    if (replacement) {\r\n      result = result.replace(searchValue, `${replacement}`);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n", "import { ProcessorContext, VariableType } from '../../models';\r\nimport { ParserRegex } from '../../parser';\r\nimport * as utils from '../../utils';\r\nimport { log } from '../../io';\r\n\r\n\r\nexport async function javascriptVariableReplacer(text: unknown, type: VariableType | string, context: ProcessorContext): Promise<unknown> {\r\n  if (!utils.isString(text)) {\r\n    return text;\r\n  }\r\n  let match: RegExpExecArray | null;\r\n  let start;\r\n  let result = text;\r\n  while (start !== result) {\r\n    start = result;\r\n    while ((match = ParserRegex.javascript.scriptSingleLine.exec(start)) !== null) {\r\n      const [searchValue, jsVariable] = match;\r\n\r\n      try {\r\n        const value = await utils.evalExpression(jsVariable, context);\r\n        if (utils.isString(value) || typeof value === 'number') {\r\n          result = result.replace(searchValue, `${value}`);\r\n        } else if (value instanceof Date) {\r\n          result = result.replace(searchValue, `${value.toISOString()}`);\r\n        } else if (value) {\r\n          result = result.replace(searchValue, `${value}`);\r\n        }\r\n      } catch (err) {\r\n        if (type === VariableType.variable) {\r\n          log.trace(`variable ${jsVariable} not defined`);\r\n        } else {\r\n          throw err;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n", "import get from 'lodash/get';\r\nimport { Variables } from '../../../models';\r\nimport { log, userInteractionProvider } from '../../../io';\r\n\r\nexport interface OpenIdConfiguration{\r\n  variablePrefix: string;\r\n  authorizationEndpoint: string;\r\n  tokenEndpoint: string;\r\n  deviceCodeEndpoint: string;\r\n  clientId: string;\r\n  clientSecret: string;\r\n  responseType: string;\r\n  responseMode?: string;\r\n  audience?: string;\r\n  scope: string;\r\n  keepAlive: boolean;\r\n  username?: string;\r\n  password?: string;\r\n  subjectIssuer?: string;\r\n  useAuthorizationHeader: boolean;\r\n}\r\n\r\nfunction getVariable(variables: Variables, variablePrefix: string, name: string): string {\r\n  return (variables[`${variablePrefix}_${name}`] || get(variables, `${variablePrefix}.${name}`)) as string;\r\n}\r\n\r\nexport function getOpenIdConfiguration(variablePrefix: string, variables: Variables) : OpenIdConfiguration | false {\r\n  if (variablePrefix) {\r\n    const config: OpenIdConfiguration = {\r\n      variablePrefix,\r\n      authorizationEndpoint: getVariable(variables, variablePrefix, 'authorizationEndpoint'),\r\n      deviceCodeEndpoint: getVariable(variables, variablePrefix, 'deviceCodeEndpoint'),\r\n      tokenEndpoint: getVariable(variables, variablePrefix, 'tokenEndpoint'),\r\n      clientId: getVariable(variables, variablePrefix, 'clientId'),\r\n      clientSecret: getVariable(variables, variablePrefix, 'clientSecret'),\r\n      responseType: getVariable(variables, variablePrefix, 'responseType'),\r\n      responseMode: getVariable(variables, variablePrefix, 'responseMode'),\r\n      audience: getVariable(variables, variablePrefix, 'audience'),\r\n      scope: getVariable(variables, variablePrefix, 'scope'),\r\n      username: getVariable(variables, variablePrefix, 'username'),\r\n      password: getVariable(variables, variablePrefix, 'password'),\r\n      subjectIssuer: getVariable(variables, variablePrefix, 'subjectIssuer'),\r\n      keepAlive: ['true', '1', true].indexOf(getVariable(variables, variablePrefix, 'keepAlive')) < 0,\r\n      useAuthorizationHeader: ['false', '0', false].indexOf(getVariable(variables, variablePrefix, 'useAuthorizationHeader')) < 0,\r\n    };\r\n    return config;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport function assertConfiguration(config: OpenIdConfiguration, keys: string[]) : boolean {\r\n  const missingKeys = [];\r\n  for (const key of keys) {\r\n    if (!Object.entries(config).some(([obj, value]) => obj === key && !!value)) {\r\n      missingKeys.push(key);\r\n    }\r\n  }\r\n  if (missingKeys.length > 0) {\r\n    const message = `missing configuration: ${missingKeys.map(obj => `${config.variablePrefix}_${obj}`).join(', ')}`;\r\n    log.error(message);\r\n    userInteractionProvider.showErrorMessage?.(message);\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n", "import { OpenIdConfiguration } from './openIdConfiguration';\r\nimport * as models from '../../../models';\r\nimport * as utils from '../../../utils';\r\nimport { log } from '../../../io';\r\n\r\nexport interface OpenIdInformation extends models.UserSession{\r\n  time: number;\r\n  config: OpenIdConfiguration;\r\n  accessToken: string;\r\n  expiresIn: number;\r\n  timeSkew: number;\r\n  refreshToken?: string;\r\n  refreshExpiresIn?: number;\r\n}\r\n\r\nexport interface OpenIdContext{\r\n  httpClient: models.HttpClient,\r\n}\r\n\r\n\r\nexport interface OpenIdSesssion extends Omit<models.UserSession, 'type'>{\r\n  config: OpenIdConfiguration,\r\n}\r\n\r\nexport async function requestOpenIdInformation(\r\n  request: models.HttpRequest | false,\r\n  options: OpenIdSesssion,\r\n  context: OpenIdContext\r\n): Promise<OpenIdInformation | false> {\r\n  if (request) {\r\n    const time = new Date().getTime();\r\n\r\n    if (!request.headers) {\r\n      request.headers = {\r\n        'content-type': 'application/x-www-form-urlencoded',\r\n      };\r\n    }\r\n\r\n    if (request.headers && options.config.useAuthorizationHeader) {\r\n      request.headers.authorization = `Basic ${Buffer.from(`${options.config.clientId}:${options.config.clientSecret}`).toString('base64')}`;\r\n    } else {\r\n      request.body = `${request.body}&${utils.toQueryParams({\r\n        client_id: options.config.clientId,\r\n        client_secret: options.config.clientSecret\r\n      })}`;\r\n    }\r\n\r\n    const response = await context?.httpClient(request, { showProgressBar: false });\r\n    if (response) {\r\n      if (models.isProcessorContext(context)) {\r\n        await utils.logResponse(response, context);\r\n      }\r\n      if (response.statusCode === 200 && utils.isString(response.body)) {\r\n        return toOpenIdInformation(JSON.parse(response.body), time, options);\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function toOpenIdInformation(jwtToken: unknown, time: number, session: OpenIdSesssion): OpenIdInformation | false {\r\n  if (isAuthToken(jwtToken)) {\r\n    const parsedToken = utils.decodeJWT(jwtToken.access_token);\r\n    if (parsedToken) {\r\n      log.debug(JSON.stringify(parsedToken, null, 2));\r\n    }\r\n    return {\r\n      ...session,\r\n      type: 'OAuth2',\r\n      time,\r\n      accessToken: jwtToken.access_token,\r\n      expiresIn: jwtToken.expires_in,\r\n      refreshToken: jwtToken.refresh_token,\r\n      refreshExpiresIn: jwtToken.refresh_expires_in,\r\n      timeSkew: parsedToken?.iat ? Math.floor(time / 1000) - parsedToken.iat : 0,\r\n    };\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nexport function isAuthToken(obj: unknown): obj is AuthToken {\r\n  const guard = obj as AuthToken;\r\n  return guard && !!guard.access_token && !!guard.expires_in;\r\n}\r\n\r\ninterface AuthToken {\r\n  access_token: string;\r\n  expires_in: number;\r\n  refresh_token?: string;\r\n  refresh_expires_in?: number;\r\n}\r\n", "import { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\r\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\r\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\r\nimport * as utils from '../../../utils';\r\nimport open from 'open';\r\nimport { registerListener, unregisterListener } from './openIdHttpserver';\r\n\r\nclass AuthorizationCodeFlow implements OpenIdFlow {\r\n  supportsFlow(flow: string): boolean {\r\n    return ['authorization_code', 'code'].indexOf(flow) >= 0;\r\n  }\r\n\r\n  getCacheKey(config: OpenIdConfiguration) {\r\n    if (assertConfiguration(config, ['tokenEndpoint', 'authorizationEndpoint', 'clientId', 'clientSecret'])) {\r\n      return `authorization_code_${config.clientId}_${config.tokenEndpoint}`;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\r\n    const id = this.getCacheKey(config);\r\n    if (id) {\r\n      return new Promise<OpenIdInformation | false>((resolve, reject) => {\r\n        const state = utils.stateGenerator();\r\n        try {\r\n          utils.report(context, 'execute OAuth2 authorization_code flow');\r\n          const redirectUri = 'http://localhost:3000/callback';\r\n          const authUrl = `${config.authorizationEndpoint}${config.authorizationEndpoint.indexOf('?') > 0 ? '&' : '?'}${utils.toQueryParams({\r\n            client_id: config.clientId,\r\n            scope: config.scope || 'openid',\r\n            response_type: 'code',\r\n            state,\r\n            audience: config.audience,\r\n            redirect_uri: redirectUri\r\n          })}`;\r\n\r\n          let unregisterProgress: (() => void) | undefined;\r\n          if (context.progress) {\r\n            unregisterProgress = context.progress.register(() => {\r\n              unregisterListener(state);\r\n              reject(new Error('process canceled'));\r\n            });\r\n          }\r\n\r\n          registerListener({\r\n            id: state,\r\n            name: `authorization for ${config.clientId}: ${config.authorizationEndpoint}`,\r\n            resolve: params => {\r\n              if (params.code && params.state === state) {\r\n                if (unregisterProgress) {\r\n                  unregisterProgress();\r\n                }\r\n                const openIdInformation = requestOpenIdInformation({\r\n                  url: config.tokenEndpoint,\r\n                  method: 'POST',\r\n                  body: utils.toQueryParams({\r\n                    grant_type: 'authorization_code',\r\n                    scope: config.scope,\r\n                    code: params.code,\r\n                    redirect_uri: redirectUri,\r\n                  })\r\n                }, {\r\n                  config,\r\n                  id,\r\n                  title: `authorization_code: ${config.clientId}`,\r\n                  description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\r\n                  details: {\r\n                    clientId: config.clientId,\r\n                    tokenEndpoint: config.tokenEndpoint,\r\n                    grantType: 'authorization_code',\r\n                  }\r\n                }, context);\r\n                resolve(openIdInformation);\r\n                return {\r\n                  valid: true,\r\n                  message: 'code received.',\r\n                  statusMessage: 'code and state valid. starting code exchange'\r\n                };\r\n              }\r\n\r\n              if (params.error_description) {\r\n                return {\r\n                  valid: false,\r\n                  message: decodeURIComponent(params.error_description),\r\n                  statusMessage: 'no access_token received'\r\n                };\r\n              }\r\n              return {\r\n                valid: false,\r\n                message: 'no code received',\r\n                statusMessage: 'no code received'\r\n              };\r\n            },\r\n            reject,\r\n          });\r\n          utils.report(context, `autorization_code browser authentication pending: ${authUrl}`);\r\n          open(authUrl);\r\n        } catch (err) {\r\n          unregisterListener(state);\r\n          reject(err);\r\n        }\r\n      });\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\nexport const authorizationCodeFlow = new AuthorizationCodeFlow();\r\n", "import { createServer, Server } from 'http';\r\nimport { log } from '../../../io';\r\n\r\ninterface RequestListener{\r\n  id: string;\r\n  name: string;\r\n  resolve: (params: Record<string, string>) => { valid: boolean; message: string; statusMessage: string;};\r\n  reject: () => void;\r\n}\r\n\r\nconst listeners: Array<RequestListener> = [];\r\n\r\nlet server: Server | false;\r\nlet serverTimeout: NodeJS.Timeout | false;\r\nlet serverTimeoutTime = 0;\r\n\r\nexport function registerListener(listener: RequestListener) : void {\r\n  listeners.push(listener);\r\n  initServer();\r\n}\r\n\r\nexport function unregisterListener(id: string) : void {\r\n  const listenerIndex = listeners.findIndex(obj => obj.id === id);\r\n  if (listenerIndex >= 0) {\r\n    listeners.splice(listenerIndex, 1);\r\n  }\r\n  if (listeners.length === 0) {\r\n    resetServer(60);\r\n  }\r\n}\r\n\r\n\r\nfunction clearServerTimeout() {\r\n  if (serverTimeout) {\r\n    clearTimeout(serverTimeout);\r\n    serverTimeout = false;\r\n    serverTimeoutTime = 0;\r\n  }\r\n}\r\n\r\nfunction resetServer(seconds: number) {\r\n  clearServerTimeout();\r\n  const timeout = seconds * 1000;\r\n  serverTimeoutTime = (new Date().getTime()) + timeout;\r\n  serverTimeout = setTimeout(() => closeServer(), timeout);\r\n}\r\n\r\nfunction closeServer() {\r\n  for (const listener of listeners) {\r\n    listener.reject();\r\n  }\r\n  listeners.length = 0;\r\n  if (server) {\r\n    clearServerTimeout();\r\n    server.close(err => {\r\n      if (err) {\r\n        log.error(err);\r\n      } else {\r\n        log.debug('http server closed');\r\n      }\r\n    });\r\n    server = false;\r\n  }\r\n}\r\n\r\nfunction initServer(port = 3000) {\r\n  resetServer(600);\r\n  if (!server) {\r\n    log.debug(`open http server on port ${port}`);\r\n    server = createServer((req, res) => {\r\n      try {\r\n        let statusMessage = 'invalid';\r\n        let statusCode = 500;\r\n\r\n        const responseContent: string[] = [];\r\n\r\n        if (req.url) {\r\n          const queryParams = parseQueryParams(req.url);\r\n          if (req.url.startsWith('/callback')) {\r\n            const listener = listeners.find(obj => obj.id === queryParams.state);\r\n            if (listener) {\r\n              const result = listener.resolve(queryParams);\r\n              responseContent.push(getMessageHtml(result.message, result.valid));\r\n              if (result.valid) {\r\n                statusCode = 200;\r\n                unregisterListener(listener.id);\r\n              }\r\n              statusMessage = result.statusMessage;\r\n            } else {\r\n              responseContent.push(getMessageHtml('invalid state received', false));\r\n              responseContent.push(`\r\n                <script>\r\n                  if(window.location.hash){\r\n                    window.document.querySelector('.js-message').remove();\r\n                    window.location.replace(\\`\\${window.location.href.substring(0,window.location.href.indexOf('#'))}?\\${window.location.hash.substring(1)}\\`);\r\n                  }\r\n                </script>\r\n                <noscript>\r\n                  ${getMessageHtml('Please enable javascript for redirect or replace fragment (#) with query (?)', false)}\r\n                </noscript>\r\n              `);\r\n              statusMessage = 'invalid state received';\r\n\r\n            }\r\n          } else if (req.url.startsWith('/reject')) {\r\n            const listener = listeners.find(obj => obj.id === queryParams.id);\r\n            if (listener) {\r\n              listener.reject();\r\n              unregisterListener(queryParams.id);\r\n              statusCode = 200;\r\n              statusMessage = 'listener removed';\r\n              responseContent.push(getMessageHtml(`${listener.name} removed`, true));\r\n            } else {\r\n              statusMessage = 'listener not found';\r\n            }\r\n          } else if (req.url.startsWith('/shutdown')) {\r\n            closeServer();\r\n            responseContent.push(getMessageHtml('server closed', true));\r\n            statusCode = 200;\r\n            statusMessage = 'server was shut down';\r\n          }\r\n        }\r\n        responseContent.push(getServerStatus());\r\n        res.setHeader('Content-Type', 'text/html');\r\n        res.writeHead(statusCode, statusMessage);\r\n        res.end(getHtml(responseContent.join('')));\r\n      } catch (err) {\r\n        log.error(err);\r\n        res.end(getHtml(`${err}`));\r\n      }\r\n    });\r\n    server.listen(port);\r\n  }\r\n}\r\n\r\n\r\nfunction parseQueryParams(url: string) {\r\n  return url.slice(url.indexOf('?') + 1).split('&').reduce((prev, current) => {\r\n    const [key, value] = current.split('=');\r\n    prev[key] = value;\r\n    return prev;\r\n  }, {} as Record<string, string>);\r\n}\r\n\r\n\r\nfunction getMessageHtml(message: string, valid: boolean) {\r\n  return `\r\n<div class=\"card js-message ${valid ? 'card--success' : 'card--error'}\">\r\n  <h3 class=\"card__title\">${valid ? 'success' : 'error'}</h3>\r\n  <div class=\"card__message\">${message}</div>\r\n</div>`;\r\n\r\n}\r\n\r\nfunction getServerStatus() {\r\n  const lines = [];\r\n  if (listeners.length > 0) {\r\n    lines.push(...listeners.map(obj => `\r\n      <div class=\"card\">\r\n        <h3 class=\"card__title\">open requests</h3>\r\n        <div class=\"card__message\">${obj.name}</div>\r\n        <div class=\"card__actions\">\r\n          <a href=\"/reject?id=${obj.id}\">remove</a>\r\n        </div>\r\n      </div>`));\r\n  }\r\n  if (serverTimeoutTime > 0) {\r\n    lines.push(`\r\n    <div class=\"card\">\r\n      <h3 class=\"card__title\">Server Status</h3>\r\n      <div class=\"card__message\">automatic shutdown in ${toTimeString(Math.floor((serverTimeoutTime - (new Date()).getTime()) / 1000))}</div>\r\n      <div class=\"card__actions\">\r\n        <a href=\"/shutdown\">shutdown</a>\r\n      </div>\r\n    </div>`);\r\n  }\r\n\r\n  return lines.join('');\r\n}\r\n\r\nfunction toTimeString(seconds: number) {\r\n  if (seconds > 0) {\r\n    const minutes = Math.trunc(seconds / 60);\r\n    const sec = seconds % 60;\r\n    if (minutes > 0) {\r\n      if (sec > 0) {\r\n        return `${minutes}minute${minutes > 1 ? 's' : ''} ${sec} seconds`;\r\n      }\r\n      return `${minutes} minute${minutes > 1 ? 's' : ''}`;\r\n    }\r\n    return `${seconds} seconds`;\r\n  }\r\n  return '-';\r\n}\r\n\r\n\r\nfunction getHtml(message: string) {\r\n  return `\r\n  <html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"utf-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>httpYac</title>\r\n    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>\r\n    <style>\r\n    :root{\r\n      --light: #FAFAFA;\r\n      --success: #4CAF50;\r\n      --success-dark: #43A047;\r\n      --error: #D32F2F;\r\n      --error-dark: #C62828;\r\n      --link-light: #E1F5FE;\r\n      --link: #00B0FF;\r\n      --link-dark: #0091EA;\r\n    }\r\n      body{\r\n        font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\r\n        background-color: var(--light);\r\n        display:flex;\r\n        align-items: center;\r\n        flex-direction: column;\r\n      }\r\n\r\n      .card{\r\n        border-radius: 4px;\r\n        background-color: #FFF;\r\n        box-shadow: 0px 2px 1px -1px rgb(0 0 0 / 20%), 0px 1px 1px 0px rgb(0 0 0 / 14%), 0px 1px 3px 0px rgb(0 0 0 / 12%);\r\n        width: 22rem;\r\n        padding: .5rem;\r\n        margin: auto;\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: center;\r\n        margin: 2rem;\r\n      }\r\n\r\n      .card--success{\r\n        border-bottom: 1rem solid var(--success);\r\n      }\r\n      .card--success:hover{\r\n        border-bottom: 1rem solid var(--success-dark);\r\n      }\r\n\r\n      .card--error{\r\n        border-bottom: 1rem solid var(--error);\r\n      }\r\n      .card--error:hover{\r\n        border-bottom: 1rem solid var(--error-dark);\r\n      }\r\n      .card__title{\r\n        margin: 0 .5rem;\r\n      }\r\n      .card__message{\r\n        padding: 0 .5rem;\r\n        word-break: break-word;\r\n      }\r\n      .card__actions{\r\n        padding: 1rem 0;\r\n      }\r\n      a {\r\n          color: var(--link);\r\n          text-decoration:none;\r\n          border-radius:3px;\r\n          cursor:pointer;\r\n          text-transform: uppercase;\r\n          padding: .5rem;\r\n      }\r\n      a:focus {\r\n        outline-color: var(--link);\r\n        color: var(--link);\r\n      }\r\n      a:hover, a:active {\r\n          color: var(--link-dark);\r\n          background-color: var(--link-light);\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n  <img src=\"https://raw.githubusercontent.com/AnWeber/vscode-httpyac/master/icon.png\" alt=\"HttpYac Logo\" />\r\n${message}\r\n</body>\r\n</html>\r\n`;\r\n}\r\n", "import { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\r\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\r\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\r\nimport * as utils from '../../../utils';\r\n\r\nclass ClientCredentialsFlow implements OpenIdFlow {\r\n  supportsFlow(flow: string): boolean {\r\n    return ['client_credentials', 'client'].indexOf(flow) >= 0;\r\n  }\r\n\r\n  getCacheKey(config: OpenIdConfiguration) {\r\n    if (assertConfiguration(config, ['tokenEndpoint', 'clientId', 'clientSecret'])) {\r\n      return `client_credentials_${config.clientId}_${config.tokenEndpoint}`;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\r\n    const id = this.getCacheKey(config);\r\n    if (id) {\r\n      utils.report(context, 'execute OAuth2 client_credentials flow');\r\n      return requestOpenIdInformation({\r\n        url: config.tokenEndpoint,\r\n        method: 'POST',\r\n        body: utils.toQueryParams({\r\n          grant_type: 'client_credentials',\r\n          scope: config.scope,\r\n        })\r\n      }, {\r\n        config,\r\n        id,\r\n        title: `clientCredentials: ${config.clientId}`,\r\n        description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\r\n        details: {\r\n          clientId: config.clientId,\r\n          tokenEndpoint: config.tokenEndpoint,\r\n          grantType: 'client_credentials',\r\n        }\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nexport const clientCredentialsFlow = new ClientCredentialsFlow();\r\n", "import { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\r\nimport { OpenIdInformation, toOpenIdInformation } from './openIdInformation';\r\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\r\nimport * as utils from '../../../utils';\r\nimport * as models from '../../../models';\r\nimport * as io from '../../../io';\r\nimport open from 'open';\r\n\r\nclass DeviceCodeFlow implements OpenIdFlow {\r\n  supportsFlow(flow: string): boolean {\r\n    return ['device_code', 'device'].indexOf(flow) >= 0;\r\n  }\r\n\r\n  getCacheKey(config: OpenIdConfiguration) {\r\n    if (assertConfiguration(config, ['tokenEndpoint', 'deviceCodeEndpoint', 'clientId'])) {\r\n      return `device_code_${config.clientId}_${config.tokenEndpoint}`;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\r\n    const id = this.getCacheKey(config);\r\n    if (id) {\r\n\r\n      utils.report(context, 'execute device_code authorization flow');\r\n\r\n      const deviceCodeTime = (new Date()).getTime();\r\n      const deviceCodeResponse = await this.requestDeviceAuthorization(context, config);\r\n\r\n      if (deviceCodeResponse\r\n        && deviceCodeResponse.statusCode === 200\r\n        && utils.isString(deviceCodeResponse.body)) {\r\n        if (models.isProcessorContext(context)) {\r\n          await utils.logResponse(deviceCodeResponse, context);\r\n        }\r\n        utils.report(context, 'device_code received');\r\n\r\n        const deviceCodeBody: DevcieCodeBody = JSON.parse(deviceCodeResponse.body);\r\n\r\n        let interval = deviceCodeBody.interval ? Number(deviceCodeBody.interval) * 1000 : 5000;\r\n        if (Number.isNaN(interval)) {\r\n          interval = 5000;\r\n        }\r\n\r\n        this.showUserCode(deviceCodeBody);\r\n\r\n        while (((new Date()).getTime() - deviceCodeTime) < Number(deviceCodeBody.expires_in) * 1000) {\r\n          try {\r\n            await utils.sleep(interval);\r\n            if (context.progress?.isCanceled?.()) {\r\n              return false;\r\n            }\r\n            const time = new Date().getTime();\r\n            const response = await this.authenticateUser(context, config, deviceCodeBody);\r\n            if (response && utils.isString(response.body)) {\r\n              const parsedBody = JSON.parse(response.body);\r\n              if (response.statusCode === 200) {\r\n                utils.report(context, 'accessToken received');\r\n                await this.logResponse(response, context);\r\n                return toOpenIdInformation(parsedBody, time, {\r\n                  config,\r\n                  id,\r\n                  title: `deviceCode: ${config.clientId}`,\r\n                  description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\r\n                  details: {\r\n                    clientId: config.clientId,\r\n                    tokenEndpoint: config.tokenEndpoint,\r\n                    grantType: 'device_code',\r\n                  }\r\n                });\r\n              }\r\n              utils.report(context, `device code ${parsedBody.error}`);\r\n              if (['slow_down', 'authorization_pending'].indexOf(parsedBody.error) >= 0) {\r\n                if (parsedBody.error === 'slow_down' || response.statusCode === 408) { // on Timeout slow down\r\n                  interval += 5000;\r\n                  io.log.debug(`DeviceCode Flow increase interval: ${interval}`);\r\n                }\r\n              } else {\r\n                if (parsedBody.error && ['access_denied', 'expired_token', 'bad_verification_code'].indexOf(parsedBody.error) >= 0) {\r\n                  io.log.debug(`DeviceCode Flow aborted: ${parsedBody.error_description || ''}`);\r\n                  await this.logResponse(response, context);\r\n                  return false;\r\n                }\r\n                if ((await io.userInteractionProvider.showWarnMessage?.(`Unknown error code ${parsedBody.error}`, 'Continue', 'Cancel')) === 'Cancel') {\r\n                  await this.logResponse(response, context);\r\n                  return false;\r\n                }\r\n              }\r\n            } else {\r\n              io.log.debug('device code received invalid response');\r\n              return false;\r\n            }\r\n\r\n          } catch (err) {\r\n            io.log.debug(err);\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private async logResponse(response: models.HttpResponse, context: OpenIdFlowContext) {\r\n    if (models.isProcessorContext(context)) {\r\n      await utils.logResponse(response, context);\r\n    }\r\n  }\r\n\r\n  private async authenticateUser(context: OpenIdFlowContext, config: OpenIdConfiguration, deviceCodeBody: DevcieCodeBody) {\r\n    return await context?.httpClient({\r\n      url: config.tokenEndpoint,\r\n      method: 'POST',\r\n      headers: {\r\n        'content-type': 'application/x-www-form-urlencoded',\r\n      },\r\n      body: utils.toQueryParams({\r\n        client_id: config.clientId,\r\n        grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\r\n        code: deviceCodeBody.device_code,\r\n      })\r\n    }, { showProgressBar: false });\r\n  }\r\n\r\n  private async requestDeviceAuthorization(context: OpenIdFlowContext, config: OpenIdConfiguration) {\r\n    return await context?.httpClient({\r\n      url: config.deviceCodeEndpoint,\r\n      method: 'POST',\r\n      headers: {\r\n        'content-type': 'application/x-www-form-urlencoded',\r\n      },\r\n      body: utils.toQueryParams({\r\n        client_id: config.clientId,\r\n        scope: config.scope || 'openid',\r\n      })\r\n    }, { showProgressBar: false });\r\n  }\r\n\r\n  private showUserCode(deviceCodeBody: DevcieCodeBody) {\r\n    const message = deviceCodeBody.message || `To sign in, use a web browser to open the page ${deviceCodeBody.verification_uri_complete} and enter the code ${deviceCodeBody.user_code} to authenticate.`;\r\n    io.log.info(message);\r\n    io.log.info(`Verfication_Uri: ${deviceCodeBody.verification_uri_complete || deviceCodeBody.verification_uri}`);\r\n    io.log.info(`User_Code: ${deviceCodeBody.user_code}`);\r\n\r\n    const openVerificationUri = async () => {\r\n      await io.userInteractionProvider.setClipboard?.(deviceCodeBody.user_code);\r\n      await open(deviceCodeBody.verification_uri_complete || deviceCodeBody.verification_uri);\r\n    };\r\n\r\n    if (io.userInteractionProvider.showInformationMessage) {\r\n      io.userInteractionProvider.showInformationMessage(\r\n        message,\r\n        'Open'\r\n      ).then(button => {\r\n        if (button) {\r\n          openVerificationUri();\r\n        }\r\n      });\r\n    } else {\r\n      openVerificationUri();\r\n    }\r\n  }\r\n}\r\n\r\ninterface DevcieCodeBody{\r\n  user_code: string,\r\n  device_code: string,\r\n  verification_uri: string,\r\n  verification_uri_complete?: string;\r\n  expires_in: string,\r\n  interval?: string,\r\n  message?: string\r\n}\r\n\r\n\r\nexport const deviceCodeFlow = new DeviceCodeFlow();\r\n", "import { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\r\nimport { OpenIdInformation, toOpenIdInformation, requestOpenIdInformation } from './openIdInformation';\r\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\r\nimport * as utils from '../../../utils';\r\nimport open from 'open';\r\nimport { registerListener, unregisterListener } from './openIdHttpserver';\r\nimport { log } from '../../../io';\r\n\r\nclass ImplicitFlow implements OpenIdFlow {\r\n  supportsFlow(flow: string): boolean {\r\n    return ['implicit', 'hybrid'].indexOf(flow) >= 0;\r\n  }\r\n\r\n  getCacheKey(config: OpenIdConfiguration) {\r\n    if (assertConfiguration(config, ['tokenEndpoint', 'authorizationEndpoint', 'clientId'])) {\r\n      return `implicit_${config.clientId}_${config.tokenEndpoint}`;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\r\n    const id = this.getCacheKey(config);\r\n    if (id) {\r\n      return new Promise<OpenIdInformation | false>((resolve, reject) => {\r\n        utils.report(context, 'execute OAuth2 implicit flow');\r\n        const state = utils.stateGenerator();\r\n        try {\r\n          const redirectUri = 'http://localhost:3000/callback';\r\n          const authUrl = `${config.authorizationEndpoint}${config.authorizationEndpoint.indexOf('?') > 0 ? '&' : '?'}${utils.toQueryParams({\r\n            client_id: config.clientId,\r\n            scope: config.scope || 'openid',\r\n            response_type: config.responseType || 'token',\r\n            nonce: utils.stateGenerator(),\r\n            state,\r\n            response_mode: config.responseMode,\r\n            audience: config.audience,\r\n            redirect_uri: redirectUri\r\n          })}`;\r\n\r\n          let unregisterProgress: (() => void) | undefined;\r\n          if (context.progress) {\r\n            unregisterProgress = context.progress.register(() => {\r\n              unregisterListener(state);\r\n              reject(new Error('progress cancel'));\r\n            });\r\n          }\r\n\r\n          registerListener({\r\n            id: state,\r\n            name: `authorization for ${config.clientId}: ${config.authorizationEndpoint}`,\r\n            resolve: params => {\r\n              if (params.state === state) {\r\n\r\n                if (params.code) {\r\n                  const openIdInformation = requestOpenIdInformation({\r\n                    url: config.tokenEndpoint,\r\n                    method: 'POST',\r\n                    body: utils.toQueryParams({\r\n                      grant_type: 'authorization_code',\r\n                      scope: config.scope,\r\n                      code: params.code,\r\n                      redirect_uri: redirectUri\r\n                    })\r\n                  }, {\r\n                    config,\r\n                    id,\r\n                    title: `implicit: ${config.clientId}`,\r\n                    description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\r\n                    details: {\r\n                      clientId: config.clientId,\r\n                      tokenEndpoint: config.tokenEndpoint,\r\n                      grantType: 'implicit',\r\n                    }\r\n                  }, context);\r\n                  resolve(openIdInformation);\r\n                  return {\r\n                    valid: true,\r\n                    message: 'code received.',\r\n                    statusMessage: 'code valid. starting code exchange'\r\n                  };\r\n                }\r\n                if (params.access_token) {\r\n                  if (unregisterProgress) {\r\n                    unregisterProgress();\r\n                  }\r\n                  const openIdInformation = toOpenIdInformation(params, (new Date()).getTime(), {\r\n                    config,\r\n                    id,\r\n                    title: `implicit: ${config.clientId}`,\r\n                    description: config.tokenEndpoint,\r\n                    details: {\r\n                      clientId: config.clientId,\r\n                      tokenEndpoint: config.tokenEndpoint,\r\n                      grantType: 'implicit',\r\n                    }\r\n                  });\r\n                  resolve(openIdInformation);\r\n                  return {\r\n                    valid: true,\r\n                    message: 'access_token received.',\r\n                    statusMessage: 'access_token and state valid.'\r\n                  };\r\n                }\r\n              }\r\n\r\n              if (params.error_description) {\r\n                return {\r\n                  valid: false,\r\n                  message: decodeURIComponent(params.error_description),\r\n                  statusMessage: 'no access_token received'\r\n                };\r\n              }\r\n              return {\r\n                valid: false,\r\n                message: 'no access_token received',\r\n                statusMessage: 'no access_token received'\r\n              };\r\n            },\r\n            reject,\r\n          });\r\n          log.trace(`open browser: ${authUrl}`);\r\n          utils.report(context, `implicit browser authentication pending: ${authUrl}`);\r\n          open(authUrl);\r\n        } catch (err) {\r\n          unregisterListener(state);\r\n          reject(err);\r\n        }\r\n      });\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\nexport const implicitFlow = new ImplicitFlow();\r\n", "import { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\r\nimport * as utils from '../../../utils';\r\nimport { OpenIdFlowContext } from './openIdFlow';\r\n\r\nclass RefreshTokenFlow {\r\n\r\n  private isTokenExpired(time: number, timeSkew: number, expiresIn?: number) {\r\n    if (typeof expiresIn !== 'undefined') {\r\n      return time + 1000 * (expiresIn - timeSkew) < (new Date()).getTime();\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async perform(openIdInformation: OpenIdInformation, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\r\n    if (!this.isTokenExpired(openIdInformation.time, openIdInformation.timeSkew, openIdInformation.expiresIn)) {\r\n      return openIdInformation;\r\n    }\r\n    if (openIdInformation.refreshToken\r\n      && !this.isTokenExpired(openIdInformation.time, openIdInformation.timeSkew, openIdInformation.refreshExpiresIn)) {\r\n      utils.report(context, 'execute OAuth2 refresh_token flow');\r\n      return requestOpenIdInformation({\r\n        url: openIdInformation.config.tokenEndpoint,\r\n        method: 'POST',\r\n        body: utils.toQueryParams({\r\n          grant_type: 'refresh_token',\r\n          refresh_token: openIdInformation.refreshToken\r\n        })\r\n      }, {\r\n        config: openIdInformation.config,\r\n        id: openIdInformation.id,\r\n        title: openIdInformation.title,\r\n        description: openIdInformation.description,\r\n        details: {\r\n          clientId: openIdInformation.config.clientId,\r\n          tokenEndpoint: openIdInformation.config.tokenEndpoint,\r\n          grantType: 'refresh_token',\r\n        }\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nexport const refreshTokenFlow = new RefreshTokenFlow();\r\n", "import { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\r\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\r\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\r\nimport * as utils from '../../../utils';\r\n\r\nclass PasswordFlow implements OpenIdFlow {\r\n  supportsFlow(flow: string): boolean {\r\n    return ['password'].indexOf(flow) >= 0;\r\n  }\r\n\r\n  getCacheKey(config: OpenIdConfiguration) {\r\n    if (assertConfiguration(config, ['tokenEndpoint', 'clientId', 'clientSecret', 'username', 'password'])) {\r\n      return `password_${config.clientId}_${config.username}_${config.tokenEndpoint}`;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\r\n    const id = this.getCacheKey(config);\r\n    if (id) {\r\n      utils.report(context, 'execute OAuth2 password flow');\r\n      return requestOpenIdInformation({\r\n        url: config.tokenEndpoint,\r\n        method: 'POST',\r\n        body: utils.toQueryParams({\r\n          grant_type: 'password',\r\n          scope: config.scope,\r\n          username: config.username,\r\n          password: config.password,\r\n        })\r\n      }, {\r\n        config,\r\n        id,\r\n        title: `PasswordFlow: ${config.username} (${config.clientId})`,\r\n        description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\r\n        details: {\r\n          clientId: config.clientId,\r\n          tokenEndpoint: config.tokenEndpoint,\r\n          grantType: 'password',\r\n          username: config.username,\r\n        }\r\n      }, context);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\nexport const passwordFlow = new PasswordFlow();\r\n", "import { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\r\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\r\nimport * as utils from '../../../utils';\r\nimport { ProcessorContext } from '../../../models';\r\nimport encodeUrl from 'encodeurl';\r\n\r\nexport class TokenExchangeFlow {\r\n  static getCacheKey(config: OpenIdConfiguration) : string | false {\r\n    if (assertConfiguration(config, ['tokenEndpoint', 'clientId', 'clientSecret'])) {\r\n      return `${config.tokenEndpoint}_${config.clientId}`;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static async perform(config: OpenIdConfiguration,\r\n    openIdInformation: OpenIdInformation,\r\n    context: ProcessorContext): Promise<OpenIdInformation | false> {\r\n    if (openIdInformation) {\r\n      utils.report(context, 'execute OAuth2 token exchange flow');\r\n      const jwtToken = utils.decodeJWT(openIdInformation.accessToken);\r\n\r\n      return requestOpenIdInformation({\r\n        url: config.tokenEndpoint,\r\n        method: 'POST',\r\n        body: utils.toQueryParams({\r\n          grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',\r\n          requested_token_type: 'urn:ietf:params:oauth:token-type:access_token',\r\n          subject_token_type: 'urn:ietf:params:oauth:token-type:access_token',\r\n          scope: config.scope || 'openid',\r\n          subject_issuer: config.subjectIssuer || jwtToken?.iss,\r\n          subject_token: encodeUrl(openIdInformation.accessToken)\r\n        })\r\n      }, {\r\n        config,\r\n        id: openIdInformation.id,\r\n        title: `${openIdInformation.title} (token exchange)`,\r\n        description: openIdInformation.description,\r\n        details: {\r\n          clientId: config.clientId,\r\n          tokenEndpoint: config.tokenEndpoint,\r\n          grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',\r\n        }\r\n      }, context);\r\n\r\n    }\r\n    return false;\r\n  }\r\n}\r\n", "import { ProcessorContext, HttpClient, UserSession, HookCancel } from '../../models';\r\nimport { userSessionStore } from '../../store';\r\nimport * as oauth from './oauth';\r\nimport { ParserRegex } from '../../parser';\r\nimport { log } from '../../io';\r\nimport * as utils from '../../utils';\r\n\r\n\r\nexport async function oauth2VariableReplacer(text: unknown, type: string, context: ProcessorContext): Promise<unknown> {\r\n  if (type.toLowerCase() === 'authorization' && utils.isString(text)) {\r\n    const match = ParserRegex.auth.oauth2.exec(text);\r\n    if (match && match.groups) {\r\n      const flow = match.groups.flow || 'client_credentials';\r\n      const config = oauth.getOpenIdConfiguration(match.groups.variablePrefix || 'oauth2', context.variables);\r\n      const tokenExchangeConfig = oauth.getOpenIdConfiguration(match.groups.tokenExchangePrefix, context.variables);\r\n\r\n      const openIdFlow = getOpenIdFlow(flow);\r\n      if (openIdFlow && config) {\r\n        const cacheKey = openIdFlow.getCacheKey(config);\r\n        if (cacheKey) {\r\n          let openIdInformation = getSessionOpenIdInformation(cacheKey, tokenExchangeConfig || config);\r\n          userSessionStore.removeUserSession(cacheKey);\r\n          if (openIdInformation) {\r\n            log.trace(`openid refresh token flow used: ${cacheKey}`);\r\n            openIdInformation = await oauth.refreshTokenFlow.perform(openIdInformation, context);\r\n          }\r\n          if (!openIdInformation) {\r\n            log.trace(`openid flow ${flow} used: ${cacheKey}`);\r\n            openIdInformation = await openIdFlow.perform(config, context);\r\n            if (openIdInformation && tokenExchangeConfig) {\r\n              openIdInformation = await oauth.TokenExchangeFlow.perform(tokenExchangeConfig, openIdInformation, context);\r\n            }\r\n          }\r\n          if (openIdInformation) {\r\n            log.trace(`openid flow ${flow} finished`);\r\n            context.variables.oauth2Session = openIdInformation;\r\n            userSessionStore.setUserSession(openIdInformation);\r\n            keepAlive(cacheKey, context.httpClient);\r\n            return `Bearer ${openIdInformation.accessToken}`;\r\n          }\r\n        }\r\n        return HookCancel;\r\n      }\r\n    }\r\n  }\r\n  return text;\r\n}\r\n\r\nfunction getSessionOpenIdInformation(cacheKey: string, config: oauth.OpenIdConfiguration): oauth.OpenIdInformation | false {\r\n  const openIdInformation = userSessionStore.userSessions.find(obj => obj.id === cacheKey);\r\n  if (isOpenIdInformation(openIdInformation) && JSON.stringify(openIdInformation.config) === JSON.stringify(config)) {\r\n    return openIdInformation;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isOpenIdInformation(userSession: UserSession | undefined): userSession is oauth.OpenIdInformation {\r\n  const guard = userSession as oauth.OpenIdInformation;\r\n  return !!guard?.accessToken;\r\n}\r\n\r\nfunction getOpenIdFlow(flowType: string) {\r\n  const openIdFlows: Array<oauth.OpenIdFlow> = [\r\n    oauth.authorizationCodeFlow,\r\n    oauth.clientCredentialsFlow,\r\n    oauth.deviceCodeFlow,\r\n    oauth.passwordFlow,\r\n    oauth.implicitFlow\r\n  ];\r\n  return openIdFlows.find(flow => flow.supportsFlow(flowType));\r\n}\r\n\r\nfunction keepAlive(cacheKey: string, httpClient: HttpClient) {\r\n  const openIdInformation = userSessionStore.userSessions.find(obj => obj.id === cacheKey);\r\n  if (isOpenIdInformation(openIdInformation) && openIdInformation.refreshToken && openIdInformation.config.keepAlive) {\r\n    const timeoutId = setTimeout(async () => {\r\n      const result = await oauth.refreshTokenFlow.perform(openIdInformation, { httpClient });\r\n      if (result) {\r\n        log.trace(`token ${result.title} refreshed`);\r\n        userSessionStore.setUserSession(result);\r\n        keepAlive(cacheKey, httpClient);\r\n      }\r\n    }, (openIdInformation.expiresIn - openIdInformation.timeSkew) * 1000);\r\n    openIdInformation.delete = () => clearTimeout(timeoutId);\r\n  }\r\n}\r\n", "import { v4 as uuidv4 } from 'uuid';\r\nimport dayjs, { OpUnitType } from 'dayjs';\r\nimport utc from 'dayjs/plugin/utc';\r\nimport { ProcessorContext, VariableType } from '../../models';\r\nimport { isString } from '../../utils';\r\nimport { ParserRegex } from '../../parser';\r\n\r\n\r\ndayjs.extend(utc);\r\n\r\nexport async function restClientVariableReplacer(text: unknown, _type: VariableType | string, { variables }: ProcessorContext): Promise<unknown> {\r\n  if (!isString(text)) {\r\n    return text;\r\n  }\r\n  let match: RegExpExecArray | null;\r\n  let result = text;\r\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(text)) !== null) {\r\n    const [searchValue, variable] = match;\r\n\r\n    const trimmedVariable = variable.trim();\r\n    let replacement: unknown = null;\r\n    if (trimmedVariable === '$guid') {\r\n      replacement = uuidv4();\r\n    } else if (trimmedVariable.startsWith('$randomInt')) {\r\n      const valMatch = /^\\$randomInt\\s*(?<min>-?\\d+)?\\s*(?<max>-?\\d+)?\\s*$/u.exec(trimmedVariable);\r\n      if (valMatch && valMatch.groups?.min && valMatch.groups?.max) {\r\n        let min = Number(valMatch.groups?.min);\r\n        let max = Number(valMatch.groups?.max);\r\n\r\n        if (!Number.isNaN(min) && !Number.isNaN(max)) {\r\n          if (min > max) {\r\n            const temp = max;\r\n            max = min;\r\n            min = temp;\r\n          }\r\n          replacement = `${(Math.floor(Math.random() * (max - min)) + min)}`;\r\n        }\r\n      }\r\n    } else if (trimmedVariable.startsWith('$timestamp')) {\r\n      const valMatch = /^\\$timestamp(?:\\s(?<offset>-?\\d+)\\s(?<option>y|Q|M|w|d|h|m|s|ms))?/u.exec(trimmedVariable);\r\n      if (valMatch) {\r\n        dayjs.extend(utc);\r\n\r\n        let date = dayjs.utc();\r\n        if (valMatch.groups?.offset && valMatch.groups?.option) {\r\n          date = date.add(Number(valMatch.groups.offset), valMatch.groups.option as OpUnitType);\r\n        }\r\n        replacement = `${date.unix()}`;\r\n      }\r\n\r\n    } else if (trimmedVariable.startsWith('$datetime')) {\r\n      const valMatch = /^\\$datetime\\s(?<type>rfc1123|iso8601|'.+'|\".+\")(?:\\s(?<offset>-?\\d+)\\s(?<option>y|Q|M|w|d|h|m|s|ms))?/u.exec(trimmedVariable);\r\n      if (valMatch?.groups?.type) {\r\n        let date = dayjs.utc();\r\n        if (valMatch.groups?.offset && valMatch.groups?.option) {\r\n          date = date.add(Number(valMatch.groups.offset), valMatch.groups.option as OpUnitType);\r\n        }\r\n\r\n        if (valMatch.groups.type === 'rfc1123') {\r\n          replacement = date.toDate().toUTCString();\r\n        } else if (valMatch.groups.type === 'iso8601') {\r\n          replacement = date.toISOString();\r\n        } else {\r\n          replacement = date.format(valMatch.groups.type.slice(1, valMatch.groups.type.length - 1));\r\n        }\r\n      }\r\n    } else if (trimmedVariable.startsWith('$localDatetime')) {\r\n      const valMatch = /^\\$localDatetime\\s(?<type>rfc1123|iso8601|'.+'|\".+\")(?:\\s(?<offset>-?\\d+)\\s(?<option>y|Q|M|w|d|h|m|s|ms))?/u.exec(trimmedVariable);\r\n      if (valMatch?.groups?.type) {\r\n        let date = dayjs.utc().local();\r\n        if (valMatch.groups?.offset && valMatch.groups?.option) {\r\n          date = date.add(Number(valMatch.groups.offset), valMatch.groups.option as OpUnitType);\r\n        }\r\n\r\n        if (valMatch.groups.type === 'rfc1123') {\r\n          replacement = date.locale('en').format('ddd, DD MMM YYYY HH:mm:ss ZZ');\r\n        } else if (valMatch.groups.type === 'iso8601') {\r\n          replacement = date.format();\r\n        } else {\r\n          replacement = date.format(valMatch.groups.type.slice(1, valMatch.groups.type.length - 1));\r\n        }\r\n      }\r\n    } else if (trimmedVariable.startsWith('$processEnv')) {\r\n      replacement = process.env[trimmedVariable.slice('$processEnv'.length).trim()];\r\n    } else if (trimmedVariable.startsWith('$dotenv')) {\r\n      replacement = variables[trimmedVariable.slice('$dotenv'.length).trim()];\r\n    }\r\n\r\n    if (replacement) {\r\n      result = result.replace(searchValue, `${replacement}`);\r\n    }\r\n  }\r\n  return result;\r\n\r\n}\r\n", "import { HookCancel } from '../../models';\r\nimport { userInteractionProvider } from '../../io';\r\nimport { isString } from '../../utils';\r\nimport { ParserRegex } from '../../parser';\r\n\r\nconst lastValue: Record<string, string> = {};\r\n\r\n\r\nexport async function showInputBoxVariableReplacer(text: unknown): Promise<unknown> {\r\n  if (!isString(text)) {\r\n    return text;\r\n  }\r\n  let match: RegExpExecArray | null;\r\n  let result = text;\r\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(text)) !== null) {\r\n    const [searchValue, variable] = match;\r\n\r\n    const matchInput = /^\\$input\\s*(?<placeholder>[^$]*)(\\$value:\\s*(?<value>.*))?\\s*$/u.exec(variable);\r\n    if (matchInput?.groups?.placeholder) {\r\n\r\n      const placeholder = matchInput.groups.placeholder;\r\n\r\n      const answer = await userInteractionProvider.showInputPrompt(placeholder, lastValue[placeholder] || matchInput.groups.value);\r\n\r\n      if (answer) {\r\n        lastValue[placeholder] = answer;\r\n        result = result.replace(searchValue, `${answer}`);\r\n      } else {\r\n        return HookCancel;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n", "import { HookCancel } from '../../models';\r\nimport { userInteractionProvider } from '../../io';\r\nimport { isString } from '../../utils';\r\nimport { ParserRegex } from '../../parser';\r\n\r\n\r\nexport async function showQuickpickVariableReplacer(text: unknown): Promise<unknown> {\r\n  if (!isString(text)) {\r\n    return text;\r\n  }\r\n  let match: RegExpExecArray | null;\r\n  let result = text;\r\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(result)) !== null) {\r\n    const [searchValue, variable] = match;\r\n\r\n    const matchInput = /^\\$pick\\s*(?<placeholder>[^$]*)(\\$value:\\s*(?<value>.*))\\s*$/u.exec(variable);\r\n    if (matchInput?.groups?.placeholder && matchInput?.groups?.value) {\r\n\r\n      const placeholder = matchInput.groups.placeholder;\r\n      const value = matchInput.groups.value;\r\n\r\n      const answer = await userInteractionProvider.showListPrompt(placeholder, value.split(','));\r\n      if (answer && result) {\r\n        result = result.replace(searchValue, `${answer}`);\r\n      } else {\r\n        return HookCancel;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n", "import { ReplaceVariableHook } from '../../models';\r\nimport { awsAuthVariableReplacer } from './awsAuthVariableReplacer';\r\nimport { basicAuthVariableReplacer } from './basicAuthVariableReplacer';\r\nimport { clientCertVariableReplacer } from './clientCertVariableReplacer';\r\nimport { digestAuthVariableReplacer } from './digestAuthVariableReplacer';\r\nimport { escapeVariableReplacer } from './escapeVariableReplacer';\r\nimport { hostVariableReplacer } from './hostVariableReplacer';\r\nimport { intellijVariableReplacer } from './intellijVariableReplacer';\r\nimport { javascriptVariableReplacer } from './javascriptVariableReplacer';\r\nimport { oauth2VariableReplacer } from './oauth2VariableReplacer';\r\nimport { restClientVariableReplacer } from './restClientVariableReplacer';\r\nimport { showInputBoxVariableReplacer } from './showInputBoxVariableReplacer';\r\nimport { showQuickpickVariableReplacer } from './showQuickpickVariableReplacer';\r\n\r\n\r\nexport enum VariableReplacerType{\r\n  aws = 'aws',\r\n  basicAuth = 'basicAuth',\r\n  clientCertificate = 'clientCertificate',\r\n  digestAuth = 'digestAuth',\r\n  escape = 'escape',\r\n  oauth2 = 'oauth2',\r\n  host = 'host',\r\n  intellijDynamic = 'intellijDynamic',\r\n  restClientDynamic = 'restClientDynamic',\r\n  javascript = 'javascript',\r\n  showInputBox = 'showInputBox',\r\n  showQuickPick = 'showQuickPick'\r\n}\r\n\r\nexport function initReplaceVariableHook(): ReplaceVariableHook {\r\n  const hook = new ReplaceVariableHook();\r\n\r\n  hook.addHook(VariableReplacerType.showInputBox, showInputBoxVariableReplacer);\r\n  hook.addHook(VariableReplacerType.showQuickPick, showQuickpickVariableReplacer);\r\n  hook.addHook(VariableReplacerType.restClientDynamic, restClientVariableReplacer);\r\n  hook.addHook(VariableReplacerType.intellijDynamic, intellijVariableReplacer);\r\n  hook.addHook(VariableReplacerType.host, hostVariableReplacer);\r\n  hook.addHook(VariableReplacerType.javascript, javascriptVariableReplacer);\r\n  hook.addHook(VariableReplacerType.oauth2, oauth2VariableReplacer);\r\n  hook.addHook(VariableReplacerType.aws, awsAuthVariableReplacer);\r\n  hook.addHook(VariableReplacerType.clientCertificate, clientCertVariableReplacer);\r\n  hook.addHook(VariableReplacerType.basicAuth, basicAuthVariableReplacer);\r\n  hook.addHook(VariableReplacerType.digestAuth, digestAuthVariableReplacer);\r\n  hook.addHook(VariableReplacerType.escape, escapeVariableReplacer);\r\n\r\n  return hook;\r\n}\r\n", "import * as models from '../models';\r\nimport { initParseEndHook, initParseHook, parseHttpFile } from '../parser';\r\nimport { fileProvider, log, userInteractionProvider } from '../io';\r\nimport { initOnRequestHook, initOnResponseHook } from '../actions';\r\nimport { userSessionStore as sessionStore } from '../store';\r\nimport { replacer, provider } from '../variables';\r\nimport * as utils from '../utils';\r\nimport merge from 'lodash/merge';\r\nimport { default as chalk } from 'chalk';\r\nimport { HookCancel } from '../models';\r\n\r\ninterface HttpFileStoreEntry{\r\n  version: number;\r\n  cacheKey: string;\r\n  httpFile?: models.HttpFile;\r\n  promise?: Promise<models.HttpFile>\r\n}\r\n\r\nexport type HttpFileStoreOptions = Omit<models.ParseOptions, 'httpFileStore'>\r\n\r\nexport class HttpFileStore {\r\n  private readonly storeCache: Array<HttpFileStoreEntry> = [];\r\n\r\n  private getFromStore(fileName: models.PathLike, version: number) {\r\n    const cacheKey = fileProvider.toString(fileName);\r\n    let httpFileStoreEntry = this.storeCache.find(obj => obj.cacheKey === cacheKey);\r\n    if (!httpFileStoreEntry) {\r\n      httpFileStoreEntry = {\r\n        cacheKey,\r\n        version,\r\n      };\r\n      this.storeCache.push(httpFileStoreEntry);\r\n    }\r\n    return httpFileStoreEntry;\r\n  }\r\n\r\n  get(fileName: models.PathLike): models.HttpFile | undefined {\r\n    const cacheKey = fileProvider.toString(fileName);\r\n    return this.storeCache.find(obj => obj.cacheKey === cacheKey)?.httpFile;\r\n  }\r\n\r\n  getAll(): Array<models.HttpFile> {\r\n    const result: Array<models.HttpFile> = [];\r\n    for (const store of this.storeCache) {\r\n      if (store.httpFile) {\r\n        result.push(store.httpFile);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getOrCreate(fileName: models.PathLike, getText: () => Promise<string>, version: number, options: HttpFileStoreOptions): Promise<models.HttpFile> {\r\n    const httpFileStoreEntry: HttpFileStoreEntry = this.getFromStore(fileName, version);\r\n    if (version > httpFileStoreEntry.version || !httpFileStoreEntry.httpFile) {\r\n      if (httpFileStoreEntry.promise\r\n        && version <= httpFileStoreEntry.version) {\r\n        return httpFileStoreEntry.promise;\r\n      }\r\n\r\n      httpFileStoreEntry.promise = getText()\r\n        .then(text => this.parse(fileName, text, options))\r\n        .then(httpFile => {\r\n          delete httpFileStoreEntry.promise;\r\n          if (httpFileStoreEntry.httpFile) {\r\n            for (const httpRegion of httpFile.httpRegions) {\r\n              const prevHttpRegion = httpFileStoreEntry.httpFile.httpRegions\r\n                .find(obj => obj.symbol.source === httpRegion.symbol.source);\r\n              if (prevHttpRegion) {\r\n                httpRegion.variablesPerEnv = prevHttpRegion.variablesPerEnv;\r\n              }\r\n            }\r\n            httpFile.activeEnvironment = httpFileStoreEntry.httpFile.activeEnvironment;\r\n          }\r\n          httpFileStoreEntry.version = version;\r\n          httpFileStoreEntry.httpFile = httpFile;\r\n          return httpFile;\r\n        })\r\n        .catch(err => {\r\n          delete httpFileStoreEntry.promise;\r\n          if (httpFileStoreEntry.httpFile) {\r\n            this.remove(httpFileStoreEntry.httpFile.fileName);\r\n          }\r\n          throw err;\r\n        });\r\n      return httpFileStoreEntry.promise;\r\n    }\r\n    return httpFileStoreEntry.promise || Promise.resolve(httpFileStoreEntry.httpFile);\r\n  }\r\n\r\n  async parse(fileName: models.PathLike, text: string, options: HttpFileStoreOptions): Promise<models.HttpFile> {\r\n    const httpFile = await this.initHttpFile(fileName, options);\r\n    return await parseHttpFile(httpFile, text, this);\r\n  }\r\n\r\n  remove(fileName: models.PathLike): void {\r\n    const cacheKey = fileProvider.toString(fileName);\r\n    const index = this.storeCache.findIndex(obj => obj.cacheKey === cacheKey);\r\n    if (index >= 0) {\r\n      this.storeCache.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  rename(oldFileName: models.PathLike, newFileName: models.PathLike) : void {\r\n    const oldCacheKey = fileProvider.toString(oldFileName);\r\n    const httpFileStoreEntry = this.storeCache.find(obj => obj.cacheKey === oldCacheKey);\r\n    if (httpFileStoreEntry) {\r\n      httpFileStoreEntry.cacheKey = fileProvider.toString(newFileName);\r\n      if (httpFileStoreEntry.httpFile) {\r\n        httpFileStoreEntry.httpFile.fileName = newFileName;\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() : void {\r\n    this.storeCache.length = 0;\r\n  }\r\n\r\n  private async initHttpFile(fileName: models.PathLike, options: HttpFileStoreOptions) {\r\n    const rootDir = await utils.findRootDirOfFile(fileName, options.workingDir,\r\n      'package.json', ...utils.defaultConfigFiles, options.config?.envDirName || 'env');\r\n\r\n    const httpFile: models.HttpFile = {\r\n      fileName,\r\n      rootDir,\r\n      hooks: {\r\n        parse: initParseHook(),\r\n        parseEndRegion: initParseEndHook(),\r\n        replaceVariable: replacer.initReplaceVariableHook(),\r\n        provideEnvironments: provider.initProvideEnvironmentsHook(),\r\n        provideVariables: provider.initProvideVariablesHook(),\r\n        onRequest: initOnRequestHook(),\r\n        onResponse: initOnResponseHook(),\r\n        responseLogging: new models.ResponseLoggingHook(),\r\n      },\r\n      httpRegions: [],\r\n      activeEnvironment: options.activeEnvironment\r\n    };\r\n\r\n    options.config = await getEnviromentConfig(options.config, httpFile.rootDir);\r\n\r\n    const hooks: Record<string, models.ConfigureHooks> = {};\r\n    if (rootDir) {\r\n      Object.assign(hooks, await utils.getPlugins(rootDir));\r\n      if (options.config?.configureHooks) {\r\n        hooks['.httpyac.js'] = options.config.configureHooks;\r\n      }\r\n    }\r\n    const envPluginLocation = process.env.HTTPYAC_PLUGIN;\r\n    if (envPluginLocation) {\r\n      try {\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        const envHook = require(envPluginLocation);\r\n        if (envHook.configureHooks) {\r\n          hooks.HTTPYAC_PLUGIN = envHook.configureHooks;\r\n        }\r\n      } catch (err) {\r\n        log.warn('Global Hook Plugin not loaded', err);\r\n      }\r\n    }\r\n    await this.configureHooks(httpFile, options, hooks);\r\n    return httpFile;\r\n  }\r\n\r\n  private async configureHooks(httpFile: models.HttpFile, options: HttpFileStoreOptions, hooks: Record<string, models.ConfigureHooks>) {\r\n    if (options.config) {\r\n      const api: models.HttpyacHooksApi = {\r\n        version: '1.0.0',\r\n        rootDir: httpFile.rootDir,\r\n        config: options.config,\r\n        httpFile,\r\n        hooks: httpFile.hooks,\r\n        log,\r\n        fileProvider,\r\n        sessionStore,\r\n        userInteractionProvider,\r\n        getHookCancel: () => HookCancel,\r\n      };\r\n      for (const [plugin, hook] of Object.entries(hooks)) {\r\n        try {\r\n          log.trace(`load ${plugin}`);\r\n          const result = hook(api);\r\n          if (utils.isPromise(result)) {\r\n            await result;\r\n          }\r\n        } catch (err) {\r\n          log.error(`error in ${plugin}`, err);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport async function getEnviromentConfig(config?: models.EnvironmentConfig, rootDir?: models.PathLike) : Promise<models.EnvironmentConfig> {\r\n  const environmentConfigs : Array<models.EnvironmentConfig> = [];\r\n  if (rootDir) {\r\n    const fileConfig = await utils.getHttpacConfig(rootDir);\r\n    if (fileConfig) {\r\n      environmentConfigs.push(fileConfig);\r\n    }\r\n  }\r\n  if (config) {\r\n    environmentConfigs.push(config);\r\n  }\r\n\r\n  const result = merge({\r\n    log: {\r\n      level: models.LogLevel.warn,\r\n      supportAnsiColors: true,\r\n    },\r\n    cookieJarEnabled: true,\r\n    envDirName: 'env',\r\n  }, ...environmentConfigs);\r\n\r\n  refreshStaticConfig(result);\r\n  return result;\r\n}\r\n\r\nfunction refreshStaticConfig(config: models.EnvironmentConfig) {\r\n  log.options.level = config?.log?.level ?? models.LogLevel.warn;\r\n  if (config?.log?.supportAnsiColors === false) {\r\n    chalk.level = 0;\r\n  }\r\n}\r\n", "import { UserSession, SessionStore, Dispose } from '../models';\r\n\r\n\r\nexport class UserSessionStore implements SessionStore {\r\n\r\n  readonly userSessions: Array<UserSession> = [];\r\n\r\n  private readonly sessionChangedListener: Array<() => void> = [];\r\n\r\n  onSessionChanged(listener: () => void) : Dispose {\r\n    this.sessionChangedListener.push(listener);\r\n\r\n    return () => {\r\n      const index = this.sessionChangedListener.indexOf(listener);\r\n      if (index >= 0) {\r\n        this.sessionChangedListener.splice(index, 1);\r\n      }\r\n    };\r\n  }\r\n\r\n\r\n  async reset() : Promise<void> {\r\n    for (const userSession of this.userSessions) {\r\n      if (userSession.delete) {\r\n        userSession.delete();\r\n      }\r\n    }\r\n    this.userSessions.length = 0;\r\n    this.notifySessionChanged();\r\n  }\r\n\r\n  getUserSession(id: string) : UserSession | undefined {\r\n    return this.userSessions.find(obj => obj.id === id);\r\n  }\r\n\r\n  setUserSession(userSession: UserSession) : void {\r\n    this.removeUserSession(userSession.id);\r\n    this.userSessions.push(userSession);\r\n    this.notifySessionChanged();\r\n  }\r\n\r\n  private notifySessionChanged() {\r\n    for (const listener of this.sessionChangedListener) {\r\n      listener();\r\n    }\r\n  }\r\n\r\n  removeUserSession(id: string) : void {\r\n    const userSession = this.userSessions.find(obj => obj.id === id);\r\n    if (userSession) {\r\n      if (userSession.delete) {\r\n        userSession.delete();\r\n      }\r\n      this.userSessions.splice(this.userSessions.indexOf(userSession), 1);\r\n      this.notifySessionChanged();\r\n    }\r\n  }\r\n\r\n  isUserSession(obj: unknown): obj is UserSession {\r\n    const session = obj as UserSession;\r\n    return session\r\n      && !!session.description\r\n      && !!session.id\r\n      && !!session.title\r\n      && !!session.type\r\n      && !!session.details;\r\n  }\r\n}\r\n\r\nexport const userSessionStore = new UserSessionStore();\r\n", "import { initHttpClient, log } from './io';\r\nimport * as models from './models';\r\nimport * as utils from './utils';\r\nimport { getEnviromentConfig } from './store';\r\n\r\n\r\n/**\r\n   * process one httpRegion of HttpFile\r\n   * @param httpFile httpFile\r\n   */\r\nexport async function send(context: models.SendContext): Promise<boolean> {\r\n  let result = false;\r\n  if (utils.isHttpRegionSendContext(context)) {\r\n    result = await sendHttpRegion(context);\r\n  } else if (utils.isHttpRegionsSendContext(context)) {\r\n    result = await sendHttpRegions(context);\r\n  } else {\r\n    result = await sendHttpFile(context);\r\n  }\r\n  return result;\r\n}\r\n\r\nasync function sendHttpRegion(context: models.HttpRegionSendContext): Promise<boolean> {\r\n  if (!context.httpRegion.metaData.disabled) {\r\n    const processorContext = await createEmptyProcessorContext(context);\r\n    if (await utils.executeGlobalScripts(processorContext)) {\r\n      return await utils.processHttpRegionActions(processorContext, true);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nasync function sendHttpRegions(context: models.HttpRegionsSendContext): Promise<boolean> {\r\n  const processorContext = await createEmptyProcessorContext(context);\r\n  if (await utils.executeGlobalScripts(processorContext)) {\r\n    for (const httpRegion of context.httpRegions) {\r\n      if (!httpRegion.metaData.disabled) {\r\n        const regionProcessorContext: models.ProcessorContext = {\r\n          ...processorContext,\r\n          httpRegion,\r\n        };\r\n        if (!await utils.processHttpRegionActions(regionProcessorContext, false)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nasync function sendHttpFile(context: models.HttpFileSendContext): Promise<boolean> {\r\n  const processorContext = await createEmptyProcessorContext(context);\r\n  for (const httpRegion of context.httpFile.httpRegions) {\r\n    if (httpRegion.metaData.disabled) {\r\n      log.debug(`${httpRegion.symbol.name} is disabled`);\r\n      continue;\r\n    }\r\n    if (httpRegion.request && context.httpRegionPredicate && !context.httpRegionPredicate(httpRegion)) {\r\n      log.debug(`${httpRegion.symbol.name} disabled by predicate`);\r\n      continue;\r\n    }\r\n    const regionProcessorContext = {\r\n      ...processorContext,\r\n      httpRegion,\r\n    };\r\n    await utils.processHttpRegionActions(regionProcessorContext);\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\nasync function createEmptyProcessorContext<T extends models.VariableProviderContext>(context: T): Promise<T & {\r\n  variables: models.Variables,\r\n  httpClient: models.HttpClient,\r\n  options: Record<string, unknown>\r\n}> {\r\n  return Object.assign(context, {\r\n    variables: await getVariables(context),\r\n    httpClient: initHttpClient(context),\r\n    options: {}\r\n  });\r\n}\r\n\r\n\r\nexport async function getVariables(context: models.VariableProviderContext): Promise<Record<string, unknown>> {\r\n  context.config = await getEnviromentConfig(context.config, context.httpFile?.rootDir);\r\n\r\n  const vars = (await context.httpFile.hooks.provideVariables.trigger(context.httpFile.activeEnvironment, context));\r\n  if (vars === models.HookCancel) {\r\n    return {};\r\n  }\r\n  const variables = Object.assign(\r\n    {},\r\n    ...vars\r\n  );\r\n  log.debug(variables);\r\n  return variables;\r\n}\r\n\r\n\r\nexport async function getEnvironments(context: models.VariableProviderContext): Promise<Array<string>> {\r\n  context.config = await getEnviromentConfig(context.config, context.httpFile?.rootDir);\r\n\r\n  const result = (await context.httpFile.hooks.provideEnvironments.trigger(context));\r\n  if (result !== models.HookCancel && result.length > 0) {\r\n    return result.reduce((prev, current) => {\r\n      for (const cur of current) {\r\n        if (prev.indexOf(cur) < 0) {\r\n          prev.push(cur);\r\n        }\r\n      }\r\n      return prev;\r\n    }, [] as Array<string>).sort();\r\n  }\r\n  return [];\r\n}\r\n", "export * from './cli';\r\n", "import inquirer from 'inquirer';\r\nimport { promises as fs } from 'fs';\r\nimport { join } from 'path';\r\nimport * as models from '../models';\r\nimport { HttpFileStore, HttpFileStoreOptions } from '../store';\r\nimport { send } from '../httpYacApi';\r\nimport * as utils from '../utils';\r\nimport { default as globby } from 'globby';\r\nimport { fileProvider, Logger } from '../io';\r\nimport { CliOptions, parseCliOptions, renderHelp, getLogLevel, CliFilterOptions } from './cliOptions';\r\nimport { CliContext } from './cliContext';\r\nimport { toCliJsonOutput } from './cliJsonOutput';\r\nimport { initIOProvider } from './initCliProvider';\r\nimport { default as chalk } from 'chalk';\r\n\r\n\r\nexport async function execute(rawArgs: string[]): Promise<void> {\r\n  initIOProvider();\r\n  const cliOptions = parseCliOptions(rawArgs);\r\n  if (!cliOptions) {\r\n    return;\r\n  }\r\n  if (cliOptions.version) {\r\n    const packageJson = await utils.parseJson<Record<string, string>>(join(__dirname, '../package.json'));\r\n    console.info(`httpyac v${packageJson?.version}`);\r\n    return;\r\n  }\r\n  if (cliOptions.help) {\r\n    renderHelp();\r\n    return;\r\n  }\r\n\r\n  if (process.platform === 'win32') {\r\n    // https://github.com/nodejs/node-v0.x-archive/issues/7940\r\n    models.testSymbols.ok = '[x]';\r\n    models.testSymbols.error = '[-]';\r\n  }\r\n\r\n  try {\r\n    const context = convertCliOptionsToContext(cliOptions);\r\n    const httpFiles: models.HttpFile[] = await getHttpFiles(cliOptions, context.config);\r\n\r\n    if (httpFiles.length > 0) {\r\n      let isFirstRequest = true;\r\n      const jsonOutput: Record<string, Array<models.HttpRegion>> = {};\r\n      while (cliOptions.interactive || isFirstRequest) {\r\n        const selection = await selectAction(httpFiles, cliOptions);\r\n\r\n        const processedHttpRegions: Array<models.HttpRegion> = [];\r\n\r\n        if (selection) {\r\n          await send(Object.assign({ processedHttpRegions }, context, selection));\r\n          jsonOutput[fileProvider.toString(selection.httpFile.fileName)] = [...processedHttpRegions];\r\n        } else {\r\n          for (const httpFile of httpFiles) {\r\n            if (!cliOptions.json && context.scriptConsole && httpFiles.length > 1) {\r\n              context.scriptConsole.info(`--------------------- ${httpFile.fileName}  --`);\r\n            }\r\n            await send(Object.assign({ processedHttpRegions }, context, { httpFile }));\r\n            jsonOutput[fileProvider.toString(httpFile.fileName)] = [...processedHttpRegions];\r\n            processedHttpRegions.length = 0;\r\n          }\r\n        }\r\n        isFirstRequest = false;\r\n\r\n        if (cliOptions.json\r\n          || Object.keys(jsonOutput).length > 1\r\n          || Object.entries(jsonOutput).some(([, httpRegions]) => httpRegions.length > 1)) {\r\n          const cliJsonOutput = toCliJsonOutput(jsonOutput, cliOptions);\r\n          if (cliOptions.json) {\r\n            console.info(JSON.stringify(cliJsonOutput, null, 2));\r\n          } else if (context.scriptConsole) {\r\n            context.scriptConsole.info('');\r\n            context.scriptConsole.info(chalk`{bold ${cliJsonOutput.summary.totalRequests}} requests tested ({green ${cliJsonOutput.summary.successRequests} succeeded}, {red ${cliJsonOutput.summary.failedRequests} failed})`);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      console.error(`httpYac cannot find the specified file ${cliOptions.fileName}.`);\r\n      return;\r\n    }\r\n  } catch (err) {\r\n    console.error(err);\r\n    if (!process.exitCode) {\r\n      process.exitCode = 1;\r\n    }\r\n    throw err;\r\n  } finally {\r\n\r\n    // needed because of async\r\n    // eslint-disable-next-line node/no-process-exit\r\n    process.exit();\r\n  }\r\n}\r\n\r\nfunction convertCliOptionsToContext(cliOptions: CliOptions): CliContext {\r\n  const context: CliContext = {\r\n    repeat: cliOptions.repeat,\r\n    scriptConsole: new Logger({\r\n      level: getLogLevel(cliOptions),\r\n      onlyFailedTests: cliOptions.filter === CliFilterOptions.onlyFailed\r\n    }),\r\n    config: {\r\n      log: {\r\n        level: getLogLevel(cliOptions),\r\n      },\r\n      request: {\r\n        timeout: cliOptions.requestTimeout,\r\n        https: {\r\n          rejectUnauthorized: cliOptions.rejectUnauthorized\r\n        }\r\n      }\r\n    },\r\n    logStream: cliOptions.json ? undefined : getStreamLogger(cliOptions),\r\n    logResponse: cliOptions.json ? undefined : getRequestLogger(cliOptions),\r\n  };\r\n\r\n  return context;\r\n}\r\n\r\nfunction initCliHooks(httpFiles: Array<models.HttpFile>, cliOptions: CliOptions) {\r\n  if (httpFiles.length > 0) {\r\n    if (cliOptions.bail) {\r\n      const bailOnFailedTest = {\r\n        afterTrigger: async function bail(context: models.HookTriggerContext<models.ProcessorContext, boolean>) {\r\n          const failedTest = context.arg.httpRegion.testResults?.find?.(obj => !obj.result);\r\n          if (failedTest) {\r\n            throw failedTest.error || new Error('bail on failed test');\r\n          }\r\n          return true;\r\n        }\r\n      };\r\n      for (const httpFile of httpFiles) {\r\n        httpFile.httpRegions.forEach(httpRegion => httpRegion.hooks.execute.addInterceptor(bailOnFailedTest));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nasync function getHttpFiles(options: CliOptions, config: models.EnvironmentConfig | undefined) {\r\n  const httpFiles: models.HttpFile[] = [];\r\n  const httpFileStore = new HttpFileStore();\r\n\r\n  const parseOptions: HttpFileStoreOptions = {\r\n    workingDir: process.cwd(),\r\n    activeEnvironment: options.activeEnvironments,\r\n    config\r\n  };\r\n  if (options.editor) {\r\n    const answer = await inquirer.prompt([{\r\n      type: 'editor',\r\n      message: 'input http request',\r\n      name: 'httpFile'\r\n    }]);\r\n    const file = await httpFileStore.getOrCreate(process.cwd(), async () => answer.httpFile, 0, parseOptions);\r\n    httpFiles.push(file);\r\n  } else if (options.fileName) {\r\n    const paths = await globby(options.fileName, {\r\n      expandDirectories: {\r\n        files: ['*.rest', '*.http'],\r\n        extensions: ['http', 'rest']\r\n      }\r\n    });\r\n\r\n    for (const path of paths) {\r\n      const httpFile = await httpFileStore.getOrCreate(path, async () => await fs.readFile(path, 'utf8'), 0, parseOptions);\r\n      httpFiles.push(httpFile);\r\n    }\r\n  }\r\n\r\n  initCliHooks(httpFiles, options);\r\n  return httpFiles;\r\n}\r\n\r\n\r\ntype SelectActionResult = { httpRegion?: models.HttpRegion | undefined, httpFile: models.HttpFile } | false;\r\n\r\nasync function selectAction(httpFiles: models.HttpFile[], cliOptions: CliOptions): Promise<SelectActionResult> {\r\n  if (httpFiles.length === 1) {\r\n    const httpFile = httpFiles[0];\r\n    const httpRegion = getHttpRegion(httpFile, cliOptions);\r\n    if (httpRegion) {\r\n      return {\r\n        httpFile,\r\n        httpRegion\r\n      };\r\n    }\r\n  }\r\n\r\n  if (!cliOptions.allRegions) {\r\n    const httpRegionMap: Record<string, { httpRegion?: models.HttpRegion | undefined, httpFile: models.HttpFile }> = {};\r\n    const hasManyFiles = httpFiles.length > 1;\r\n    for (const httpFile of httpFiles) {\r\n      httpRegionMap[hasManyFiles ? `${httpFile.fileName}: all` : 'all'] = { httpFile };\r\n\r\n      for (const httpRegion of httpFile.httpRegions) {\r\n        if (httpRegion.request) {\r\n          const name = httpRegion.symbol.name;\r\n          httpRegionMap[hasManyFiles ? `${httpFile.fileName}: ${name}` : name] = {\r\n            httpRegion,\r\n            httpFile\r\n          };\r\n        }\r\n      }\r\n    }\r\n    const answer = await inquirer.prompt([{\r\n      type: 'list',\r\n      name: 'region',\r\n      message: 'please choose which region to use',\r\n      choices: Object.entries(httpRegionMap).map(([key]) => key),\r\n    }]);\r\n    if (answer.region && httpRegionMap[answer.region]) {\r\n      return httpRegionMap[answer.region];\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getHttpRegion(httpFile: models.HttpFile, cliOptions: CliOptions): models.HttpRegion | false {\r\n  let httpRegion: models.HttpRegion | false = false;\r\n  if (cliOptions.httpRegionName) {\r\n    httpRegion = httpFile.httpRegions.find(obj => obj.metaData.name === cliOptions.httpRegionName) || false;\r\n  } else {\r\n    httpRegion = httpFile.httpRegions\r\n      .find(obj => cliOptions.httpRegionLine\r\n        && obj.symbol.startLine <= cliOptions.httpRegionLine\r\n        && obj.symbol.endLine >= cliOptions.httpRegionLine) || false;\r\n  }\r\n  return httpRegion;\r\n}\r\n\r\nfunction getStreamLogger(options: CliOptions): models.StreamLogger | undefined {\r\n  if (options.output !== 'none') {\r\n    return async function logStream(_channel, type, message) {\r\n      const data = Buffer.isBuffer(message) ? message.toString('utf-8') : message;\r\n      console.info(`${new Date().toLocaleTimeString()} - ${type}: `, data);\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction getRequestLogger(options: CliOptions): models.RequestLogger | undefined {\r\n  const requestLoggerOptions = getRequestLoggerOptions(\r\n    options.output,\r\n    options.filter === CliFilterOptions.onlyFailed,\r\n    !options.raw\r\n  );\r\n  if (requestLoggerOptions) {\r\n    return utils.requestLoggerFactory(\r\n      console.info,\r\n      requestLoggerOptions,\r\n      options.outputFailed ? getRequestLoggerOptions(\r\n        options.outputFailed,\r\n        options.filter === CliFilterOptions.onlyFailed,\r\n        !options.raw\r\n      ) : undefined\r\n    );\r\n  }\r\n  return undefined;\r\n}\r\nfunction getRequestLoggerOptions(\r\n  output: string | undefined,\r\n  onlyFailed: boolean,\r\n  responseBodyPrettyPrint: boolean\r\n): utils.RequestLoggerFactoryOptions | undefined {\r\n  switch (output) {\r\n    case 'body':\r\n      return {\r\n        responseBodyLength: 0,\r\n        responseBodyPrettyPrint,\r\n        onlyFailed\r\n      };\r\n    case 'headers':\r\n      return {\r\n        requestOutput: true,\r\n        requestHeaders: true,\r\n        responseHeaders: true,\r\n        onlyFailed\r\n      };\r\n    case 'response':\r\n      return {\r\n        responseHeaders: true,\r\n        responseBodyPrettyPrint,\r\n        responseBodyLength: 0,\r\n        onlyFailed\r\n      };\r\n    case 'none':\r\n      return undefined;\r\n    case 'short':\r\n      return { useShort: true, onlyFailed };\r\n    case 'exchange':\r\n    default:\r\n      return {\r\n        requestOutput: true,\r\n        requestHeaders: true,\r\n        responseBodyPrettyPrint,\r\n        requestBodyLength: 0,\r\n        responseHeaders: true,\r\n        responseBodyLength: 0,\r\n        onlyFailed\r\n      };\r\n  }\r\n}\r\n", "import arg from 'arg';\r\nimport { RepeatOptions, RepeatOrder, LogLevel } from '../models';\r\n\r\nexport enum CliFilterOptions{\r\n  onlyFailed = 'only-failed',\r\n}\r\n\r\nexport interface CliOptions {\r\n  activeEnvironments?: Array<string>,\r\n  allRegions?: boolean,\r\n  bail?: boolean;\r\n  editor?: boolean;\r\n  fileName?: string,\r\n  filter?: string;\r\n  help?: boolean,\r\n  httpRegionLine?: number,\r\n  httpRegionName?: string,\r\n  interactive?: boolean,\r\n  json?: boolean;\r\n  output?: string,\r\n  outputFailed?: string,\r\n  raw?: boolean,\r\n  rejectUnauthorized?: boolean;\r\n  repeat?: RepeatOptions,\r\n  requestTimeout?: number;\r\n  silent?: boolean;\r\n  verbose?: boolean;\r\n  version?: boolean;\r\n}\r\n\r\nexport function getLogLevel(cliOptions: CliOptions) : LogLevel | undefined {\r\n  if (cliOptions.json) {\r\n    return LogLevel.none;\r\n  }\r\n  if (cliOptions.silent) {\r\n    return LogLevel.error;\r\n  }\r\n  if (cliOptions.verbose) {\r\n    return LogLevel.trace;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport function parseCliOptions(rawArgs: string[]): CliOptions | undefined {\r\n  try {\r\n    const args = arg(\r\n      {\r\n        '--all': Boolean,\r\n        '--bail': Boolean,\r\n        '--editor': Boolean,\r\n        '--env': [String],\r\n        '--filter': String,\r\n        '--help': Boolean,\r\n        '--insecure': Boolean,\r\n        '--interactive': Boolean,\r\n        '--json': Boolean,\r\n        '--line': Number,\r\n        '--name': String,\r\n        '--no-color': Boolean,\r\n        '--output': String,\r\n        '--output-failed': String,\r\n        '--raw': Boolean,\r\n        '--quiet': Boolean,\r\n        '--repeat': Number,\r\n        '--repeat-mode': String,\r\n        '--silent': Boolean,\r\n        '--timeout': Number,\r\n        '--verbose': Boolean,\r\n        '--version': Boolean,\r\n\r\n        '-e': '--env',\r\n        '-h': '--help',\r\n        '-i': '--interactive',\r\n        '-l': '--line',\r\n        '-n': '--name',\r\n        '-o': '--output',\r\n        '-s': '--silent',\r\n        '-v': '--verbose'\r\n      },\r\n      {\r\n        argv: rawArgs.slice(2),\r\n      }\r\n    );\r\n\r\n    return {\r\n      activeEnvironments: args['--env'],\r\n      allRegions: args['--all'],\r\n      bail: args['--bail'],\r\n      editor: args['--editor'],\r\n      fileName: args._.length > 0 ? args._[args._.length - 1] : undefined,\r\n      filter: args['--filter'],\r\n      help: args['--help'],\r\n      httpRegionLine: args['--line'],\r\n      httpRegionName: args['--name'],\r\n      interactive: args['--interactive'],\r\n      json: args['--json'],\r\n      output: args['--output'],\r\n      outputFailed: args['--output-failed'],\r\n      raw: args['--raw'],\r\n      rejectUnauthorized: args['--insecure'] !== undefined ? !args['--insecure'] : undefined,\r\n      repeat: args['--repeat'] ? {\r\n        count: args['--repeat'],\r\n        type: args['--repeat-mode'] === 'sequential' ? RepeatOrder.sequential : RepeatOrder.parallel,\r\n      } : undefined,\r\n      requestTimeout: args['--timeout'],\r\n      silent: args['--silent'],\r\n      verbose: args['--verbose'],\r\n      version: args['--version'],\r\n    };\r\n  } catch (error) {\r\n    if (error instanceof arg.ArgError) {\r\n      console.error(error.message);\r\n    } else {\r\n      console.error(error);\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport function renderHelp() : void {\r\n  const helpMessage = `send http requests of .http or .rest\r\n\r\nusage: httpyac [options...] <file or glob pattern>\r\n       --all           execute all http requests in a http file\r\n       --bail          stops when a test case fails\r\n       --editor        enter a new request and execute it\r\n  -e   --env           list of environemnts\r\n       --filter        filter requests output (only-failed)\r\n  -h   --help          help\r\n       --insecure      allow insecure server connections when using ssl\r\n  -i   --interactive   do not exit the program after request, go back to selection\r\n       --json          use json output\r\n  -l   --line          line of the http requests\r\n  -n   --name          name of the http requests\r\n       --no-color      disable color support\r\n  -o   --output        output format of response (short, body, headers, response, exchange, none)\r\n       --output-failed output format of failed response (short, body, headers, response, exchange, none)\r\n       --raw           prevent formatting of response body\r\n  -r   --repeat        repeat count for requests\r\n       --repeat-mode   repeat mode: sequential, parallel (default)\r\n  -s   --silent        log only request\r\n       --timeout       maximum time allowed for connections\r\n  -v   --verbose       make the operation more talkative\r\n       --version       version of httpyac`;\r\n\r\n  console.info(helpMessage);\r\n}\r\n", "import { HttpRegion, HttpResponse, TestResult } from '../models';\r\nimport { CliFilterOptions, CliOptions } from './cliOptions';\r\n\r\n\r\nexport interface CliJsonOutput {\r\n  _meta: {\r\n    version: string,\r\n  },\r\n  summary: CliRequestSummary & CliTestSummary,\r\n  requests: Array<CliOutputRequest>,\r\n}\r\n\r\nexport interface CliOutputRequest {\r\n  fileName: string;\r\n  name?: string;\r\n  title?: string;\r\n  description?: string;\r\n  line?: number;\r\n  summary: CliTestSummary,\r\n  response: HttpResponse | undefined,\r\n  testResults?: Array<TestResult>\r\n}\r\n\r\nexport interface CliRequestSummary {\r\n  totalRequests: number;\r\n  failedRequests: number;\r\n  successRequests: number;\r\n}\r\n\r\nexport interface CliTestSummary {\r\n  totalTests: number;\r\n  failedTests: number;\r\n  successTests: number;\r\n}\r\n\r\n\r\nfunction sum(x: number, y: number) {\r\n  return x + y;\r\n}\r\n\r\nexport function toCliJsonOutput(context: Record<string, Array<HttpRegion>>, options: CliOptions): CliJsonOutput {\r\n  const requests: Array<CliOutputRequest> = [];\r\n  for (const [fileName, httpRegions] of Object.entries(context)) {\r\n    requests.push(...httpRegions.map(httpRegion => {\r\n      const result: CliOutputRequest = {\r\n        fileName,\r\n        response: convertResponse(\r\n          httpRegion.response,\r\n          options.outputFailed && httpRegion.testResults?.some?.(test => !test.result) ? options.outputFailed : options.output\r\n        ),\r\n        name: httpRegion.metaData?.name,\r\n        title: httpRegion.metaData?.title,\r\n        description: httpRegion.metaData?.description,\r\n        line: httpRegion.symbol.startLine,\r\n        testResults: httpRegion.testResults,\r\n        summary: {\r\n          totalTests: httpRegion.testResults?.length || 0,\r\n          failedTests: httpRegion.testResults?.filter?.(obj => !obj.result).length || 0,\r\n          successTests: httpRegion.testResults?.filter?.(obj => !!obj.result).length || 0,\r\n        }\r\n      };\r\n      return result;\r\n    }));\r\n\r\n  }\r\n  return {\r\n    _meta: {\r\n      version: '1.0.0',\r\n    },\r\n    requests: options.filter === CliFilterOptions.onlyFailed ? requests.filter(obj => obj.summary.failedTests > 0) : requests,\r\n    summary: {\r\n      totalRequests: requests.length,\r\n      failedRequests: requests.filter(obj => obj.summary.failedTests > 0).length,\r\n      successRequests: requests.filter(obj => obj.summary.failedTests === 0).length,\r\n      totalTests: requests.map(obj => obj.summary.totalTests).reduce(sum, 0),\r\n      failedTests: requests.map(obj => obj.summary.failedTests).reduce(sum, 0),\r\n      successTests: requests.map(obj => obj.summary.successTests).reduce(sum, 0),\r\n    }\r\n  };\r\n}\r\n\r\n\r\nfunction convertResponse(response: HttpResponse | undefined, output: string | undefined) {\r\n  if (response) {\r\n    delete response.rawBody;\r\n    delete response.prettyPrintBody;\r\n    delete response.parsedBody;\r\n    delete response.contentType;\r\n\r\n    switch (output) {\r\n      case 'body':\r\n      case 'response':\r\n        delete response.request;\r\n        return response;\r\n      case 'short':\r\n        delete response.body;\r\n        delete response.request;\r\n        return response;\r\n      case 'none':\r\n        return undefined;\r\n      case 'headers':\r\n        delete response.body;\r\n        delete response.request?.body;\r\n        return response;\r\n      case 'exchange':\r\n      default:\r\n        return response;\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n", "import * as models from '../models';\r\nimport { fileProvider, userInteractionProvider } from '../io';\r\nimport { promises as fs, createReadStream } from 'fs';\r\nimport { join, isAbsolute, dirname } from 'path';\r\nimport inquirer from 'inquirer';\r\nimport clipboard from 'clipboardy';\r\n\r\nexport function initIOProvider(): void {\r\n  initFileProvider();\r\n  initUserInteractionProvider();\r\n}\r\n\r\n\r\nfunction initFileProvider(): void {\r\n  fileProvider.isAbsolute = async (fileName: models.PathLike) => isAbsolute(fileProvider.toString(fileName));\r\n  fileProvider.dirname = (fileName: string) => dirname(fileProvider.toString(fileName));\r\n  fileProvider.joinPath = (fileName: models.PathLike, path: string): models.PathLike => join(fileProvider.toString(fileName), path);\r\n\r\n  fileProvider.exists = async (fileName: models.PathLike): Promise<boolean> => {\r\n    try {\r\n      return !!(await fs.stat(fileProvider.toString(fileName)));\r\n    } catch (err) {\r\n      return false;\r\n    }\r\n  };\r\n  fileProvider.readFile = async (fileName: models.PathLike, encoding: models.FileEnconding): Promise<string> => {\r\n    const file = fileProvider.fsPath(fileName);\r\n    return fs.readFile(file, encoding);\r\n  };\r\n  fileProvider.readBuffer = async (fileName: models.PathLike) => {\r\n    const file = fileProvider.fsPath(fileName);\r\n    const stream = createReadStream(file);\r\n    return toBuffer(stream);\r\n  };\r\n  fileProvider.writeBuffer = (fileName: models.PathLike, buffer: Buffer) => fs.writeFile(fileProvider.toString(fileName), buffer);\r\n  fileProvider.readdir = async (dirname: models.PathLike): Promise<string[]> => fs.readdir(fileProvider.toString(dirname));\r\n}\r\n\r\n\r\nfunction toBuffer(stream: NodeJS.ReadableStream): Promise<Buffer> {\r\n  return new Promise<Buffer>((resolve, reject) => {\r\n    const buffers: Buffer[] = [];\r\n    stream.on('data', obj => {\r\n      if (Buffer.isBuffer(obj)) {\r\n        buffers.push(obj);\r\n      } else {\r\n        buffers.push(Buffer.from(obj));\r\n      }\r\n    });\r\n    stream.on('end', () => resolve(Buffer.concat(buffers)));\r\n    stream.on('error', error => reject(error));\r\n    stream.resume();\r\n  });\r\n}\r\n\r\n\r\nfunction initUserInteractionProvider() {\r\n\r\n  userInteractionProvider.showNote = async function showNote(note: string) {\r\n    const answer = await inquirer.prompt([{\r\n      type: 'confirm',\r\n      name: 'note',\r\n      message: note,\r\n    }]);\r\n    return answer.note;\r\n  };\r\n  userInteractionProvider.showInputPrompt = async function showInputPrompt(message: string, defaultValue?: string) {\r\n    const answer = await inquirer.prompt([{\r\n      type: 'input',\r\n      name: 'placeholder',\r\n      message,\r\n      default: defaultValue\r\n    }]);\r\n    return answer.placeholder;\r\n  };\r\n  userInteractionProvider.showListPrompt = async function showListPrompt(message: string, values: string[]) {\r\n    const answer = await inquirer.prompt([{\r\n      type: 'list',\r\n      name: 'placeholder',\r\n      message,\r\n      choices: values\r\n    }]);\r\n    return answer.placeholder;\r\n  };\r\n  userInteractionProvider.getClipboard = async function getClipboard() {\r\n    return await clipboard.read();\r\n  };\r\n  userInteractionProvider.setClipboard = async function setClipboard(message: string) {\r\n    await clipboard.write(message);\r\n  };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
